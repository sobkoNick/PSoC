FILE: .\boot.asm                        (0001) ; Generated by PSoC Designer 5.1.2110.0
                                        (0002) ;
                                        (0003) ;@Id: boot.tpl#892 @
                                        (0004) ;=============================================================================
                                        (0005) ;  FILENAME:   boot.asm
                                        (0006) ;  Version:    4.21
                                        (0007) ;
                                        (0008) ;  DESCRIPTION:
                                        (0009) ;  M8C Boot Code for CY8C24x90 microcontroller devices.
                                        (0010) ;
                                        (0011) ;  Copyright (c) Cypress Semiconductor 2010. All Rights Reserved.
                                        (0012) ;
                                        (0013) ; NOTES:
                                        (0014) ; PSoC Designer's Device Editor uses a template file, BOOT.TPL, located in
                                        (0015) ; the project's root directory to create BOOT.ASM. Any changes made to
                                        (0016) ; BOOT.ASM will be  overwritten every time the project is generated; therefore
                                        (0017) ; changes should be made to BOOT.TPL not BOOT.ASM. Care must be taken when
                                        (0018) ; modifying BOOT.TPL so that replacement strings (such as @PROJECT_NAME)
                                        (0019) ; are not accidentally modified.
                                        (0020) ;
                                        (0021) ;=============================================================================
                                        (0022) 
                                        (0023) include ".\lib\GlobalParams.inc"	;File generated by PSoC Designer (Project dependent)
                                        (0024) include "m8c.inc"			;Part specific file
                                        (0025) include "m8ssc.inc"			;Part specific file
                                        (0026) include "memory.inc"			;File generated by PSoC Designer (Project dependent)
                                        (0027) 
                                        (0028) ;--------------------------------------
                                        (0029) ; Export Declarations
                                        (0030) ;--------------------------------------
                                        (0031) 
                                        (0032) export __Start
                                        (0033) IF	(TOOLCHAIN & HITECH)
                                        (0034) ELSE
                                        (0035) export __bss_start
                                        (0036) export __data_start
                                        (0037) export __idata_start
                                        (0038) export __func_lit_start
                                        (0039) export __text_start
                                        (0040) ENDIF
                                        (0041) export  _bGetPowerSetting
                                        (0042) export   bGetPowerSetting
                                        (0043) 
                                        (0044) 
                                        (0045) ;--------------------------------------
                                        (0046) ; Optimization flags
                                        (0047) ;--------------------------------------
                                        (0048) ;
                                        (0049) ; To change the value of these flags, modify the file boot.tpl, not
                                        (0050) ; boot.asm. See the notes in the banner comment at the beginning of
                                        (0051) ; this file.
                                        (0052) 
                                        (0053) ; Optimization for Assembly language (only) projects and C-language projects
                                        (0054) ; that do not depend on the C compiler to initialize the values of RAM variables.
                                        (0055) ;   Set to 1: Support for C Run-time Environment initialization
                                        (0056) ;   Set to 0: Support for C not included. Faster start up, smaller code space.
                                        (0057) ;
                                        (0058) IF	(TOOLCHAIN & HITECH)
                                        (0059) ; The C compiler will customize the startup code - it's not required here
                                        (0060) 
                                        (0061) C_LANGUAGE_SUPPORT:              equ 0
                                        (0062) ELSE
                                        (0063) C_LANGUAGE_SUPPORT:              equ 1
                                        (0064) ENDIF
                                        (0065) 
                                        (0066) 
                                        (0067) ; For historical reasons, by default the boot code uses an lcall instruction
                                        (0068) ; to invoke the user's _main code. If _main executes a return instruction,
                                        (0069) ; boot provides an infinite loop. By changing the following equate from zero
                                        (0070) ; to 1, boot's lcall will be replaced by a ljmp instruction, saving two
                                        (0071) ; bytes on the stack which are otherwise required for the return address. If
                                        (0072) ; this option is enabled, _main must not return. (Beginning with the 4.2
                                        (0073) ; release, the C compiler automatically places an infinite loop at the end
                                        (0074) ; of main, rather than a return instruction.)
                                        (0075) ;
                                        (0076) ENABLE_LJMP_TO_MAIN:             equ 0
                                        (0077) 
                                        (0078) 
                                        (0079) ;-----------------------------------------------------------------------------
                                        (0080) ; Interrupt Vector Table
                                        (0081) ;-----------------------------------------------------------------------------
                                        (0082) ;
                                        (0083) ; Interrupt vector table entries are 4 bytes long.  Each one contains
                                        (0084) ; a jump instruction to an ISR (Interrupt Service Routine), although
                                        (0085) ; very short ISRs could be encoded within the table itself. Normally,
                                        (0086) ; vector jump targets are modified automatically according to the user
                                        (0087) ; modules selected. This occurs when the 'Generate Application' opera-
                                        (0088) ; tion is run causing PSoC Designer to create boot.asm and the other
                                        (0089) ; configuration files. If you need to hard code a vector, update the
                                        (0090) ; file boot.tpl, not boot.asm. See the banner comment at the beginning
                                        (0091) ; of this file.
                                        (0092) ;-----------------------------------------------------------------------------
                                        (0093) 
                                        (0094)     AREA TOP (ROM, ABS, CON)
                                        (0095) 
                                        (0096)     org   0                        ;Reset Interrupt Vector
                                        (0097) IF	(TOOLCHAIN & HITECH)
                                        (0098) ;   jmp   __Start                  ;C compiler fills in this vector
                                        (0099) ELSE
0000: 80 67    JMP   0x0068             (0100)     jmp   __Start                  ;First instruction executed following a Reset
                                        (0101) ENDIF
                                        (0102) 
                                        (0103)     org   04h                      ;Low Voltage Detect (LVD) Interrupt Vector
0004: 30       HALT                     (0104)     halt                           ;Stop execution if power falls too low
                                        (0105) 
                                        (0106)     org   08h                      ;Analog Column 0 Interrupt Vector
                                        (0107)     // call	void_handler
0008: 7E       RETI                     (0108)     reti
                                        (0109) 
                                        (0110)     org   0Ch                      ;Analog Column 1 Interrupt Vector
                                        (0111)     // call	void_handler
000C: 7E       RETI                     (0112)     reti
                                        (0113) 
                                        (0114)     org   18h                      ;VC3 Interrupt Vector
                                        (0115)     // call	void_handler
0018: 7E       RETI                     (0116)     reti
                                        (0117) 
                                        (0118)     org   1Ch                      ;GPIO Interrupt Vector
                                        (0119)     // call	void_handler
001C: 7E       RETI                     (0120)     reti
                                        (0121) 
                                        (0122)     org   20h                      ;PSoC Block DBB00 Interrupt Vector
0020: 7D 10 29 LJMP  _ADC_ADConversion_ISR(0123)     ljmp	_ADC_ADConversion_ISR
0023: 7E       RETI                     (0124)     reti
                                        (0125) 
                                        (0126)     org   24h                      ;PSoC Block DBB01 Interrupt Vector
                                        (0127)     // call	void_handler
0024: 7E       RETI                     (0128)     reti
                                        (0129) 
                                        (0130)     org   28h                      ;PSoC Block DCB02 Interrupt Vector
                                        (0131)     // call	void_handler
0028: 7E       RETI                     (0132)     reti
                                        (0133) 
                                        (0134)     org   2Ch                      ;PSoC Block DCB03 Interrupt Vector
                                        (0135)     // call	void_handler
002C: 7E       RETI                     (0136)     reti
                                        (0137) 
                                        (0138)     org   40h                      ;USB Reset Interrupt Vector
0040: 7D 13 C4 LJMP  _USBUART_1_RESET_ISR(0139)     ljmp	_USBUART_1_RESET_ISR
0043: 7E       RETI                     (0140)     reti
                                        (0141) 
                                        (0142)     org   44h                      ;USB SOF Interrupt Vector
0044: 7D 13 E9 LJMP  _USBUART_1_SOF_ISR (0143)     ljmp	_USBUART_1_SOF_ISR
0047: 7E       RETI                     (0144)     reti
                                        (0145) 
                                        (0146)     org   48h                      ;USB EP0 Interrupt Vector
0048: 7D 07 B2 LJMP  _USBUART_1_EP0_ISR (0147)     ljmp	_USBUART_1_EP0_ISR
004B: 7E       RETI                     (0148)     reti
                                        (0149) 
                                        (0150)     org   4Ch                      ;USB EP1 Interrupt Vector
004C: 7D 13 B4 LJMP  _USBUART_1_EP1_ISR (0151)     ljmp	_USBUART_1_EP1_ISR
004F: 7E       RETI                     (0152)     reti
                                        (0153) 
                                        (0154)     org   50h                      ;USB EP2 Interrupt Vector
0050: 7D 13 B8 LJMP  _USBUART_1_EP2_ISR (0155)     ljmp	_USBUART_1_EP2_ISR
0053: 7E       RETI                     (0156)     reti
                                        (0157) 
                                        (0158)     org   54h                      ;USB EP3 Interrupt Vector
0054: 7D 13 BC LJMP  _USBUART_1_EP3_ISR (0159)     ljmp	_USBUART_1_EP3_ISR
0057: 7E       RETI                     (0160)     reti
                                        (0161) 
                                        (0162)     org   58h                      ;USB EP4 Interrupt Vector
0058: 7D 13 C0 LJMP  _USBUART_1_EP4_ISR (0163)     ljmp	_USBUART_1_EP4_ISR
005B: 7E       RETI                     (0164)     reti
                                        (0165) 
                                        (0166)     org   5Ch                      ;USB Wakeup Interrupt Vector
005C: 7D 13 EA LJMP  _USBUART_1_WAKEUP_ISR(0167)     ljmp	_USBUART_1_WAKEUP_ISR
005F: 7E       RETI                     (0168)     reti
                                        (0169) 
                                        (0170)     org   60h                      ;PSoC I2C Interrupt Vector
                                        (0171)     // call	void_handler
0060: 7E       RETI                     (0172)     reti
                                        (0173) 
                                        (0174)     org   64h                      ;Sleep Timer Interrupt Vector
                                        (0175)     // call	void_handler
0064: 7E       RETI                     (0176)     reti
0068: 71 10    OR    F,0x10             
                                        (0177) 
                                        (0178) ;-----------------------------------------------------------------------------
                                        (0179) ;  Start of Execution.
                                        (0180) ;-----------------------------------------------------------------------------
                                        (0181) ;  The Supervisory ROM SWBootReset function has already completed the
                                        (0182) ;  calibrate1 process, loading trim values for 5 volt operation.
                                        (0183) ;
                                        (0184) 
                                        (0185) IF	(TOOLCHAIN & HITECH)
                                        (0186)  	AREA PD_startup(CODE, REL, CON)
                                        (0187) ELSE
                                        (0188)     org 68h
                                        (0189) ENDIF
                                        (0190) __Start:
                                        (0191) 
                                        (0192)     ; initialize values for voltage stabilization, if required,
                                        (0193)     ; leaving power-on reset (POR) level at the default (low) level, at
                                        (0194)     ; least for now. 
                                        (0195)     ;
                                        (0196)     M8C_SetBank1
006A: 62 FA 00 MOV   REG[0xFA],0x0      (0197)     mov reg[0FAh], 0				;Reset flash location
006D: 62 E3 07 MOV   REG[0xE3],0x7      (0198)     mov   reg[VLT_CR], LVD_TBEN_JUST | TRIP_VOLTAGE_JUST
0070: 70 EF    AND   F,0xEF             
                                        (0199)     M8C_SetBank0
                                        (0200) 
                                        (0201)     ; %53%20%46%46% Apply Erratum 001-05137 workaround
0072: 50 20    MOV   A,0x20             (0202)     mov   A, 20h
0074: 28       ROMX                     (0203)     romx
0075: 62 E3 38 MOV   REG[0xE3],0x38     
                                        (0204)     ; %45%20%46%46% End workaround
                                        (0205) 	
                                        (0206) M8C_ClearWDTAndSleep			   ; Clear WDT before enabling it.
                                        (0207) IF ( WATCHDOG_ENABLE )             ; WDT selected in Global Params
                                        (0208)     M8C_EnableWatchDog
                                        (0209) ENDIF
                                        (0210) 
0078: 41 FE FB AND   REG[0xFE],0xFB     (0211)     and  reg[CPU_SCR1], ~CPU_SCR1_ECO_ALLOWED  ; Prevent ECO from being enabled
                                        (0212) 
                                        (0213)     ;---------------------------
                                        (0214)     ; Set up the Temporary stack
                                        (0215)     ;---------------------------
                                        (0216)     ; A temporary stack is set up for the SSC instructions.
                                        (0217)     ; The real stack start will be assigned later.
                                        (0218)     ;
                                        (0219) _stack_start:          equ 80h
007B: 50 80    MOV   A,0x80             (0220)     mov   A, _stack_start          ; Set top of stack to end of used RAM
007D: 4E       SWAP  SP,A               (0221)     swap  SP, A                    ; This is only temporary if going to LMM
007E: 62 E3 38 MOV   REG[0xE3],0x38     
                                        (0222) 
                                        (0223)     ;------------------------
                                        (0224)     ; Set Power-related Trim 
                                        (0225)     ;------------------------
                                        (0226) M8C_ClearWDTAndSleep ; Clear WDT before enabling it.
                                        (0227) IF ( POWER_SETTING & POWER_SET_5V0)            ; *** 5.0 Volt operation   ***
                                        (0228) 
                                        (0229)   IF ( AGND_BYPASS )
                                        (0230)     ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                        (0231)     ; The 5V trim has already been set, but we need to update the AGNDBYP
                                        (0232)     ; bit in the write-only BDG_TR register. Recalculate the register
                                        (0233)     ; value using the proper trim values.
                                        (0234)     ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                        (0235)     M8SSC_SetTableVoltageTrim 1, SSCTBL1_TRIM_BGR_5V, AGND_BYPASS_JUST
                                        (0236)   ENDIF
                                        (0237) ELSE
                                        (0238) 	; 3.3V operation trim codes
                                        (0239) 	; Set the IMO and Bandgap trims for 3v operation
                                        (0240)     M8SSC_SetTableTrims  1, SSCTBL1_TRIM_IMO_3V_24MHZ, SSCTBL1_TRIM_BGR_3V, AGN_BYPASS_JUST
                                        (0241) 	
                                        (0242) 	; Set the IMO Gain Trim for 3v operation
                                        (0243) 	M8SSC_SetTableIMOGainTrim 2, SSCTBL2_TRIM_IMO_GAIN_3V
                                        (0244) 
                                        (0245) ENDIF ; 3.3 Volt Operation
                                        (0246) 
0081: 55 F8 00 MOV   [pTemp+75],0x0     (0247)     mov  [bSSC_KEY1],  0           ; Lock out Flash and Supervisiory operations
0084: 55 F9 00 MOV   [pTemp+76],0x0     (0248)     mov  [bSSC_KEYSP], 0
0087: 71 10    OR    F,0x10             
                                        (0249) 				
                                        (0250)     ;---------------------------------------
                                        (0251)     ; Initialize Crystal Oscillator and PLL
                                        (0252)     ;---------------------------------------
                                        (0253) 
                                        (0254)     ; Either no ECO, or waiting for stable clock is to be done in main
                                        (0255)     M8C_SetBank1
0089: 62 E0 02 MOV   REG[0xE0],0x2      (0256)     mov   reg[OSC_CR0], (SLEEP_TIMER_JUST | OSC_CR0_CPU_12MHz)
008C: 70 EF    AND   F,0xEF             
008E: 62 E3 38 MOV   REG[0xE3],0x38     
0091: 62 D1 03 MOV   REG[0xD1],0x3      
                                        (0257)     M8C_SetBank0
                                        (0258)     M8C_ClearWDTAndSleep           ; Reset the watch dog
                                        (0259) 
                                        (0260)     ;------------------------------------------------------- 
                                        (0261)     ; Initialize Proper Drive Mode for External Clock Pin
                                        (0262)     ;-------------------------------------------------------
                                        (0263)  
                                        (0264)     ; Change EXTCLK pin from Hi-Z Analog (110b) drive mode to Hi-Z (010b) drive mode
                                        (0265) IF (SYSCLK_SOURCE)
                                        (0266)     and reg[PRT1DM2],  ~0x10        ; Clear bit 4 of EXTCLK pin's DM2 register  
                                        (0267) ENDIF 
                                        (0268)     ; EXTCLK pin is now in proper drive mode to input the external clock signal
                                        (0269) 
                                        (0270) 
                                        (0271) 
                                        (0272) IF	(TOOLCHAIN & HITECH)
                                        (0273)     ;---------------------------------------------
                                        (0274)     ; HI-TECH initialization: Enter the Large Memory Model, if applicable
                                        (0275)     ;---------------------------------------------
                                        (0276) 	global		__Lstackps
                                        (0277) 	mov     a,low __Lstackps
                                        (0278) 	swap    a,sp
                                        (0279) 
                                        (0280) IF ( SYSTEM_LARGE_MEMORY_MODEL )
                                        (0281)     RAM_SETPAGE_STK SYSTEM_STACK_PAGE      ; relocate stack page ...
                                        (0282)     RAM_SETPAGE_IDX2STK            ; initialize other page pointers
                                        (0283)     RAM_SETPAGE_CUR 0
                                        (0284)     RAM_SETPAGE_MVW 0
                                        (0285)     RAM_SETPAGE_MVR 0
                                        (0286)     IF ( SYSTEM_IDXPG_TRACKS_STK_PP ); Now enable paging:
                                        (0287)       or    F, FLAG_PGMODE_11b       ; LMM w/ IndexPage<==>StackPage
                                        (0288)     ELSE
                                        (0289)       or    F, FLAG_PGMODE_10b       ; LMM w/ independent IndexPage
                                        (0290)     ENDIF ;  SYSTEM_IDXPG_TRACKS_STK_PP
                                        (0291) ENDIF ;  SYSTEM_LARGE_MEMORY_MODEL
                                        (0292) ELSE
                                        (0293)     ;---------------------------------------------
                                        (0294)     ; ImageCraft Enter the Large Memory Model, if applicable
                                        (0295)     ;---------------------------------------------
                                        (0296) IF ( SYSTEM_LARGE_MEMORY_MODEL )
                                        (0297)     RAM_SETPAGE_STK SYSTEM_STACK_PAGE      ; relocate stack page ...
0094: 50 00    MOV   A,0x0              (0298)     mov   A, SYSTEM_STACK_BASE_ADDR        ;   and offset, if any
0096: 4E       SWAP  SP,A               (0299)     swap  A, SP
0097: 62 D3 03 MOV   REG[0xD3],0x3      
009A: 62 D0 00 MOV   REG[0xD0],0x0      
009D: 62 D5 00 MOV   REG[0xD5],0x0      
00A0: 62 D4 00 MOV   REG[0xD4],0x0      
                                        (0300)     RAM_SETPAGE_IDX2STK            ; initialize other page pointers
                                        (0301)     RAM_SETPAGE_CUR 0
                                        (0302)     RAM_SETPAGE_MVW 0
                                        (0303)     RAM_SETPAGE_MVR 0
                                        (0304) 
                                        (0305)   IF ( SYSTEM_IDXPG_TRACKS_STK_PP ); Now enable paging:
00A3: 71 C0    OR    F,0xC0             (0306)     or    F, FLAG_PGMODE_11b       ; LMM w/ IndexPage<==>StackPage
                                        (0307)   ELSE
                                        (0308)     or    F, FLAG_PGMODE_10b       ; LMM w/ independent IndexPage
                                        (0309)   ENDIF ;  SYSTEM_IDXPG_TRACKS_STK_PP
                                        (0310) ELSE
                                        (0311)     mov   A, __ramareas_end        ; Set top of stack to end of used RAM
                                        (0312)     swap  SP, A
                                        (0313) ENDIF ;  SYSTEM_LARGE_MEMORY_MODEL
                                        (0314) ENDIF ;	TOOLCHAIN
                                        (0315) 
                                        (0316)     ;------------------------
                                        (0317)     ; Close CT leakage path.
                                        (0318)     ;------------------------
00A5: 62 71 05 MOV   REG[0x71],0x5      (0319)     mov   reg[ACB00CR0], 05h
00A8: 62 75 05 MOV   REG[0x75],0x5      (0320)     mov   reg[ACB01CR0], 05h
                                        (0321) 
                                        (0322)     ;-------------------------
                                        (0323)     ; Load Base Configuration
                                        (0324)     ;-------------------------
                                        (0325)     ; Load global parameter settings and load the user modules in the
                                        (0326)     ; base configuration. Exceptions: (1) Leave CPU Speed fast as possible
                                        (0327)     ; to minimize start up time; (2) We may still need to play with the
                                        (0328)     ; Sleep Timer.
                                        (0329)     ;
00AB: 7C 04 8C LCALL 0x048C             (0330)     lcall LoadConfigInit
00AE: 71 10    OR    F,0x10             
                                        (0331) 	M8C_SetBank1
00B0: 41 E7 3F AND   REG[0xE7],0x3F     (0332) 	and  reg[DEC_CR1], 0x3F
00B3: 43 E7 80 OR    REG[0xE7],0x80     (0333) 	or   reg[DEC_CR1], 0x80
00B6: 70 EF    AND   F,0xEF             
                                        (0334) 	M8C_SetBank0
                                        (0335)     ;-----------------------------------
                                        (0336)     ; Initialize C Run-Time Environment
                                        (0337)     ;-----------------------------------
                                        (0338) IF ( C_LANGUAGE_SUPPORT )
                                        (0339) IF ( SYSTEM_SMALL_MEMORY_MODEL )
                                        (0340)     mov  A,0                           ; clear the 'bss' segment to zero
                                        (0341)     mov  [__r0],<__bss_start
                                        (0342) BssLoop:
                                        (0343)     cmp  [__r0],<__bss_end
                                        (0344)     jz   BssDone
                                        (0345)     mvi  [__r0],A
                                        (0346)     jmp  BssLoop
                                        (0347) BssDone:
                                        (0348)     mov  A,>__idata_start              ; copy idata to data segment
                                        (0349)     mov  X,<__idata_start
                                        (0350)     mov  [__r0],<__data_start
                                        (0351) IDataLoop:
                                        (0352)     cmp  [__r0],<__data_end
                                        (0353)     jz   C_RTE_Done
                                        (0354)     push A
                                        (0355)     romx
                                        (0356)     mvi  [__r0],A
                                        (0357)     pop  A
                                        (0358)     inc  X
                                        (0359)     adc  A,0
                                        (0360)     jmp  IDataLoop
                                        (0361) 
                                        (0362) ENDIF ; SYSTEM_SMALL_MEMORY_MODEL
                                        (0363) 
                                        (0364) IF ( SYSTEM_LARGE_MEMORY_MODEL )
00B8: 62 D0 00 MOV   REG[0xD0],0x0      (0365)     mov   reg[CUR_PP], >__r0           ; force direct addr mode instructions
                                        (0366)                                        ; to use the Virtual Register page.
                                        (0367) 
                                        (0368)     ; Dereference the constant (flash) pointer pXIData to access the start
                                        (0369)     ; of the extended idata area, "xidata." Xidata follows the end of the
                                        (0370)     ; text segment and may have been relocated by the Code Compressor.
                                        (0371)     ;
00BB: 50 03    MOV   A,0x3              (0372)     mov   A, >__pXIData                ; Get the address of the flash
00BD: 57 A5    MOV   X,0xA5             (0373)     mov   X, <__pXIData                ;   pointer to the xidata area.
00BF: 08       PUSH  A                  (0374)     push  A
00C0: 28       ROMX                     (0375)     romx                               ; get the MSB of xidata's address
00C1: 53 AC    MOV   [__r0],A           (0376)     mov   [__r0], A
00C3: 18       POP   A                  (0377)     pop   A
00C4: 75       INC   X                  (0378)     inc   X
00C5: 09 00    ADC   A,0x0              (0379)     adc   A, 0
00C7: 28       ROMX                     (0380)     romx                               ; get the LSB of xidata's address
00C8: 4B       SWAP  A,X                (0381)     swap  A, X
00C9: 51 AC    MOV   A,[__r0]           (0382)     mov   A, [__r0]                    ; pXIData (in [A,X]) points to the
                                        (0383)                                        ;   XIData structure list in flash
00CB: 80 04    JMP   0x00D0             (0384)     jmp   .AccessStruct
                                        (0385) 
                                        (0386)     ; Unpack one element in the xidata "structure list" that specifies the
                                        (0387)     ; values of C variables. Each structure contains 3 member elements.
                                        (0388)     ; The first is a pointer to a contiguous block of RAM to be initial-
                                        (0389)     ; ized. Blocks are always 255 bytes or less in length and never cross
                                        (0390)     ; RAM page boundaries. The list terminates when the MSB of the pointer
                                        (0391)     ; contains 0xFF. There are two formats for the struct depending on the
                                        (0392)     ; value in the second member element, an unsigned byte:
                                        (0393)     ; (1) If the value of the second element is non-zero, it represents
                                        (0394)     ; the 'size' of the block of RAM to be initialized. In this case, the
                                        (0395)     ; third member of the struct is an array of bytes of length 'size' and
                                        (0396)     ; the bytes are copied to the block of RAM.
                                        (0397)     ; (2) If the value of the second element is zero, the block of RAM is
                                        (0398)     ; to be cleared to zero. In this case, the third member of the struct
                                        (0399)     ; is an unsigned byte containing the number of bytes to clear.
                                        (0400) 
                                        (0401) .AccessNextStructLoop:
00CD: 75       INC   X                  (0402)     inc   X                            ; pXIData++
00CE: 09 00    ADC   A,0x0              (0403)     adc   A, 0
00D0: 62 E3 00 MOV   REG[0xE3],0x0      
                                        (0404) .AccessStruct:                         ; Entry point for first block
                                        (0405)     ;
                                        (0406)     ; Assert: pXIData in [A,X] points to the beginning of an XIData struct.
                                        (0407)     ;
                                        (0408)     M8C_ClearWDT                       ; Clear the watchdog for long inits
00D3: 08       PUSH  A                  (0409)     push  A
00D4: 28       ROMX                     (0410)     romx                               ; MSB of RAM addr (CPU.A <- *pXIData)
00D5: 60 D5    MOV   REG[0xD5],A        (0411)     mov   reg[MVW_PP], A               ;   for use with MVI write operations
00D7: 74       INC   A                  (0412)     inc   A                            ; End of Struct List? (MSB==0xFF?)
00D8: A0 4B    JZ    0x0124             (0413)     jz    .C_RTE_WrapUp                ;   Yes, C runtime environment complete
00DA: 18       POP   A                  (0414)     pop   A                            ; restore pXIData to [A,X]
00DB: 75       INC   X                  (0415)     inc   X                            ; pXIData++
00DC: 09 00    ADC   A,0x0              (0416)     adc   A, 0
00DE: 08       PUSH  A                  (0417)     push  A
00DF: 28       ROMX                     (0418)     romx                               ; LSB of RAM addr (CPU.A <- *pXIData)
00E0: 53 AC    MOV   [__r0],A           (0419)     mov   [__r0], A                    ; RAM Addr now in [reg[MVW_PP],[__r0]]
00E2: 18       POP   A                  (0420)     pop   A                            ; restore pXIData to [A,X]
00E3: 75       INC   X                  (0421)     inc   X                            ; pXIData++ (point to size)
00E4: 09 00    ADC   A,0x0              (0422)     adc   A, 0
00E6: 08       PUSH  A                  (0423)     push  A
00E7: 28       ROMX                     (0424)     romx                               ; Get the size (CPU.A <- *pXIData)
00E8: A0 1C    JZ    0x0105             (0425)     jz    .ClearRAMBlockToZero         ; If Size==0, then go clear RAM
00EA: 53 AB    MOV   [__r1],A           (0426)     mov   [__r1], A                    ;             else downcount in __r1
00EC: 18       POP   A                  (0427)     pop   A                            ; restore pXIData to [A,X]
                                        (0428) 
                                        (0429) .CopyNextByteLoop:
                                        (0430)     ; For each byte in the structure's array member, copy from flash to RAM.
                                        (0431)     ; Assert: pXIData in [A,X] points to previous byte of flash source;
                                        (0432)     ;         [reg[MVW_PP],[__r0]] points to next RAM destination;
                                        (0433)     ;         __r1 holds a non-zero count of the number of bytes remaining.
                                        (0434)     ;
00ED: 75       INC   X                  (0435)     inc   X                            ; pXIData++ (point to next data byte)
00EE: 09 00    ADC   A,0x0              (0436)     adc   A, 0
00F0: 08       PUSH  A                  (0437)     push  A
00F1: 28       ROMX                     (0438)     romx                               ; Get the data value (CPU.A <- *pXIData)
00F2: 3F AC    MVI   [__r0],A           (0439)     mvi   [__r0], A                    ; Transfer the data to RAM
00F4: 47 AC FF TST   [__r0],0xFF        (0440)     tst   [__r0], 0xff                 ; Check for page crossing
00F7: B0 06    JNZ   0x00FE             (0441)     jnz   .CopyLoopTail                ;   No crossing, keep going
00F9: 5D D5    MOV   A,REG[0xD5]        (0442)     mov   A, reg[ MVW_PP]              ;   If crossing, bump MVW page reg
00FB: 74       INC   A                  (0443)     inc   A
00FC: 60 D5    MOV   REG[0xD5],A        (0444)     mov   reg[ MVW_PP], A
                                        (0445) .CopyLoopTail:
00FE: 18       POP   A                  (0446)     pop   A                            ; restore pXIData to [A,X]
00FF: 7A AB    DEC   [__r1]             (0447)     dec   [__r1]                       ; End of this array in flash?
0101: BF EB    JNZ   0x00ED             (0448)     jnz   .CopyNextByteLoop            ;   No,  more bytes to copy
0103: 8F C9    JMP   0x00CD             (0449)     jmp   .AccessNextStructLoop        ;   Yes, initialize another RAM block
                                        (0450) 
                                        (0451) .ClearRAMBlockToZero:
0105: 18       POP   A                  (0452)     pop   A                            ; restore pXIData to [A,X]
0106: 75       INC   X                  (0453)     inc   X                            ; pXIData++ (point to next data byte)
0107: 09 00    ADC   A,0x0              (0454)     adc   A, 0
0109: 08       PUSH  A                  (0455)     push  A
010A: 28       ROMX                     (0456)     romx                               ; Get the run length (CPU.A <- *pXIData)
010B: 53 AB    MOV   [__r1],A           (0457)     mov   [__r1], A                    ; Initialize downcounter
010D: 50 00    MOV   A,0x0              (0458)     mov   A, 0                         ; Initialize source data
                                        (0459) 
                                        (0460) .ClearRAMBlockLoop:
                                        (0461)     ; Assert: [reg[MVW_PP],[__r0]] points to next RAM destination and
                                        (0462)     ;         __r1 holds a non-zero count of the number of bytes remaining.
                                        (0463)     ;
010F: 3F AC    MVI   [__r0],A           (0464)     mvi   [__r0], A                    ; Clear a byte
0111: 47 AC FF TST   [__r0],0xFF        (0465)     tst   [__r0], 0xff                 ; Check for page crossing
0114: B0 08    JNZ   0x011D             (0466)     jnz   .ClearLoopTail               ;   No crossing, keep going
0116: 5D D5    MOV   A,REG[0xD5]        (0467)     mov   A, reg[ MVW_PP]              ;   If crossing, bump MVW page reg
0118: 74       INC   A                  (0468)     inc   A
0119: 60 D5    MOV   REG[0xD5],A        (0469)     mov   reg[ MVW_PP], A
011B: 50 00    MOV   A,0x0              (0470)     mov   A, 0                         ; Restore the zero used for clearing
                                        (0471) .ClearLoopTail:
011D: 7A AB    DEC   [__r1]             (0472)     dec   [__r1]                       ; Was this the last byte?
011F: BF EF    JNZ   0x010F             (0473)     jnz   .ClearRAMBlockLoop           ;   No,  continue
0121: 18       POP   A                  (0474)     pop   A                            ;   Yes, restore pXIData to [A,X] and
0122: 8F AA    JMP   0x00CD             (0475)     jmp   .AccessNextStructLoop        ;        initialize another RAM block
                                        (0476) 
                                        (0477) .C_RTE_WrapUp:
0124: 18       POP   A                  (0478)     pop   A                            ; balance stack
0125: 71 10    OR    F,0x10             
                                        (0479) 
                                        (0480) ENDIF ; SYSTEM_LARGE_MEMORY_MODEL
                                        (0481) 
                                        (0482) C_RTE_Done:
                                        (0483) 
                                        (0484) ENDIF ; C_LANGUAGE_SUPPORT
                                        (0485) 
                                        (0486) 
                                        (0487)     ;-------------------------------
                                        (0488)     ; Set Power-On Reset (POR) Level
                                        (0489)     ;-------------------------------
                                        (0490) 
                                        (0491)     ;  The writes to the VLT_CR register below include setting the POR to VLT_CR_POR_HIGH,
                                        (0492)     ;  VLT_CR_POR_MID or VLT_CR_POR_LOW. Correctly setting this value is critical to the proper
                                        (0493)     ;  operation of the PSoC. The POR protects the M8C from mis-executing when Vdd falls low. These
                                        (0494)     ;  values should not be changed from the settings here. Failure to follow this instruction could 
                                        (0495)     ;  lead to corruption of PSoC flash.
                                        (0496) 
                                        (0497)     M8C_SetBank1
                                        (0498) 
                                        (0499) IF (POWER_SETTING & POWER_SET_3V3)             ; 3.3V Operation?
                                        (0500)     or   reg[VLT_CR], VLT_CR_POR_LOW           ;   Yes, change to midpoint trip
                                        (0501) ELSE										   ; 5V Operation
                                        (0502)   IF ( CPU_CLOCK_JUST ^ OSC_CR0_CPU_24MHz )    ;      As fast as 24MHz?
0127: 43 E3 00 OR    REG[0xE3],0x0      (0503)     or   reg[VLT_CR], VLT_CR_POR_LOW           ;         No, change to midpoint trip
012A: 70 EF    AND   F,0xEF             
                                        (0504)   ELSE ; 24HMz                                 ;
                                        (0505)     or    reg[VLT_CR], VLT_CR_POR_HIGH         ;        Yes, switch to	highest setting
                                        (0506)   ENDIF ; 24MHz
                                        (0507) ENDIF ; 3.3V Operation
                                        (0508) 
                                        (0509)     M8C_SetBank0
                                        (0510) 
                                        (0511)     ;----------------------------
                                        (0512)     ; Wrap up and invoke "main"
                                        (0513)     ;----------------------------
                                        (0514) 
                                        (0515)     ; Disable the Sleep interrupt that was used for timing above.  In fact,
                                        (0516)     ; no interrupts should be enabled now, so may as well clear the register.
                                        (0517)     ;
012C: 62 E0 00 MOV   REG[0xE0],0x0      (0518)     mov  reg[INT_MSK0],0
012F: 71 10    OR    F,0x10             
                                        (0519) 
                                        (0520)     ; Everything has started OK. Now select requested CPU & sleep frequency.
                                        (0521)     ;
                                        (0522)     M8C_SetBank1
0131: 62 E0 00 MOV   REG[0xE0],0x0      (0523)     mov  reg[OSC_CR0],(SLEEP_TIMER_JUST | CPU_CLOCK_JUST)
0134: 70 EF    AND   F,0xEF             
                                        (0524)     M8C_SetBank0
                                        (0525) 
                                        (0526)     ; Global Interrupt are NOT enabled, this should be done in main().
                                        (0527)     ; LVD is set but will not occur unless Global Interrupts are enabled.
                                        (0528)     ; Global Interrupts should be enabled as soon as possible in main().
                                        (0529)     ;
0136: 62 E2 00 MOV   REG[0xE2],0x0      (0530)     mov  reg[INT_VC],0             ; Clear any pending interrupts which may
                                        (0531)                                    ; have been set during the boot process.
                                        (0532) IF	(TOOLCHAIN & HITECH)
                                        (0533) 	ljmp  startup                  ; Jump to C compiler startup code
                                        (0534) ELSE
                                        (0535) IF ENABLE_LJMP_TO_MAIN
                                        (0536)     ljmp  _main                    ; goto main (no return)
                                        (0537) ELSE
0139: 7C 11 EE LCALL _main              (0538)     lcall _main                    ; call main
                                        (0539) .Exit:
013C: 8F FF    JMP   0x013C             (0540)     jmp  .Exit                     ; Wait here after return till power-off or reset
                                        (0541) ENDIF
                                        (0542) ENDIF ; TOOLCHAIN
                                        (0543) 
                                        (0544)     ;---------------------------------
                                        (0545)     ; Library Access to Global Parms
                                        (0546)     ;---------------------------------
                                        (0547)     ;
                                        (0548)  bGetPowerSetting:
                                        (0549) _bGetPowerSetting:
                                        (0550)     ; Returns value of POWER_SETTING in the A register.
                                        (0551)     ; No inputs. No Side Effects.
                                        (0552)     ;
013E: 50 10    MOV   A,0x10             (0553)     mov   A, POWER_SETTING          ; Supply voltage and internal main osc
0140: 7F       RET                      (0554)     ret
                                        (0555) 
                                        (0556) IF	(TOOLCHAIN & HITECH)
                                        (0557) ELSE
                                        (0558)     ;---------------------------------
                                        (0559)     ; Order Critical RAM & ROM AREAs
                                        (0560)     ;---------------------------------
                                        (0561)     ;  'TOP' is all that has been defined so far...
                                        (0562) 
                                        (0563)     ;  ROM AREAs for C CONST, static & global items
                                        (0564)     ;
                                        (0565)     AREA lit               (ROM, REL, CON)   ; 'const' definitions
                                        (0566)     AREA idata             (ROM, REL, CON)   ; Constants for initializing RAM
                                        (0567) __idata_start:
                                        (0568) 
                                        (0569)     AREA func_lit          (ROM, REL, CON)   ; Function Pointers
                                        (0570) __func_lit_start:
                                        (0571) 
                                        (0572) IF ( SYSTEM_LARGE_MEMORY_MODEL )
                                        (0573)     ; We use the func_lit area to store a pointer to extended initialized
                                        (0574)     ; data (xidata) area that follows the text area. Func_lit isn't
                                        (0575)     ; relocated by the code compressor, but the text area may shrink and
                                        (0576)     ; that moves xidata around.
                                        (0577)     ;
                                        (0578) __pXIData:         word __text_end           ; ptr to extended idata
                                        (0579) ENDIF
                                        (0580) 
                                        (0581)     AREA psoc_config       (ROM, REL, CON)   ; Configuration Load & Unload
                                        (0582)     AREA UserModules       (ROM, REL, CON)   ; User Module APIs
                                        (0583) 
                                        (0584)     ; CODE segment for general use
                                        (0585)     ;
                                        (0586)     AREA text (ROM, REL, CON)
                                        (0587) __text_start:
                                        (0588) 
                                        (0589)     ; RAM area usage
                                        (0590)     ;
                                        (0591)     AREA data              (RAM, REL, CON)   ; initialized RAM
                                        (0592) __data_start:
                                        (0593) 
                                        (0594)     AREA virtual_registers (RAM, REL, CON)   ; Temp vars of C compiler
                                        (0595)     AREA InterruptRAM      (RAM, REL, CON)   ; Interrupts, on Page 0
                                        (0596)     AREA bss               (RAM, REL, CON)   ; general use
                                        (0597) __bss_start:
                                        (0598) 
                                        (0599) ENDIF ; TOOLCHAIN
                                        (0600) 
                                        (0601) ; end of file boot.asm
    0141: 30       HALT  
    0142: 30       HALT  
    0143: 30       HALT  
    0144: 30       HALT  
    0145: 30       HALT  
    0146: 30       HALT  
    0147: 30       HALT  
    0148: 30       HALT  
    0149: 30       HALT  
    014A: 30       HALT  
    014B: 30       HALT  
    014C: 30       HALT  
    014D: 30       HALT  
    014E: 30       HALT  
    014F: 30       HALT  
    0150: 30       HALT  
    0151: 30       HALT  
    0152: 30       HALT  
    0153: 30       HALT  
    0154: 30       HALT  
    0155: 30       HALT  
    0156: 30       HALT  
    0157: 30       HALT  
    0158: 30       HALT  
    0159: 30       HALT  
    015A: 30       HALT  
    015B: 30       HALT  
    015C: 30       HALT  
    015D: 30       HALT  
    015E: 30       HALT  
    015F: 30       HALT  
    0160: 30       HALT  
    0161: 30       HALT  
    0162: 30       HALT  
    0163: 30       HALT  
    0164: 30       HALT  
    0165: 30       HALT  
    0166: 30       HALT  
    0167: 30       HALT  
    0168: 30       HALT  
    0169: 30       HALT  
    016A: 30       HALT  
    016B: 30       HALT  
    016C: 30       HALT  
    016D: 30       HALT  
    016E: 30       HALT  
    016F: 30       HALT  
    0170: 30       HALT  
    0171: 30       HALT  
    0172: 30       HALT  
    0173: 30       HALT  
    0174: 30       HALT  
    0175: 30       HALT  
    0176: 30       HALT  
    0177: 30       HALT  
    0178: 30       HALT  
    0179: 30       HALT  
    017A: 30       HALT  
    017B: 30       HALT  
    017C: 30       HALT  
    017D: 30       HALT  
    017E: 30       HALT  
    017F: 30       HALT  
    0180: 30       HALT  
    0181: 30       HALT  
    0182: 30       HALT  
    0183: 30       HALT  
    0184: 30       HALT  
    0185: 30       HALT  
    0186: 30       HALT  
    0187: 30       HALT  
    0188: 30       HALT  
    0189: 30       HALT  
    018A: 30       HALT  
    018B: 30       HALT  
    018C: 30       HALT  
    018D: 30       HALT  
    018E: 30       HALT  
    018F: 30       HALT  
    0190: 30       HALT  
    0191: 30       HALT  
    0192: 30       HALT  
    0193: 30       HALT  
    0194: 30       HALT  
    0195: 30       HALT  
    0196: 30       HALT  
    0197: 30       HALT  
    0198: 30       HALT  
    0199: 30       HALT  
    019A: 30       HALT  
    019B: 30       HALT  
    019C: 30       HALT  
    019D: 30       HALT  
    019E: 30       HALT  
    019F: 30       HALT  
    01A0: 45 6E 64 XOR   REG[0x6E],0x64
    01A3: 20       POP   X
    01A4: 6F 66    RRC   [X+102]
    01A6: 20       POP   X
    01A7: 54 65    MOV   [X+101],A
FILE: lib\psocconfigtbl.asm             (0001) ; Generated by PSoC Designer 5.1.2110.0
03A7: 70 EF    AND   F,0xEF             (0002) ;
                                        (0003) include "m8c.inc"
                                        (0004) ;  Personalization tables 
                                        (0005) export LoadConfigTBL_usbuart_Bank1
                                        (0006) export LoadConfigTBL_usbuart_Bank0
                                        (0007) export LoadConfigTBL_usbuart_Ordered
                                        (0008) AREA lit(rom, rel)
                                        (0009) LoadConfigTBL_usbuart_Bank0:
                                        (0010) ;  Instance name ADC, User Module ADCINC
                                        (0011) ;       Instance name ADC, Block Name ADC(ASD11)
                                        (0012) 	db		84h, 90h		;ADC_AtoDcr0(ASD11CR0)
                                        (0013) 	db		85h, 20h		;ADC_AtoDcr1(ASD11CR1)
                                        (0014) 	db		86h, 60h		;ADC_AtoDcr2(ASD11CR2)
                                        (0015) 	db		87h, f8h		;ADC_AtoDcr3(ASD11CR3)
                                        (0016) ;       Instance name ADC, Block Name PWM(DBB00)
                                        (0017) 	db		23h, 00h		;ADC_PWMcr0(DBB00CR0)
                                        (0018) 	db		21h, 00h		;ADC_PWMdr1(DBB00DR1)
                                        (0019) 	db		22h, 01h		;ADC_PWMdr2(DBB00DR2)
                                        (0020) ;  Instance name DAC8_1, User Module DAC8
                                        (0021) ;       Instance name DAC8_1, Block Name LSB(ASD20)
                                        (0022) 	db		90h, 80h		;DAC8_1_LSB_CR0(ASD20CR0)
                                        (0023) 	db		91h, 80h		;DAC8_1_LSB_CR1(ASD20CR1)
                                        (0024) 	db		92h, 20h		;DAC8_1_LSB_CR2(ASD20CR2)
                                        (0025) 	db		93h, 30h		;DAC8_1_LSB_CR3(ASD20CR3)
                                        (0026) ;       Instance name DAC8_1, Block Name MSB(ASC10)
                                        (0027) 	db		80h, a0h		;DAC8_1_MSB_CR0(ASC10CR0)
                                        (0028) 	db		81h, 41h		;DAC8_1_MSB_CR1(ASC10CR1)
                                        (0029) 	db		82h, a0h		;DAC8_1_MSB_CR2(ASC10CR2)
                                        (0030) 	db		83h, 3ch		;DAC8_1_MSB_CR3(ASC10CR3)
                                        (0031) ;  Instance name USBUART_1, User Module USBUART
                                        (0032) ;  Global Register values Bank 0
                                        (0033) 	db		60h, 09h		; AnalogColumnInputSelect register (AMX_IN)
                                        (0034) 	db		66h, 00h		; AnalogComparatorControl1 register (CMP_CR1)
                                        (0035) 	db		61h, 00h		; AnalogMuxBusConfig register (AMUXCFG)
                                        (0036) 	db		63h, 3dh		; AnalogReferenceControl register (ARF_CR)
                                        (0037) 	db		65h, 00h		; AnalogSyncControl register (ASY_CR)
                                        (0038) 	db		e6h, 02h		; DecimatorControl_0 register (DEC_CR0)
                                        (0039) 	db		e7h, 42h		; DecimatorControl_1 register (DEC_CR1)
                                        (0040) 	db		56h, 00h		; Endpoint0Control register (EP0_CR)
                                        (0041) 	db		57h, 00h		; Endpoint0Count register (EP0_CNT)
                                        (0042) 	db		58h, 00h		; Endpoint0Data0 register (EP0_DR0)
                                        (0043) 	db		59h, 00h		; Endpoint0Data1 register (EP0_DR1)
                                        (0044) 	db		5ah, 00h		; Endpoint0Data2 register (EP0_DR2)
                                        (0045) 	db		5bh, 00h		; Endpoint0Data3 register (EP0_DR3)
                                        (0046) 	db		5ch, 00h		; Endpoint0Data4 register (EP0_DR4)
                                        (0047) 	db		5dh, 00h		; Endpoint0Data5 register (EP0_DR5)
                                        (0048) 	db		5eh, 00h		; Endpoint0Data6 register (EP0_DR6)
                                        (0049) 	db		5fh, 00h		; Endpoint0Data7 register (EP0_DR7)
                                        (0050) 	db		4fh, 00h		; Endpoint1Count0 register (EP1_CNT)
                                        (0051) 	db		4eh, 00h		; Endpoint1Count1 register (EP1_CNT1)
                                        (0052) 	db		51h, 00h		; Endpoint2Count0 register (EP2_CNT)
                                        (0053) 	db		50h, 00h		; Endpoint2Count1 register (EP2_CNT1)
                                        (0054) 	db		53h, 00h		; Endpoint3Count0 register (EP3_CNT)
                                        (0055) 	db		52h, 00h		; Endpoint3Count1 register (EP3_CNT1)
                                        (0056) 	db		55h, 00h		; Endpoint4Count0 register (EP4_CNT)
                                        (0057) 	db		54h, 00h		; Endpoint4Count1 register (EP4_CNT1)
                                        (0058) 	db		d6h, 00h		; I2CConfig register (I2CCFG)
                                        (0059) 	db		b0h, 00h		; Row_0_InputMux register (RDI0RI)
                                        (0060) 	db		b1h, 00h		; Row_0_InputSync register (RDI0SYN)
                                        (0061) 	db		b2h, 00h		; Row_0_LogicInputAMux register (RDI0IS)
                                        (0062) 	db		b3h, 33h		; Row_0_LogicSelect_0 register (RDI0LT0)
                                        (0063) 	db		b4h, 33h		; Row_0_LogicSelect_1 register (RDI0LT1)
                                        (0064) 	db		b5h, 00h		; Row_0_OutputDrive_0 register (RDI0SRO0)
                                        (0065) 	db		b6h, 00h		; Row_0_OutputDrive_1 register (RDI0SRO1)
                                        (0066) 	db		4ah, 00h		; USBControl_0 register (USB_CR0)
                                        (0067) 	db		4bh, 00h		; USBIOControl_0 register (USBIO_CR0)
                                        (0068) 	db		4ch, 00h		; USBIOControl_1 register (USBIO_CR1)
                                        (0069) 	db		ffh
                                        (0070) LoadConfigTBL_usbuart_Bank1:
                                        (0071) ;  Instance name ADC, User Module ADCINC
                                        (0072) ;       Instance name ADC, Block Name ADC(ASD11)
                                        (0073) ;       Instance name ADC, Block Name PWM(DBB00)
                                        (0074) 	db		20h, 31h		;ADC_PWMfn(DBB00FN)
                                        (0075) 	db		21h, 15h		;ADC_PWMsl(DBB00IN)
                                        (0076) 	db		22h, 40h		;ADC_PWMos(DBB00OU)
                                        (0077) ;  Instance name DAC8_1, User Module DAC8
                                        (0078) ;       Instance name DAC8_1, Block Name LSB(ASD20)
                                        (0079) ;       Instance name DAC8_1, Block Name MSB(ASC10)
                                        (0080) ;  Instance name USBUART_1, User Module USBUART
                                        (0081) ;  Global Register values Bank 1
                                        (0082) 	db		61h, 00h		; AnalogClockSelect1 register (CLK_CR1)
                                        (0083) 	db		69h, 00h		; AnalogClockSelect2 register (CLK_CR2)
                                        (0084) 	db		60h, 00h		; AnalogColumnClockSelect register (CLK_CR0)
                                        (0085) 	db		62h, 08h		; AnalogIOControl_0 register (ABF_CR0)
                                        (0086) 	db		67h, 33h		; AnalogLUTControl0 register (ALT_CR0)
                                        (0087) 	db		68h, 00h		; AnalogLUTControl1 register (ALT_CR1)
                                        (0088) 	db		63h, 00h		; AnalogModulatorControl_0 register (AMD_CR0)
                                        (0089) 	db		66h, 00h		; AnalogModulatorControl_1 register (AMD_CR1)
                                        (0090) 	db		64h, 00h		; ComparatorGlobalOutEn register (CMP_GO_EN)
                                        (0091) 	db		64h, 00h		; ComparatorGlobalOutEn1 register (CMP_GO_EN1)
                                        (0092) 	db		fdh, 80h		; DAC_Control register (DAC_CR)
                                        (0093) 	db		c4h, 00h		; Endpoint1Control register (EP1_CR)
                                        (0094) 	db		c5h, 00h		; Endpoint2Control register (EP2_CR)
                                        (0095) 	db		c6h, 00h		; Endpoint3Control register (EP3_CR)
                                        (0096) 	db		c7h, 00h		; Endpoint4Control register (EP4_CR)
                                        (0097) 	db		d1h, 00h		; GlobalDigitalInterconnect_Drive_Even_Input register (GDI_E_IN)
                                        (0098) 	db		d3h, 00h		; GlobalDigitalInterconnect_Drive_Even_Output register (GDI_E_OU)
                                        (0099) 	db		d0h, 00h		; GlobalDigitalInterconnect_Drive_Odd_Input register (GDI_O_IN)
                                        (0100) 	db		d2h, 00h		; GlobalDigitalInterconnect_Drive_Odd_Output register (GDI_O_OU)
                                        (0101) 	db		e1h, bfh		; OscillatorControl_1 register (OSC_CR1)
                                        (0102) 	db		e2h, 00h		; OscillatorControl_2 register (OSC_CR2)
                                        (0103) 	db		dfh, 31h		; OscillatorControl_3 register (OSC_CR3)
                                        (0104) 	db		deh, 02h		; OscillatorControl_4 register (OSC_CR4)
                                        (0105) 	db		ddh, 00h		; OscillatorGlobalBusEnableControl register (OSC_GO_EN)
                                        (0106) 	db		d8h, 00h		; Port_0_MUXBusCtrl register (MUX_CR0)
                                        (0107) 	db		d9h, 00h		; Port_1_MUXBusCtrl register (MUX_CR1)
                                        (0108) 	db		dah, 00h		; Port_2_MUXBusCtrl register (MUX_CR2)
                                        (0109) 	db		dbh, 00h		; Port_3_MUXBusCtrl register (MUX_CR3)
                                        (0110) 	db		ech, 00h		; Port_4_MUXBusCtrl register (MUX_CR4)
                                        (0111) 	db		edh, 00h		; Port_5_MUXBusCtrl register (MUX_CR5)
                                        (0112) 	db		e7h, 48h		; Type2Decimator_Control register (DEC_CR2)
                                        (0113) 	db		c1h, 00h		; USBControl_1 register (USB_CR1)
                                        (0114) 	db		ffh
                                        (0115) AREA psoc_config(rom, rel)
                                        (0116) LoadConfigTBL_usbuart_Ordered:
                                        (0117) ;  Ordered Global Register values
                                        (0118) 	M8C_SetBank0
03A9: 62 00 00 MOV   REG[0x0],0x0       (0119) 	mov	reg[00h], 00h		; Port_0_Data register (PRT0DR)
03AC: 71 10    OR    F,0x10             
                                        (0120) 	M8C_SetBank1
03AE: 62 00 00 MOV   REG[0x0],0x0       (0121) 	mov	reg[00h], 00h		; Port_0_DriveMode_0 register (PRT0DM0)
03B1: 62 01 FF MOV   REG[0x1],0xFF      (0122) 	mov	reg[01h], ffh		; Port_0_DriveMode_1 register (PRT0DM1)
03B4: 70 EF    AND   F,0xEF             
                                        (0123) 	M8C_SetBank0
03B6: 62 03 FF MOV   REG[0x3],0xFF      (0124) 	mov	reg[03h], ffh		; Port_0_DriveMode_2 register (PRT0DM2)
03B9: 62 02 00 MOV   REG[0x2],0x0       (0125) 	mov	reg[02h], 00h		; Port_0_GlobalSelect register (PRT0GS)
03BC: 71 10    OR    F,0x10             
                                        (0126) 	M8C_SetBank1
03BE: 62 02 00 MOV   REG[0x2],0x0       (0127) 	mov	reg[02h], 00h		; Port_0_IntCtrl_0 register (PRT0IC0)
03C1: 62 03 00 MOV   REG[0x3],0x0       (0128) 	mov	reg[03h], 00h		; Port_0_IntCtrl_1 register (PRT0IC1)
03C4: 70 EF    AND   F,0xEF             
                                        (0129) 	M8C_SetBank0
03C6: 62 01 00 MOV   REG[0x1],0x0       (0130) 	mov	reg[01h], 00h		; Port_0_IntEn register (PRT0IE)
03C9: 62 04 00 MOV   REG[0x4],0x0       (0131) 	mov	reg[04h], 00h		; Port_1_Data register (PRT1DR)
03CC: 71 10    OR    F,0x10             
                                        (0132) 	M8C_SetBank1
03CE: 62 04 00 MOV   REG[0x4],0x0       (0133) 	mov	reg[04h], 00h		; Port_1_DriveMode_0 register (PRT1DM0)
03D1: 62 05 FF MOV   REG[0x5],0xFF      (0134) 	mov	reg[05h], ffh		; Port_1_DriveMode_1 register (PRT1DM1)
03D4: 70 EF    AND   F,0xEF             
                                        (0135) 	M8C_SetBank0
03D6: 62 07 FF MOV   REG[0x7],0xFF      (0136) 	mov	reg[07h], ffh		; Port_1_DriveMode_2 register (PRT1DM2)
03D9: 62 06 00 MOV   REG[0x6],0x0       (0137) 	mov	reg[06h], 00h		; Port_1_GlobalSelect register (PRT1GS)
03DC: 71 10    OR    F,0x10             
                                        (0138) 	M8C_SetBank1
03DE: 62 06 00 MOV   REG[0x6],0x0       (0139) 	mov	reg[06h], 00h		; Port_1_IntCtrl_0 register (PRT1IC0)
03E1: 62 07 00 MOV   REG[0x7],0x0       (0140) 	mov	reg[07h], 00h		; Port_1_IntCtrl_1 register (PRT1IC1)
03E4: 70 EF    AND   F,0xEF             
                                        (0141) 	M8C_SetBank0
03E6: 62 05 00 MOV   REG[0x5],0x0       (0142) 	mov	reg[05h], 00h		; Port_1_IntEn register (PRT1IE)
03E9: 62 08 00 MOV   REG[0x8],0x0       (0143) 	mov	reg[08h], 00h		; Port_2_Data register (PRT2DR)
03EC: 71 10    OR    F,0x10             
                                        (0144) 	M8C_SetBank1
03EE: 62 08 00 MOV   REG[0x8],0x0       (0145) 	mov	reg[08h], 00h		; Port_2_DriveMode_0 register (PRT2DM0)
03F1: 62 09 FF MOV   REG[0x9],0xFF      (0146) 	mov	reg[09h], ffh		; Port_2_DriveMode_1 register (PRT2DM1)
03F4: 70 EF    AND   F,0xEF             
                                        (0147) 	M8C_SetBank0
03F6: 62 0B FF MOV   REG[0xB],0xFF      (0148) 	mov	reg[0bh], ffh		; Port_2_DriveMode_2 register (PRT2DM2)
03F9: 62 0A 00 MOV   REG[0xA],0x0       (0149) 	mov	reg[0ah], 00h		; Port_2_GlobalSelect register (PRT2GS)
03FC: 71 10    OR    F,0x10             
                                        (0150) 	M8C_SetBank1
03FE: 62 0A 00 MOV   REG[0xA],0x0       (0151) 	mov	reg[0ah], 00h		; Port_2_IntCtrl_0 register (PRT2IC0)
0401: 62 0B 00 MOV   REG[0xB],0x0       (0152) 	mov	reg[0bh], 00h		; Port_2_IntCtrl_1 register (PRT2IC1)
0404: 70 EF    AND   F,0xEF             
                                        (0153) 	M8C_SetBank0
0406: 62 09 00 MOV   REG[0x9],0x0       (0154) 	mov	reg[09h], 00h		; Port_2_IntEn register (PRT2IE)
0409: 62 0C 00 MOV   REG[0xC],0x0       (0155) 	mov	reg[0ch], 00h		; Port_3_Data register (PRT3DR)
040C: 71 10    OR    F,0x10             
                                        (0156) 	M8C_SetBank1
040E: 62 0C 00 MOV   REG[0xC],0x0       (0157) 	mov	reg[0ch], 00h		; Port_3_DriveMode_0 register (PRT3DM0)
0411: 62 0D BF MOV   REG[0xD],0xBF      (0158) 	mov	reg[0dh], bfh		; Port_3_DriveMode_1 register (PRT3DM1)
0414: 70 EF    AND   F,0xEF             
                                        (0159) 	M8C_SetBank0
0416: 62 0F BF MOV   REG[0xF],0xBF      (0160) 	mov	reg[0fh], bfh		; Port_3_DriveMode_2 register (PRT3DM2)
0419: 62 0E 00 MOV   REG[0xE],0x0       (0161) 	mov	reg[0eh], 00h		; Port_3_GlobalSelect register (PRT3GS)
041C: 71 10    OR    F,0x10             
                                        (0162) 	M8C_SetBank1
041E: 62 0E 00 MOV   REG[0xE],0x0       (0163) 	mov	reg[0eh], 00h		; Port_3_IntCtrl_0 register (PRT3IC0)
0421: 62 0F 00 MOV   REG[0xF],0x0       (0164) 	mov	reg[0fh], 00h		; Port_3_IntCtrl_1 register (PRT3IC1)
0424: 70 EF    AND   F,0xEF             
                                        (0165) 	M8C_SetBank0
0426: 62 0D 00 MOV   REG[0xD],0x0       (0166) 	mov	reg[0dh], 00h		; Port_3_IntEn register (PRT3IE)
0429: 62 10 00 MOV   REG[0x10],0x0      (0167) 	mov	reg[10h], 00h		; Port_4_Data register (PRT4DR)
042C: 71 10    OR    F,0x10             
                                        (0168) 	M8C_SetBank1
042E: 62 10 00 MOV   REG[0x10],0x0      (0169) 	mov	reg[10h], 00h		; Port_4_DriveMode_0 register (PRT4DM0)
0431: 62 11 FF MOV   REG[0x11],0xFF     (0170) 	mov	reg[11h], ffh		; Port_4_DriveMode_1 register (PRT4DM1)
0434: 70 EF    AND   F,0xEF             
                                        (0171) 	M8C_SetBank0
0436: 62 13 FF MOV   REG[0x13],0xFF     (0172) 	mov	reg[13h], ffh		; Port_4_DriveMode_2 register (PRT4DM2)
0439: 62 12 00 MOV   REG[0x12],0x0      (0173) 	mov	reg[12h], 00h		; Port_4_GlobalSelect register (PRT4GS)
043C: 71 10    OR    F,0x10             
                                        (0174) 	M8C_SetBank1
043E: 62 12 00 MOV   REG[0x12],0x0      (0175) 	mov	reg[12h], 00h		; Port_4_IntCtrl_0 register (PRT4IC0)
0441: 62 13 00 MOV   REG[0x13],0x0      (0176) 	mov	reg[13h], 00h		; Port_4_IntCtrl_1 register (PRT4IC1)
0444: 70 EF    AND   F,0xEF             
                                        (0177) 	M8C_SetBank0
0446: 62 11 00 MOV   REG[0x11],0x0      (0178) 	mov	reg[11h], 00h		; Port_4_IntEn register (PRT4IE)
0449: 62 14 00 MOV   REG[0x14],0x0      (0179) 	mov	reg[14h], 00h		; Port_5_Data register (PRT5DR)
044C: 71 10    OR    F,0x10             
                                        (0180) 	M8C_SetBank1
044E: 62 14 00 MOV   REG[0x14],0x0      (0181) 	mov	reg[14h], 00h		; Port_5_DriveMode_0 register (PRT5DM0)
0451: 62 15 FF MOV   REG[0x15],0xFF     (0182) 	mov	reg[15h], ffh		; Port_5_DriveMode_1 register (PRT5DM1)
0454: 70 EF    AND   F,0xEF             
                                        (0183) 	M8C_SetBank0
0456: 62 17 FF MOV   REG[0x17],0xFF     (0184) 	mov	reg[17h], ffh		; Port_5_DriveMode_2 register (PRT5DM2)
0459: 62 16 00 MOV   REG[0x16],0x0      (0185) 	mov	reg[16h], 00h		; Port_5_GlobalSelect register (PRT5GS)
045C: 71 10    OR    F,0x10             
                                        (0186) 	M8C_SetBank1
045E: 62 16 00 MOV   REG[0x16],0x0      (0187) 	mov	reg[16h], 00h		; Port_5_IntCtrl_0 register (PRT5IC0)
0461: 62 17 00 MOV   REG[0x17],0x0      (0188) 	mov	reg[17h], 00h		; Port_5_IntCtrl_1 register (PRT5IC1)
0464: 70 EF    AND   F,0xEF             
                                        (0189) 	M8C_SetBank0
0466: 62 15 00 MOV   REG[0x15],0x0      (0190) 	mov	reg[15h], 00h		; Port_5_IntEn register (PRT5IE)
0469: 62 1C 00 MOV   REG[0x1C],0x0      (0191) 	mov	reg[1ch], 00h		; Port_7_Data register (PRT7DR)
046C: 71 10    OR    F,0x10             
                                        (0192) 	M8C_SetBank1
046E: 62 1C 00 MOV   REG[0x1C],0x0      (0193) 	mov	reg[1ch], 00h		; Port_7_DriveMode_0 register (PRT7DM0)
0471: 62 1D 81 MOV   REG[0x1D],0x81     (0194) 	mov	reg[1dh], 81h		; Port_7_DriveMode_1 register (PRT7DM1)
0474: 70 EF    AND   F,0xEF             
                                        (0195) 	M8C_SetBank0
0476: 62 1F 81 MOV   REG[0x1F],0x81     (0196) 	mov	reg[1fh], 81h		; Port_7_DriveMode_2 register (PRT7DM2)
0479: 62 1E 00 MOV   REG[0x1E],0x0      (0197) 	mov	reg[1eh], 00h		; Port_7_GlobalSelect register (PRT7GS)
047C: 71 10    OR    F,0x10             
                                        (0198) 	M8C_SetBank1
047E: 62 1E 00 MOV   REG[0x1E],0x0      (0199) 	mov	reg[1eh], 00h		; Port_7_IntCtrl_0 register (PRT7IC0)
0481: 62 1F 00 MOV   REG[0x1F],0x0      (0200) 	mov	reg[1fh], 00h		; Port_7_IntCtrl_1 register (PRT7IC1)
0484: 70 EF    AND   F,0xEF             
                                        (0201) 	M8C_SetBank0
0486: 62 1D 00 MOV   REG[0x1D],0x0      (0202) 	mov	reg[1dh], 00h		; Port_7_IntEn register (PRT7IE)
0489: 70 EF    AND   F,0xEF             
                                        (0203) 	M8C_SetBank0
048B: 7F       RET                      (0204) 	ret
                                        (0205) 
                                        (0206) 
                                        (0207) ; PSoC Configuration file trailer PsocConfig.asm
FILE: lib\psocconfig.asm                (0001) ; Generated by PSoC Designer 5.1.2110.0
                                        (0002) ;
                                        (0003) ;==========================================================================
                                        (0004) ;  PSoCConfig.asm
                                        (0005) ;  @PSOC_VERSION
                                        (0006) ;
                                        (0007) ;  Version: 0.85
                                        (0008) ;  Revised: June 22, 2004
                                        (0009) ;  Copyright (c) Cypress Semiconductor 2011. All Rights Reserved.
                                        (0010) ;
                                        (0011) ;  This file is generated by the Device Editor on Application Generation.
                                        (0012) ;  It contains code which loads the configuration data table generated in
                                        (0013) ;  the file PSoCConfigTBL.asm
                                        (0014) ;
                                        (0015) ;  DO NOT EDIT THIS FILE MANUALLY, AS IT IS OVERWRITTEN!!!
                                        (0016) ;  Edits to this file will not be preserved.
                                        (0017) ;==========================================================================
                                        (0018) ;
                                        (0019) include "m8c.inc"
                                        (0020) include "memory.inc"
                                        (0021) include "GlobalParams.inc"
                                        (0022) 
                                        (0023) export LoadConfigInit
                                        (0024) export _LoadConfigInit
                                        (0025) export LoadConfig_usbuart
                                        (0026) export _LoadConfig_usbuart
                                        (0027) 
                                        (0028) export NO_SHADOW
                                        (0029) export _NO_SHADOW
                                        (0030) 
                                        (0031) FLAG_CFG_MASK:      equ 10h         ;M8C flag register REG address bit mask
                                        (0032) END_CONFIG_TABLE:   equ ffh         ;end of config table indicator
                                        (0033) 
                                        (0034) AREA psoc_config(rom, rel)
                                        (0035) 
                                        (0036) ;---------------------------------------------------------------------------
                                        (0037) ; LoadConfigInit - Establish the start-up configuration (except for a few
                                        (0038) ;                  parameters handled by boot code, like CPU speed). This
                                        (0039) ;                  function can be called from user code, but typically it
                                        (0040) ;                  is only called from boot.
                                        (0041) ;
                                        (0042) ;       INPUTS: None.
                                        (0043) ;      RETURNS: Nothing.
                                        (0044) ; SIDE EFFECTS: Registers are volatile: the A and X registers can be modified!
                                        (0045) ;               In the large memory model currently only the page
                                        (0046) ;               pointer registers listed below are modified.  This does
                                        (0047) ;               not guarantee that in future implementations of this
                                        (0048) ;               function other page pointer registers will not be
                                        (0049) ;               modified.
                                        (0050) ;          
                                        (0051) ;               Page Pointer Registers Modified: 
                                        (0052) ;               CUR_PP
                                        (0053) ;
                                        (0054) _LoadConfigInit:
                                        (0055)  LoadConfigInit:
                                        (0056)     RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0057)     
048C: 7C 04 93 LCALL 0x0493             (0058) 	lcall	LoadConfig_usbuart
048F: 7C 03 A7 LCALL 0x03A7             (0059) 	lcall	LoadConfigTBL_usbuart_Ordered
                                        (0060) 
                                        (0061) 
                                        (0062)     RAM_EPILOGUE RAM_USE_CLASS_4
0492: 7F       RET                      (0063)     ret
                                        (0064) 
                                        (0065) ;---------------------------------------------------------------------------
                                        (0066) ; Load Configuration usbuart
                                        (0067) ;
                                        (0068) ;    Load configuration registers for usbuart.
                                        (0069) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
                                        (0070) ;
                                        (0071) ;       INPUTS: None.
                                        (0072) ;      RETURNS: Nothing.
                                        (0073) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
                                        (0074) ;               modified as may the Page Pointer registers!
                                        (0075) ;               In the large memory model currently only the page
                                        (0076) ;               pointer registers listed below are modified.  This does
                                        (0077) ;               not guarantee that in future implementations of this
                                        (0078) ;               function other page pointer registers will not be
                                        (0079) ;               modified.
                                        (0080) ;          
                                        (0081) ;               Page Pointer Registers Modified: 
                                        (0082) ;               CUR_PP
                                        (0083) ;
                                        (0084) _LoadConfig_usbuart:
                                        (0085)  LoadConfig_usbuart:
                                        (0086)     RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0087) 
0493: 10       PUSH  X                  (0088) 	push	x
0494: 70 EF    AND   F,0xEF             
                                        (0089)     M8C_SetBank0                    ; Force bank 0
0496: 50 00    MOV   A,0x0              (0090)     mov     a, 0                    ; Specify bank 0
0498: 67       ASR   A                  (0091)     asr     a                       ; Store in carry flag
                                        (0092)                                     ; Load bank 0 table:
0499: 50 02    MOV   A,0x2              (0093)     mov     A, >LoadConfigTBL_usbuart_Bank0
049B: 57 F7    MOV   X,0xF7             (0094)     mov     X, <LoadConfigTBL_usbuart_Bank0
049D: 7C 04 AE LCALL 0x04AE             (0095)     lcall   LoadConfig              ; Load the bank 0 values
                                        (0096) 
04A0: 50 01    MOV   A,0x1              (0097)     mov     a, 1                    ; Specify bank 1
04A2: 67       ASR   A                  (0098)     asr     a                       ; Store in carry flag
                                        (0099)                                     ; Load bank 1 table:
04A3: 50 03    MOV   A,0x3              (0100)     mov     A, >LoadConfigTBL_usbuart_Bank1
04A5: 57 5E    MOV   X,0x5E             (0101)     mov     X, <LoadConfigTBL_usbuart_Bank1
04A7: 7C 04 AE LCALL 0x04AE             (0102)     lcall   LoadConfig              ; Load the bank 1 values
04AA: 70 EF    AND   F,0xEF             
                                        (0103) 
                                        (0104)     M8C_SetBank0                    ; Force return to bank 0
04AC: 20       POP   X                  (0105) 	pop		x
                                        (0106) 
                                        (0107)     RAM_EPILOGUE RAM_USE_CLASS_4
04AD: 7F       RET                      (0108)     ret
                                        (0109) 
                                        (0110) 
                                        (0111) 
                                        (0112) 
                                        (0113) ;---------------------------------------------------------------------------
                                        (0114) ; LoadConfig - Set IO registers as specified in ROM table of (address,value)
                                        (0115) ;              pairs. Terminate on address=0xFF.
                                        (0116) ;
                                        (0117) ;  INPUTS:  [A,X] points to the table to be loaded
                                        (0118) ;           Flag Register Carry bit encodes the Register Bank
                                        (0119) ;           (Carry=0 => Bank 0; Carry=1 => Bank 1)
                                        (0120) ;
                                        (0121) ;  RETURNS: nothing.
                                        (0122) ;
                                        (0123) ;  STACK FRAME:  X-4 I/O Bank 0/1 indicator
                                        (0124) ;                X-3 Temporary store for register address
                                        (0125) ;                X-2 LSB of config table address
                                        (0126) ;                X-1 MSB of config table address
                                        (0127) ;
                                        (0128) LoadConfig:
                                        (0129)     RAM_PROLOGUE RAM_USE_CLASS_2
04AE: 38 02    ADD   SP,0x2             (0130)     add     SP, 2                   ; Set up local vars
04B0: 10       PUSH  X                  (0131)     push    X                       ; Save config table address on stack
04B1: 08       PUSH  A                  (0132)     push    A
04B2: 4F       MOV   X,SP               (0133)     mov     X, SP
04B3: 56 FC 00 MOV   [X-4],0x0          (0134)     mov     [X-4], 0                ; Set default Destination to Bank 0
04B6: D0 04    JNC   0x04BB             (0135)     jnc     .BankSelectSaved        ; Carry says Bank 0 is OK
04B8: 56 FC 01 MOV   [X-4],0x1          (0136)     mov     [X-4], 1                ; No Carry: default to Bank 1
                                        (0137) .BankSelectSaved:
04BB: 18       POP   A                  (0138)     pop     A
04BC: 20       POP   X                  (0139)     pop     X
04BD: 70 EF    AND   F,0xEF             
04BF: 62 E3 00 MOV   REG[0xE3],0x0      
                                        (0140) 
                                        (0141) LoadConfigLp:
                                        (0142)     M8C_SetBank0                    ; Switch to bank 0
                                        (0143)     M8C_ClearWDT                    ; Clear the watchdog for long inits
04C2: 10       PUSH  X                  (0144)     push    X                       ; Preserve the config table address
04C3: 08       PUSH  A                  (0145)     push    A
04C4: 28       ROMX                     (0146)     romx                            ; Load register address from table
04C5: 39 FF    CMP   A,0xFF             (0147)     cmp     A, END_CONFIG_TABLE     ; End of table?
04C7: A0 1F    JZ    0x04E7             (0148)     jz      EndLoadConfig           ;   Yes, go wrap it up
04C9: 4F       MOV   X,SP               (0149)     mov     X, SP                   ;
04CA: 48 FC 01 TST   [X-4],0x1          (0150)     tst     [X-4], 1                ; Loading IO Bank 1?
04CD: A0 03    JZ    0x04D1             (0151)     jz      .IOBankNowSet           ;    No, Bank 0 is fine
04CF: 71 10    OR    F,0x10             
                                        (0152)     M8C_SetBank1                    ;   Yes, switch to Bank 1
                                        (0153) .IOBankNowSet:
04D1: 54 FD    MOV   [X-3],A            (0154)     mov     [X-3], A                ; Stash the register address
04D3: 18       POP   A                  (0155)     pop     A                       ; Retrieve the table address
04D4: 20       POP   X                  (0156)     pop     X
04D5: 75       INC   X                  (0157)     inc     X                       ; Advance to the data byte
04D6: 09 00    ADC   A,0x0              (0158)     adc     A, 0
04D8: 10       PUSH  X                  (0159)     push    X                       ; Save the config table address again
04D9: 08       PUSH  A                  (0160)     push    A
04DA: 28       ROMX                     (0161)     romx                            ; load config data from the table
04DB: 4F       MOV   X,SP               (0162)     mov     X, SP                   ; retrieve the register address
04DC: 59 FD    MOV   X,[X-3]            (0163)     mov     X, [X-3]
04DE: 61 00    MOV   REG[X+0x0],A       (0164)     mov     reg[X], A               ; Configure the register
04E0: 18       POP   A                  (0165)     pop     A                       ; retrieve the table address
04E1: 20       POP   X                  (0166)     pop     X
04E2: 75       INC   X                  (0167)     inc     X                       ; advance to next table entry
04E3: 09 00    ADC   A,0x0              (0168)     adc     A, 0
04E5: 8F D7    JMP   0x04BD             (0169)     jmp     LoadConfigLp            ; loop to configure another register
                                        (0170) EndLoadConfig:
04E7: 38 FC    ADD   SP,0xFC            (0171)     add     SP, -4
04E9: 70 3F    AND   F,0x3F             
04EB: 71 C0    OR    F,0xC0             
                                        (0172)     RAM_EPILOGUE RAM_USE_CLASS_2
04ED: 7F       RET                      (0173)     ret
                                        (0174) 
                                        (0175) AREA InterruptRAM(ram, rel)
                                        (0176) 
                                        (0177) NO_SHADOW:
                                        (0178) _NO_SHADOW:
FILE: lib\usbuart_1_std.asm             (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME: USBUART_1_std.asm
                                        (0004) ;;  Version: 1.40, Updated on 2011/3/29 at 14:31:18
                                        (0005) ;;  Generated by PSoC Designer 5.1.2110.0
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: USB Device User Module software implementation file.
                                        (0008) ;;
                                        (0009) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                        (0010) ;;        arguments and observe the associated "Registers are volatile" policy.
                                        (0011) ;;        This means it is the caller's responsibility to preserve any values
                                        (0012) ;;        in the X and A registers that are still needed after the API functions
                                        (0013) ;;        returns. For Large Memory Model devices it is also the caller's
                                        (0014) ;;        responsibility to preserve any value in the CUR_PP, IDX_PP, MVR_PP and
                                        (0015) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                        (0016) ;;        now, there is no guarantee that will remain the case in future releases.
                                        (0017) ;;-----------------------------------------------------------------------------
                                        (0018) ;;  Copyright (c) Cypress Semiconductor 2011. All Rights Reserved.
                                        (0019) ;;*****************************************************************************
                                        (0020) ;;*****************************************************************************
                                        (0021) 
                                        (0022) include "m8c.inc"
                                        (0023) include "USBUART_1_macros.inc"
                                        (0024) include "USBUART_1.inc"
                                        (0025) 
                                        (0026) ;-----------------------------------------------
                                        (0027) ;  Constant Data Allocation
                                        (0028) ;-----------------------------------------------
                                        (0029) AREA UserModules (ROM, REL)
                                        (0030) 
                                        (0031) ;-----------------------------------------------------------------------------
                                        (0032) ;  FUNCTION NAME: USBUART_1_Not_Supported
                                        (0033) ;
                                        (0034) ;  DESCRIPTION:
                                        (0035) ;
                                        (0036) ;-----------------------------------------------------------------------------
                                        (0037) ;
                                        (0038) ;  ARGUMENTS:
                                        (0039) ;
                                        (0040) ;  RETURNS:
                                        (0041) ;
                                        (0042) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0043) ;
                                        (0044) ;  THEORY of OPERATION or PROCEDURE:
                                        (0045) ;
                                        (0046) ;-----------------------------------------------------------------------------
                                        (0047) 
                                        (0048) ; d2h_std_dev
                                        (0049) IF (USB_CB_SRC_d2h_std_dev_00 & USB_NOT_SUPPORTED)
                                        (0050) export  USBUART_1_CB_d2h_std_dev_00
                                        (0051) USBUART_1_CB_d2h_std_dev_00:
                                        (0052) ENDIF
                                        (0053) IF (USB_CB_SRC_d2h_std_dev_01 & USB_NOT_SUPPORTED)
                                        (0054) export  USBUART_1_CB_d2h_std_dev_01
                                        (0055) USBUART_1_CB_d2h_std_dev_01:
                                        (0056) ENDIF
                                        (0057) IF (USB_CB_SRC_d2h_std_dev_02 & USB_NOT_SUPPORTED)
                                        (0058) export  USBUART_1_CB_d2h_std_dev_02
                                        (0059) USBUART_1_CB_d2h_std_dev_02:
                                        (0060) ENDIF
                                        (0061) IF (USB_CB_SRC_d2h_std_dev_03 & USB_NOT_SUPPORTED)
                                        (0062) export  USBUART_1_CB_d2h_std_dev_03
                                        (0063) USBUART_1_CB_d2h_std_dev_03:
                                        (0064) ENDIF
                                        (0065) IF (USB_CB_SRC_d2h_std_dev_04 & USB_NOT_SUPPORTED)
                                        (0066) export  USBUART_1_CB_d2h_std_dev_04
                                        (0067) USBUART_1_CB_d2h_std_dev_04:
                                        (0068) ENDIF
                                        (0069) IF (USB_CB_SRC_d2h_std_dev_05 & USB_NOT_SUPPORTED)
                                        (0070) export  USBUART_1_CB_d2h_std_dev_05
                                        (0071) USBUART_1_CB_d2h_std_dev_05:
                                        (0072) ENDIF
                                        (0073) IF (USB_CB_SRC_d2h_std_dev_06 & USB_NOT_SUPPORTED)
                                        (0074) export  USBUART_1_CB_d2h_std_dev_06
                                        (0075) USBUART_1_CB_d2h_std_dev_06:
                                        (0076) ENDIF
                                        (0077) IF (USB_CB_SRC_d2h_std_dev_07 & USB_NOT_SUPPORTED)
                                        (0078) export  USBUART_1_CB_d2h_std_dev_07
                                        (0079) USBUART_1_CB_d2h_std_dev_07:
                                        (0080) ENDIF
                                        (0081) IF (USB_CB_SRC_d2h_std_dev_08 & USB_NOT_SUPPORTED)
                                        (0082) export  USBUART_1_CB_d2h_std_dev_08
                                        (0083) USBUART_1_CB_d2h_std_dev_08:
                                        (0084) ENDIF
                                        (0085) 
                                        (0086) ; h2d_std_dev
                                        (0087) IF (USB_CB_SRC_h2d_std_dev_00 & USB_NOT_SUPPORTED)
                                        (0088) export  USBUART_1_CB_h2d_std_dev_00
                                        (0089) USBUART_1_CB_h2d_std_dev_00:
                                        (0090) ENDIF
                                        (0091) IF (USB_CB_SRC_h2d_std_dev_01 & USB_NOT_SUPPORTED)
                                        (0092) export  USBUART_1_CB_h2d_std_dev_01
                                        (0093) USBUART_1_CB_h2d_std_dev_01:
                                        (0094) ENDIF
                                        (0095) IF (USB_CB_SRC_h2d_std_dev_02 & USB_NOT_SUPPORTED)
                                        (0096) export  USBUART_1_CB_h2d_std_dev_02
                                        (0097) USBUART_1_CB_h2d_std_dev_02:
                                        (0098) ENDIF
                                        (0099) IF (USB_CB_SRC_h2d_std_dev_03 & USB_NOT_SUPPORTED)
                                        (0100) export  USBUART_1_CB_h2d_std_dev_03
                                        (0101) USBUART_1_CB_h2d_std_dev_03:
                                        (0102) ENDIF
                                        (0103) IF (USB_CB_SRC_h2d_std_dev_04 & USB_NOT_SUPPORTED)
                                        (0104) export  USBUART_1_CB_h2d_std_dev_04
                                        (0105) USBUART_1_CB_h2d_std_dev_04:
                                        (0106) ENDIF
                                        (0107) IF (USB_CB_SRC_h2d_std_dev_05 & USB_NOT_SUPPORTED)
                                        (0108) export  USBUART_1_CB_h2d_std_dev_05
                                        (0109) USBUART_1_CB_h2d_std_dev_05:
                                        (0110) ENDIF
                                        (0111) IF (USB_CB_SRC_h2d_std_dev_06 & USB_NOT_SUPPORTED)
                                        (0112) export  USBUART_1_CB_h2d_std_dev_06
                                        (0113) USBUART_1_CB_h2d_std_dev_06:
                                        (0114) ENDIF
                                        (0115) IF (USB_CB_SRC_h2d_std_dev_07 & USB_NOT_SUPPORTED)
                                        (0116) export  USBUART_1_CB_h2d_std_dev_07
                                        (0117) USBUART_1_CB_h2d_std_dev_07:
                                        (0118) ENDIF
                                        (0119) IF (USB_CB_SRC_h2d_std_dev_08 & USB_NOT_SUPPORTED)
                                        (0120) export  USBUART_1_CB_h2d_std_dev_08
                                        (0121) USBUART_1_CB_h2d_std_dev_08:
                                        (0122) ENDIF
                                        (0123) IF (USB_CB_SRC_h2d_std_dev_09 & USB_NOT_SUPPORTED)
                                        (0124) export  USBUART_1_CB_h2d_std_dev_09
                                        (0125) USBUART_1_CB_h2d_std_dev_09:
                                        (0126) ENDIF
                                        (0127) 
                                        (0128) ; d2h_std_ifc
                                        (0129) IF (USB_CB_SRC_d2h_std_ifc_00 & USB_NOT_SUPPORTED)
                                        (0130) export  USBUART_1_CB_d2h_std_ifc_00
                                        (0131) USBUART_1_CB_d2h_std_ifc_00:
                                        (0132) ENDIF
                                        (0133) IF (USB_CB_SRC_d2h_std_ifc_01 & USB_NOT_SUPPORTED)
                                        (0134) export  USBUART_1_CB_d2h_std_ifc_01
                                        (0135) USBUART_1_CB_d2h_std_ifc_01:
                                        (0136) ENDIF
                                        (0137) IF (USB_CB_SRC_d2h_std_ifc_02 & USB_NOT_SUPPORTED)
                                        (0138) export  USBUART_1_CB_d2h_std_ifc_02
                                        (0139) USBUART_1_CB_d2h_std_ifc_02:
                                        (0140) ENDIF
                                        (0141) IF (USB_CB_SRC_d2h_std_ifc_03 & USB_NOT_SUPPORTED)
                                        (0142) export  USBUART_1_CB_d2h_std_ifc_03
                                        (0143) USBUART_1_CB_d2h_std_ifc_03:
                                        (0144) ENDIF
                                        (0145) IF (USB_CB_SRC_d2h_std_ifc_04 & USB_NOT_SUPPORTED)
                                        (0146) export  USBUART_1_CB_d2h_std_ifc_04
                                        (0147) USBUART_1_CB_d2h_std_ifc_04:
                                        (0148) ENDIF
                                        (0149) IF (USB_CB_SRC_d2h_std_ifc_05 & USB_NOT_SUPPORTED)
                                        (0150) export  USBUART_1_CB_d2h_std_ifc_05
                                        (0151) USBUART_1_CB_d2h_std_ifc_05:
                                        (0152) ENDIF
                                        (0153) IF (USB_CB_SRC_d2h_std_ifc_06 & USB_NOT_SUPPORTED)
                                        (0154) export  USBUART_1_CB_d2h_std_ifc_06
                                        (0155) USBUART_1_CB_d2h_std_ifc_06:
                                        (0156) ENDIF
                                        (0157) IF (USB_CB_SRC_d2h_std_ifc_07 & USB_NOT_SUPPORTED)
                                        (0158) export  USBUART_1_CB_d2h_std_ifc_07
                                        (0159) USBUART_1_CB_d2h_std_ifc_07:
                                        (0160) ENDIF
                                        (0161) IF (USB_CB_SRC_d2h_std_ifc_08 & USB_NOT_SUPPORTED)
                                        (0162) export  USBUART_1_CB_d2h_std_ifc_08
                                        (0163) USBUART_1_CB_d2h_std_ifc_08:
                                        (0164) ENDIF
                                        (0165) IF (USB_CB_SRC_d2h_std_ifc_09 & USB_NOT_SUPPORTED)
                                        (0166) export  USBUART_1_CB_d2h_std_ifc_09
                                        (0167) USBUART_1_CB_d2h_std_ifc_09:
                                        (0168) ENDIF
                                        (0169) IF (USB_CB_SRC_d2h_std_ifc_10 & USB_NOT_SUPPORTED)
                                        (0170) export  USBUART_1_CB_d2h_std_ifc_10
                                        (0171) USBUART_1_CB_d2h_std_ifc_10:
                                        (0172) ENDIF
                                        (0173) 
                                        (0174) ; d2h_std_ifc
                                        (0175) IF (USB_CB_SRC_h2d_std_ifc_00 & USB_NOT_SUPPORTED)
                                        (0176) export  USBUART_1_CB_h2d_std_ifc_00
                                        (0177) USBUART_1_CB_h2d_std_ifc_00:
                                        (0178) ENDIF
                                        (0179) 
                                        (0180) ; d2h_std_ep
                                        (0181) IF (USB_CB_SRC_d2h_std_ep_00 & USB_NOT_SUPPORTED)
                                        (0182) export  USBUART_1_CB_d2h_std_ep_00
                                        (0183) USBUART_1_CB_d2h_std_ep_00:
                                        (0184) ENDIF
                                        (0185) 
                                        (0186) ; h2d_std_ep
                                        (0187) IF (USB_CB_SRC_h2d_std_ep_00 & USB_NOT_SUPPORTED)
                                        (0188) export  USBUART_1_CB_h2d_std_ep_00
                                        (0189) USBUART_1_CB_h2d_std_ep_00:
                                        (0190) ENDIF
                                        (0191) IF (USB_CB_SRC_h2d_std_ep_01 & USB_NOT_SUPPORTED)
                                        (0192) export  USBUART_1_CB_h2d_std_ep_01
                                        (0193) USBUART_1_CB_h2d_std_ep_01:
                                        (0194) ENDIF
                                        (0195) IF (USB_CB_SRC_h2d_std_ep_02 & USB_NOT_SUPPORTED)
                                        (0196) export  USBUART_1_CB_h2d_std_ep_02
                                        (0197) USBUART_1_CB_h2d_std_ep_02:
                                        (0198) ENDIF
                                        (0199) IF (USB_CB_SRC_h2d_std_ep_03 & USB_NOT_SUPPORTED)
                                        (0200) export  USBUART_1_CB_h2d_std_ep_03
                                        (0201) USBUART_1_CB_h2d_std_ep_03:
                                        (0202) ENDIF
                                        (0203) 
                                        (0204) export  USBUART_1_Not_Supported
                                        (0205) export _USBUART_1_Not_Supported
                                        (0206) USBUART_1_Not_Supported:
                                        (0207) _USBUART_1_Not_Supported:
04EE: 50 00    MOV   A,0x0              (0208)    MOV    A, 0                         ; Count 0
04F0: 57 03    MOV   X,0x3              (0209)    MOV    X, USB_MODE_STALL_IN_OUT     ; Stall the request
04F2: 7D 07 DA LJMP  USBUART_1_EP0_UPD_MODE_EXIT(0210)    LJMP   USBUART_1_EP0_UPD_MODE_EXIT
                                        (0211) ;-----------------------------------------------------------------------------
                                        (0212) ;  FUNCTION NAME: USBUART_1_CB_d2h_std_dev_00
                                        (0213) ;
                                        (0214) ;  DESCRIPTION:   Get Device Status
                                        (0215) ;
                                        (0216) ;****************************************************************
                                        (0217) ; STANDARD DEVICE IN REQUEST: Get_Device_Status
                                        (0218) ;****************************************************************
                                        (0219) ;
                                        (0220) ; bmRequestType  : (IN | STANDARD | DEVICE)       = 80h
                                        (0221) ; bRequest       : GET_STATUS                     = 00h
                                        (0222) ; wValue         : RESERVED                       = 0000h
                                        (0223) ; wIndex         : RESERVED                       = 0000h
                                        (0224) ; wLength        : SIZEOF_ENDPOINT_STATUS         = 0002h
                                        (0225) ;
                                        (0226) ; The GET_DEVICE_STATUS request returns the current device status.
                                        (0227) ;
                                        (0228) ;****************************************************************
                                        (0229) ;-----------------------------------------------------------------------------
                                        (0230) ;
                                        (0231) ;  ARGUMENTS:
                                        (0232) ;
                                        (0233) ;  RETURNS:
                                        (0234) ;
                                        (0235) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0236) ;
                                        (0237) ;  THEORY of OPERATION or PROCEDURE:
                                        (0238) ;
                                        (0239) ;-----------------------------------------------------------------------------
                                        (0240) IF (USB_CB_SRC_d2h_std_dev_00 & USB_UM_SUPPLIED)
                                        (0241) .LITERAL
                                        (0242) GetStatusTransferDescrTable:
                                        (0243)     TD_START_TABLE 1                   ; One entry
                                        (0244)     TD_ENTRY    USB_DS_RAM, 2, USBUART_1_TransferBuffer, NULL_PTR  ; Intermediate Buffer
                                        (0245) .ENDLITERAL
                                        (0246) export  USBUART_1_CB_d2h_std_dev_00
                                        (0247) USBUART_1_CB_d2h_std_dev_00:
04FE: 55 1F 00 MOV   [0x1F],0x0         (0248)     MOV     [USBUART_1_t2], 0          ; Use the UM temp var--Selector
                                        (0249) 
0501: 55 0D 00 MOV   [0xD],0x0          (0250)     MOV     [USBUART_1_TransferBuffer+1], 0  ; Use the UM Transfer Buffer
0504: 5F 0C 02 MOV   [0xC],[0x2]        (0251)     MOV     [USBUART_1_TransferBuffer], [USBUART_1_DeviceStatus]
                                        (0252) 
0507: 50 04    MOV   A,0x4              (0253)     MOV     A,>GetStatusTransferDescrTable  ; Get the ROM Address MSB
0509: 57 F5    MOV   X,0xF5             (0254)     MOV     X,<GetStatusTransferDescrTable  ; Get the ROM Address LSB
050B: 80 C1    JMP   0x05CD             (0255)     JMP     USBUART_1_GetTableEntry_Local_Std
                                        (0256) ENDIF
                                        (0257) 
                                        (0258) ;-----------------------------------------------------------------------------
                                        (0259) ;  USB 2nd Tier Dispatch Jump Tables for Standard Requests (based on bRequest)
                                        (0260) ;-----------------------------------------------------------------------------
                                        (0261) ;  FUNCTION NAME: ;  USB 2nd Tier Dispatch Jump Table
                                        (0262) ;
                                        (0263) ;  DESCRIPTION:   The following tables dispatch to the Standard request handler
                                        (0264) ;                 functions.  (Assumes bmRequestType(5:6) is 0, Standard)
                                        (0265) ;
                                        (0266) ;-----------------------------------------------------------------------------
                                        (0267) ;
                                        (0268) ;  ARGUMENTS:
                                        (0269) ;
                                        (0270) ;  RETURNS:
                                        (0271) ;
                                        (0272) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0273) ;
                                        (0274) ;  THEORY of OPERATION or PROCEDURE:
                                        (0275) ;
                                        (0276) ;-----------------------------------------------------------------------------
                                        (0277) USBUART_1_DT_d2h_std_dev:
                                        (0278) ;-----------------------------------------------------------------------------
                                        (0279) 
050D: 8F F0    JMP   USBUART_1_CB_d2h_std_dev_00(0280)     jmp     USBUART_1_CB_d2h_std_dev_00
050F: 8F DE    JMP   _USBUART_1_Not_Supported|USBUART_1_CB_h2d_std_dev_08|USBUART_1_CB_h2d_std_dev_07|USBUART_1_CB_d2h_std_dev_07|USBUART_1_CB_h2d_std_dev_06|USBUART_1_CB_d2h_std_dev_05|USBUART_1_CB_h2d_std_dev_04|USBUART_1_CB_d2h_std_dev_04|USBUART_1_Not_Supported|...(0281)     jmp     USBUART_1_CB_d2h_std_dev_01
0511: 8F DC    JMP   _USBUART_1_Not_Supported|USBUART_1_CB_h2d_std_dev_08|USBUART_1_CB_h2d_std_dev_07|USBUART_1_CB_d2h_std_dev_07|USBUART_1_CB_h2d_std_dev_06|USBUART_1_CB_d2h_std_dev_05|USBUART_1_CB_h2d_std_dev_04|USBUART_1_CB_d2h_std_dev_04|USBUART_1_Not_Supported|...(0282)     jmp     USBUART_1_CB_d2h_std_dev_02
0513: 8F DA    JMP   _USBUART_1_Not_Supported|USBUART_1_CB_h2d_std_dev_08|USBUART_1_CB_h2d_std_dev_07|USBUART_1_CB_d2h_std_dev_07|USBUART_1_CB_h2d_std_dev_06|USBUART_1_CB_d2h_std_dev_05|USBUART_1_CB_h2d_std_dev_04|USBUART_1_CB_d2h_std_dev_04|USBUART_1_Not_Supported|...(0283)     jmp     USBUART_1_CB_d2h_std_dev_03
0515: 8F D8    JMP   _USBUART_1_Not_Supported|USBUART_1_CB_h2d_std_dev_08|USBUART_1_CB_h2d_std_dev_07|USBUART_1_CB_d2h_std_dev_07|USBUART_1_CB_h2d_std_dev_06|USBUART_1_CB_d2h_std_dev_05|USBUART_1_CB_h2d_std_dev_04|USBUART_1_CB_d2h_std_dev_04|USBUART_1_Not_Supported|...(0284)     jmp     USBUART_1_CB_d2h_std_dev_04
0517: 8F D6    JMP   _USBUART_1_Not_Supported|USBUART_1_CB_h2d_std_dev_08|USBUART_1_CB_h2d_std_dev_07|USBUART_1_CB_d2h_std_dev_07|USBUART_1_CB_h2d_std_dev_06|USBUART_1_CB_d2h_std_dev_05|USBUART_1_CB_h2d_std_dev_04|USBUART_1_CB_d2h_std_dev_04|USBUART_1_Not_Supported|...(0285)     jmp     USBUART_1_CB_d2h_std_dev_05
0519: 80 B9    JMP   USBUART_1_CB_d2h_std_dev_06(0286)     jmp     USBUART_1_CB_d2h_std_dev_06
051B: 8F D2    JMP   _USBUART_1_Not_Supported|USBUART_1_CB_h2d_std_dev_08|USBUART_1_CB_h2d_std_dev_07|USBUART_1_CB_d2h_std_dev_07|USBUART_1_CB_h2d_std_dev_06|USBUART_1_CB_d2h_std_dev_05|USBUART_1_CB_h2d_std_dev_04|USBUART_1_CB_d2h_std_dev_04|USBUART_1_Not_Supported|...(0287)     jmp     USBUART_1_CB_d2h_std_dev_07
051D: 81 13    JMP   USBUART_1_CB_d2h_std_dev_08(0288)     jmp     USBUART_1_CB_d2h_std_dev_08
                                        (0289) 
                                        (0290) USBUART_1_DT_d2h_std_dev_End:
                                        (0291) USBUART_1_DT_d2h_std_dev_Size: equ (USBUART_1_DT_d2h_std_dev_End-USBUART_1_DT_d2h_std_dev) / 2
                                        (0292) USBUART_1_DT_d2h_std_dev_Dispatch::
051F: 5D 59    MOV   A,REG[0x59]        (0293)     MOV    A, REG[USBUART_1_EP0DATA + bRequest]
0521: 39 09    CMP   A,0x9              
0523: D0 04    JNC   0x0528             
0525: 64       ASL   A                  
0526: EF E6    JACC  0x050D             
0528: 7D 04 EE LJMP  _USBUART_1_Not_Supported|USBUART_1_CB_h2d_std_dev_08|USBUART_1_CB_h2d_std_dev_07|USBUART_1_CB_d2h_std_dev_07|USBUART_1_CB_h2d_std_dev_06|USBUART_1_CB_d2h_std_dev_05|USBUART_1_CB_h2d_std_dev_04|USBUART_1_CB_d2h_std_dev_04|USBUART_1_Not_Supported|...
                                        (0294)     DISPATCHER USBUART_1_DT_d2h_std_dev, USBUART_1_DT_d2h_std_dev_Size, USBUART_1_Not_Supported
                                        (0295) 
                                        (0296) ;-----------------------------------------------------------------------------
                                        (0297) USBUART_1_DT_h2d_std_dev:
                                        (0298) ;-----------------------------------------------------------------------------
                                        (0299) 
052B: 8F C2    JMP   _USBUART_1_Not_Supported|USBUART_1_CB_h2d_std_dev_08|USBUART_1_CB_h2d_std_dev_07|USBUART_1_CB_d2h_std_dev_07|USBUART_1_CB_h2d_std_dev_06|USBUART_1_CB_d2h_std_dev_05|USBUART_1_CB_h2d_std_dev_04|USBUART_1_CB_d2h_std_dev_04|USBUART_1_Not_Supported|...(0300)     jmp     USBUART_1_CB_h2d_std_dev_00
052D: 81 0C    JMP   USBUART_1_CB_h2d_std_dev_01(0301)     jmp     USBUART_1_CB_h2d_std_dev_01
052F: 8F BE    JMP   _USBUART_1_Not_Supported|USBUART_1_CB_h2d_std_dev_08|USBUART_1_CB_h2d_std_dev_07|USBUART_1_CB_d2h_std_dev_07|USBUART_1_CB_h2d_std_dev_06|USBUART_1_CB_d2h_std_dev_05|USBUART_1_CB_h2d_std_dev_04|USBUART_1_CB_d2h_std_dev_04|USBUART_1_Not_Supported|...(0302)     jmp     USBUART_1_CB_h2d_std_dev_02
0531: 81 13    JMP   USBUART_1_CB_h2d_std_dev_03(0303)     jmp     USBUART_1_CB_h2d_std_dev_03
0533: 8F BA    JMP   _USBUART_1_Not_Supported|USBUART_1_CB_h2d_std_dev_08|USBUART_1_CB_h2d_std_dev_07|USBUART_1_CB_d2h_std_dev_07|USBUART_1_CB_h2d_std_dev_06|USBUART_1_CB_d2h_std_dev_05|USBUART_1_CB_h2d_std_dev_04|USBUART_1_CB_d2h_std_dev_04|USBUART_1_Not_Supported|...(0304)     jmp     USBUART_1_CB_h2d_std_dev_04
0535: 81 24    JMP   USBUART_1_CB_h2d_std_dev_05(0305)     jmp     USBUART_1_CB_h2d_std_dev_05
0537: 8F B6    JMP   _USBUART_1_Not_Supported|USBUART_1_CB_h2d_std_dev_08|USBUART_1_CB_h2d_std_dev_07|USBUART_1_CB_d2h_std_dev_07|USBUART_1_CB_h2d_std_dev_06|USBUART_1_CB_d2h_std_dev_05|USBUART_1_CB_h2d_std_dev_04|USBUART_1_CB_d2h_std_dev_04|USBUART_1_Not_Supported|...(0306)     jmp     USBUART_1_CB_h2d_std_dev_06
0539: 8F B4    JMP   _USBUART_1_Not_Supported|USBUART_1_CB_h2d_std_dev_08|USBUART_1_CB_h2d_std_dev_07|USBUART_1_CB_d2h_std_dev_07|USBUART_1_CB_h2d_std_dev_06|USBUART_1_CB_d2h_std_dev_05|USBUART_1_CB_h2d_std_dev_04|USBUART_1_CB_d2h_std_dev_04|USBUART_1_Not_Supported|...(0307)     jmp     USBUART_1_CB_h2d_std_dev_07
053B: 8F B2    JMP   _USBUART_1_Not_Supported|USBUART_1_CB_h2d_std_dev_08|USBUART_1_CB_h2d_std_dev_07|USBUART_1_CB_d2h_std_dev_07|USBUART_1_CB_h2d_std_dev_06|USBUART_1_CB_d2h_std_dev_05|USBUART_1_CB_h2d_std_dev_04|USBUART_1_CB_d2h_std_dev_04|USBUART_1_Not_Supported|...(0308)     jmp     USBUART_1_CB_h2d_std_dev_08
053D: 81 25    JMP   USBUART_1_CB_h2d_std_dev_09(0309)     jmp     USBUART_1_CB_h2d_std_dev_09
                                        (0310) 
                                        (0311) USBUART_1_DT_h2d_std_dev_End:
                                        (0312) USBUART_1_DT_h2d_std_dev_Size: equ (USBUART_1_DT_h2d_std_dev_End-USBUART_1_DT_h2d_std_dev) / 2
                                        (0313) USBUART_1_DT_h2d_std_dev_Dispatch::
                                        (0314) 
053F: 5D 59    MOV   A,REG[0x59]        (0315)     MOV     A, REG[USBUART_1_EP0DATA + bRequest]
0541: 39 0A    CMP   A,0xA              
0543: D0 04    JNC   0x0548             
0545: 64       ASL   A                  
0546: EF E4    JACC  0x052B             
0548: 7D 04 EE LJMP  _USBUART_1_Not_Supported|USBUART_1_CB_h2d_std_dev_08|USBUART_1_CB_h2d_std_dev_07|USBUART_1_CB_d2h_std_dev_07|USBUART_1_CB_h2d_std_dev_06|USBUART_1_CB_d2h_std_dev_05|USBUART_1_CB_h2d_std_dev_04|USBUART_1_CB_d2h_std_dev_04|USBUART_1_Not_Supported|...
                                        (0316)     DISPATCHER USBUART_1_DT_h2d_std_dev, USBUART_1_DT_h2d_std_dev_Size, USBUART_1_Not_Supported
                                        (0317) 
                                        (0318) 
                                        (0319) ;-----------------------------------------------------------------------------
                                        (0320) USBUART_1_DT_d2h_std_ifc:
                                        (0321) ;-----------------------------------------------------------------------------
                                        (0322) 
054B: 81 71    JMP   USBUART_1_CB_d2h_std_ifc_00(0323)     jmp     USBUART_1_CB_d2h_std_ifc_00
054D: 8F A0    JMP   _USBUART_1_Not_Supported|USBUART_1_CB_h2d_std_dev_08|USBUART_1_CB_h2d_std_dev_07|USBUART_1_CB_d2h_std_dev_07|USBUART_1_CB_h2d_std_dev_06|USBUART_1_CB_d2h_std_dev_05|USBUART_1_CB_h2d_std_dev_04|USBUART_1_CB_d2h_std_dev_04|USBUART_1_Not_Supported|...(0324)     jmp     USBUART_1_CB_d2h_std_ifc_01
054F: 8F 9E    JMP   _USBUART_1_Not_Supported|USBUART_1_CB_h2d_std_dev_08|USBUART_1_CB_h2d_std_dev_07|USBUART_1_CB_d2h_std_dev_07|USBUART_1_CB_h2d_std_dev_06|USBUART_1_CB_d2h_std_dev_05|USBUART_1_CB_h2d_std_dev_04|USBUART_1_CB_d2h_std_dev_04|USBUART_1_Not_Supported|...(0325)     jmp     USBUART_1_CB_d2h_std_ifc_02
0551: 8F 9C    JMP   _USBUART_1_Not_Supported|USBUART_1_CB_h2d_std_dev_08|USBUART_1_CB_h2d_std_dev_07|USBUART_1_CB_d2h_std_dev_07|USBUART_1_CB_h2d_std_dev_06|USBUART_1_CB_d2h_std_dev_05|USBUART_1_CB_h2d_std_dev_04|USBUART_1_CB_d2h_std_dev_04|USBUART_1_Not_Supported|...(0326)     jmp     USBUART_1_CB_d2h_std_ifc_03
0553: 8F 9A    JMP   _USBUART_1_Not_Supported|USBUART_1_CB_h2d_std_dev_08|USBUART_1_CB_h2d_std_dev_07|USBUART_1_CB_d2h_std_dev_07|USBUART_1_CB_h2d_std_dev_06|USBUART_1_CB_d2h_std_dev_05|USBUART_1_CB_h2d_std_dev_04|USBUART_1_CB_d2h_std_dev_04|USBUART_1_Not_Supported|...(0327)     jmp     USBUART_1_CB_d2h_std_ifc_04
0555: 8F 98    JMP   _USBUART_1_Not_Supported|USBUART_1_CB_h2d_std_dev_08|USBUART_1_CB_h2d_std_dev_07|USBUART_1_CB_d2h_std_dev_07|USBUART_1_CB_h2d_std_dev_06|USBUART_1_CB_d2h_std_dev_05|USBUART_1_CB_h2d_std_dev_04|USBUART_1_CB_d2h_std_dev_04|USBUART_1_Not_Supported|...(0328)     jmp     USBUART_1_CB_d2h_std_ifc_05
0557: 8F 96    JMP   _USBUART_1_Not_Supported|USBUART_1_CB_h2d_std_dev_08|USBUART_1_CB_h2d_std_dev_07|USBUART_1_CB_d2h_std_dev_07|USBUART_1_CB_h2d_std_dev_06|USBUART_1_CB_d2h_std_dev_05|USBUART_1_CB_h2d_std_dev_04|USBUART_1_CB_d2h_std_dev_04|USBUART_1_Not_Supported|...(0329)     jmp     USBUART_1_CB_d2h_std_ifc_06
0559: 8F 94    JMP   _USBUART_1_Not_Supported|USBUART_1_CB_h2d_std_dev_08|USBUART_1_CB_h2d_std_dev_07|USBUART_1_CB_d2h_std_dev_07|USBUART_1_CB_h2d_std_dev_06|USBUART_1_CB_d2h_std_dev_05|USBUART_1_CB_h2d_std_dev_04|USBUART_1_CB_d2h_std_dev_04|USBUART_1_Not_Supported|...(0330)     jmp     USBUART_1_CB_d2h_std_ifc_07
055B: 8F 92    JMP   _USBUART_1_Not_Supported|USBUART_1_CB_h2d_std_dev_08|USBUART_1_CB_h2d_std_dev_07|USBUART_1_CB_d2h_std_dev_07|USBUART_1_CB_h2d_std_dev_06|USBUART_1_CB_d2h_std_dev_05|USBUART_1_CB_h2d_std_dev_04|USBUART_1_CB_d2h_std_dev_04|USBUART_1_Not_Supported|...(0331)     jmp     USBUART_1_CB_d2h_std_ifc_08
055D: 8F 90    JMP   _USBUART_1_Not_Supported|USBUART_1_CB_h2d_std_dev_08|USBUART_1_CB_h2d_std_dev_07|USBUART_1_CB_d2h_std_dev_07|USBUART_1_CB_h2d_std_dev_06|USBUART_1_CB_d2h_std_dev_05|USBUART_1_CB_h2d_std_dev_04|USBUART_1_CB_d2h_std_dev_04|USBUART_1_Not_Supported|...(0332)     jmp     USBUART_1_CB_d2h_std_ifc_09
055F: 81 75    JMP   USBUART_1_CB_d2h_std_ifc_10(0333)     jmp     USBUART_1_CB_d2h_std_ifc_10
                                        (0334) 
                                        (0335) USBUART_1_DT_d2h_std_ifc_End:
                                        (0336) USBUART_1_DT_d2h_std_ifc_Size: equ (USBUART_1_DT_d2h_std_ifc_End-USBUART_1_DT_d2h_std_ifc) / 2
                                        (0337) USBUART_1_DT_d2h_std_ifc_Dispatch::
0561: 3C 01 00 CMP   [0x1],0x0          (0338)     CMP     [USBUART_1_Configuration], 0  ; Is the device configured?
0564: B0 03    JNZ   0x0568             (0339)     JNZ     .configured                ; Jump on configured
0566: 8F 87    JMP   _USBUART_1_Not_Supported|USBUART_1_CB_h2d_std_dev_08|USBUART_1_CB_h2d_std_dev_07|USBUART_1_CB_d2h_std_dev_07|USBUART_1_CB_h2d_std_dev_06|USBUART_1_CB_d2h_std_dev_05|USBUART_1_CB_h2d_std_dev_04|USBUART_1_CB_d2h_std_dev_04|USBUART_1_Not_Supported|...(0340)     JMP    _USBUART_1_Not_Supported    ; Stall the request if not configured
                                        (0341) ; Jump here if the device is configured
                                        (0342) .configured:
0568: 5D 59    MOV   A,REG[0x59]        (0343)     MOV     A, REG[USBUART_1_EP0DATA + bRequest]
056A: 39 0B    CMP   A,0xB              
056C: D0 04    JNC   0x0571             
056E: 64       ASL   A                  
056F: EF DB    JACC  0x054B             
0571: 7D 04 EE LJMP  _USBUART_1_Not_Supported|USBUART_1_CB_h2d_std_dev_08|USBUART_1_CB_h2d_std_dev_07|USBUART_1_CB_d2h_std_dev_07|USBUART_1_CB_h2d_std_dev_06|USBUART_1_CB_d2h_std_dev_05|USBUART_1_CB_h2d_std_dev_04|USBUART_1_CB_d2h_std_dev_04|USBUART_1_Not_Supported|...
                                        (0344)     DISPATCHER USBUART_1_DT_d2h_std_ifc, USBUART_1_DT_d2h_std_ifc_Size, USBUART_1_Not_Supported
                                        (0345) 
                                        (0346) ;-----------------------------------------------------------------------------
                                        (0347) USBUART_1_DT_h2d_std_ifc:
                                        (0348) ;-----------------------------------------------------------------------------
                                        (0349) 
0574: 8F 79    JMP   _USBUART_1_Not_Supported|USBUART_1_CB_h2d_std_dev_08|USBUART_1_CB_h2d_std_dev_07|USBUART_1_CB_d2h_std_dev_07|USBUART_1_CB_h2d_std_dev_06|USBUART_1_CB_d2h_std_dev_05|USBUART_1_CB_h2d_std_dev_04|USBUART_1_CB_d2h_std_dev_04|USBUART_1_Not_Supported|...(0350)     jmp     USBUART_1_CB_h2d_std_ifc_00
                                        (0351) 
                                        (0352) USBUART_1_DT_h2d_std_ifc_End:
                                        (0353) USBUART_1_DT_h2d_std_ifc_Size: equ (USBUART_1_DT_h2d_std_ifc_End-USBUART_1_DT_h2d_std_ifc) / 2
                                        (0354) USBUART_1_DT_h2d_std_ifc_Dispatch::
0576: 3C 01 00 CMP   [0x1],0x0          (0355)     CMP     [USBUART_1_Configuration], 0  ; Is the device configured?
0579: B0 03    JNZ   0x057D             (0356)     JNZ     .configured                ; Jump on configured
057B: 8F 72    JMP   _USBUART_1_Not_Supported|USBUART_1_CB_h2d_std_dev_08|USBUART_1_CB_h2d_std_dev_07|USBUART_1_CB_d2h_std_dev_07|USBUART_1_CB_h2d_std_dev_06|USBUART_1_CB_d2h_std_dev_05|USBUART_1_CB_h2d_std_dev_04|USBUART_1_CB_d2h_std_dev_04|USBUART_1_Not_Supported|...(0357)     JMP    _USBUART_1_Not_Supported    ; Stall the request if not configured
                                        (0358) ; Jump here if the device is configured
                                        (0359) .configured:
057D: 5D 59    MOV   A,REG[0x59]        (0360)     MOV     A, REG[USBUART_1_EP0DATA + bRequest]
057F: 39 01    CMP   A,0x1              
0581: D0 04    JNC   0x0586             
0583: 64       ASL   A                  
0584: EF EF    JACC  0x0574             
0586: 7D 04 EE LJMP  _USBUART_1_Not_Supported|USBUART_1_CB_h2d_std_dev_08|USBUART_1_CB_h2d_std_dev_07|USBUART_1_CB_d2h_std_dev_07|USBUART_1_CB_h2d_std_dev_06|USBUART_1_CB_d2h_std_dev_05|USBUART_1_CB_h2d_std_dev_04|USBUART_1_CB_d2h_std_dev_04|USBUART_1_Not_Supported|...
                                        (0361)     DISPATCHER USBUART_1_DT_h2d_std_ifc, USBUART_1_DT_h2d_std_ifc_Size, USBUART_1_Not_Supported
                                        (0362) 
                                        (0363) ;-----------------------------------------------------------------------------
                                        (0364) USBUART_1_DT_d2h_std_ep:
                                        (0365) ;-----------------------------------------------------------------------------
0589: 81 5F    JMP   USBUART_1_CB_d2h_std_ep_00(0366)     jmp     USBUART_1_CB_d2h_std_ep_00
                                        (0367) 
                                        (0368) USBUART_1_DT_d2h_std_ep_End:
                                        (0369) USBUART_1_DT_d2h_std_ep_Size: equ (USBUART_1_DT_d2h_std_ep_End-USBUART_1_DT_d2h_std_ep) / 2
                                        (0370) USBUART_1_DT_d2h_std_ep_Dispatch::
058B: 3C 01 00 CMP   [0x1],0x0          (0371)     CMP     [USBUART_1_Configuration], 0  ; Is the device configured?
058E: B0 0D    JNZ   0x059C             (0372)     JNZ     .configured                ; Jump on configured
                                        (0373) 
0590: 5D 5D    MOV   A,REG[0x5D]        (0374)     MOV     A, REG[USBUART_1_EP0DATA + wIndexHi] ; Is the request for EP0?
0592: 53 1F    MOV   [0x1F],A           (0375)     MOV     [USBUART_1_t2], A          ; Use the UM temp var--Selector
0594: 5D 5C    MOV   A,REG[0x5C]        (0376)     MOV     A, REG[USBUART_1_EP0DATA + wIndexLo] ;
0596: 2C 1F    OR    [0x1F],A           (0377)     OR      [USBUART_1_t2], A          ; Use the UM temp var--Selector
0598: A0 03    JZ    0x059C             (0378)     JZ      .ep0_request
                                        (0379) 
059A: 8F 53    JMP   _USBUART_1_Not_Supported|USBUART_1_CB_h2d_std_dev_08|USBUART_1_CB_h2d_std_dev_07|USBUART_1_CB_d2h_std_dev_07|USBUART_1_CB_h2d_std_dev_06|USBUART_1_CB_d2h_std_dev_05|USBUART_1_CB_h2d_std_dev_04|USBUART_1_CB_d2h_std_dev_04|USBUART_1_Not_Supported|...(0380)     JMP    _USBUART_1_Not_Supported    ; Stall the request if not configured
                                        (0381) ; Jump here if the device is configured or EP0 request
                                        (0382) .configured:
                                        (0383) .ep0_request:
059C: 5D 59    MOV   A,REG[0x59]        (0384)     MOV     A, REG[USBUART_1_EP0DATA + bRequest]
059E: 39 01    CMP   A,0x1              
05A0: D0 04    JNC   0x05A5             
05A2: 64       ASL   A                  
05A3: EF E5    JACC  0x0589             
05A5: 7D 04 EE LJMP  _USBUART_1_Not_Supported|USBUART_1_CB_h2d_std_dev_08|USBUART_1_CB_h2d_std_dev_07|USBUART_1_CB_d2h_std_dev_07|USBUART_1_CB_h2d_std_dev_06|USBUART_1_CB_d2h_std_dev_05|USBUART_1_CB_h2d_std_dev_04|USBUART_1_CB_d2h_std_dev_04|USBUART_1_Not_Supported|...
                                        (0385)     DISPATCHER USBUART_1_DT_d2h_std_ep, USBUART_1_DT_d2h_std_ep_Size, USBUART_1_Not_Supported
                                        (0386) 
                                        (0387) 
                                        (0388) ;-----------------------------------------------------------------------------
                                        (0389) USBUART_1_DT_h2d_std_ep:
                                        (0390) ;-----------------------------------------------------------------------------
05A8: 8F 45    JMP   _USBUART_1_Not_Supported|USBUART_1_CB_h2d_std_dev_08|USBUART_1_CB_h2d_std_dev_07|USBUART_1_CB_d2h_std_dev_07|USBUART_1_CB_h2d_std_dev_06|USBUART_1_CB_d2h_std_dev_05|USBUART_1_CB_h2d_std_dev_04|USBUART_1_CB_d2h_std_dev_04|USBUART_1_Not_Supported|...(0391)     jmp     USBUART_1_CB_h2d_std_ep_00
05AA: 81 57    JMP   USBUART_1_CB_h2d_std_ep_01(0392)     jmp     USBUART_1_CB_h2d_std_ep_01
05AC: 8F 41    JMP   _USBUART_1_Not_Supported|USBUART_1_CB_h2d_std_dev_08|USBUART_1_CB_h2d_std_dev_07|USBUART_1_CB_d2h_std_dev_07|USBUART_1_CB_h2d_std_dev_06|USBUART_1_CB_d2h_std_dev_05|USBUART_1_CB_h2d_std_dev_04|USBUART_1_CB_d2h_std_dev_04|USBUART_1_Not_Supported|...(0393)     jmp     USBUART_1_CB_h2d_std_ep_02
05AE: 81 88    JMP   USBUART_1_CB_h2d_std_ep_03(0394)     jmp     USBUART_1_CB_h2d_std_ep_03
                                        (0395) 
                                        (0396) USBUART_1_DT_h2d_std_ep_End:
                                        (0397) USBUART_1_DT_h2d_std_ep_Size: equ (USBUART_1_DT_h2d_std_ep_End-USBUART_1_DT_h2d_std_ep) / 2
                                        (0398) USBUART_1_DT_h2d_std_ep_Dispatch::
05B0: 3C 01 00 CMP   [0x1],0x0          (0399)     CMP     [USBUART_1_Configuration], 0  ; Is the device configured?
05B3: B0 0D    JNZ   0x05C1             (0400)     JNZ     .configured                ; Jump on configured
                                        (0401) 
05B5: 5D 5D    MOV   A,REG[0x5D]        (0402)     MOV     A, REG[USBUART_1_EP0DATA + wIndexHi] ; Is the request for EP0?
05B7: 53 1F    MOV   [0x1F],A           (0403)     MOV     [USBUART_1_t2], A          ; Use the UM temp var--Selector
05B9: 5D 5C    MOV   A,REG[0x5C]        (0404)     MOV     A, REG[USBUART_1_EP0DATA + wIndexLo] ;
05BB: 2C 1F    OR    [0x1F],A           (0405)     OR      [USBUART_1_t2], A          ; Use the UM temp var--Selector
05BD: A0 03    JZ    0x05C1             (0406)     JZ      .ep0_request
                                        (0407) 
05BF: 8F 2E    JMP   _USBUART_1_Not_Supported|USBUART_1_CB_h2d_std_dev_08|USBUART_1_CB_h2d_std_dev_07|USBUART_1_CB_d2h_std_dev_07|USBUART_1_CB_h2d_std_dev_06|USBUART_1_CB_d2h_std_dev_05|USBUART_1_CB_h2d_std_dev_04|USBUART_1_CB_d2h_std_dev_04|USBUART_1_Not_Supported|...(0408)     JMP    _USBUART_1_Not_Supported    ; Stall the request if not configured
                                        (0409) ; Jump here if the device is configured or EP0 request
                                        (0410) .configured:
                                        (0411) .ep0_request:
05C1: 5D 59    MOV   A,REG[0x59]        (0412)     MOV     A, REG[USBUART_1_EP0DATA + bRequest]
05C3: 39 04    CMP   A,0x4              
05C5: D0 04    JNC   0x05CA             
05C7: 64       ASL   A                  
05C8: EF DF    JACC  0x05A8             
05CA: 7D 04 EE LJMP  _USBUART_1_Not_Supported|USBUART_1_CB_h2d_std_dev_08|USBUART_1_CB_h2d_std_dev_07|USBUART_1_CB_d2h_std_dev_07|USBUART_1_CB_h2d_std_dev_06|USBUART_1_CB_d2h_std_dev_05|USBUART_1_CB_h2d_std_dev_04|USBUART_1_CB_d2h_std_dev_04|USBUART_1_Not_Supported|...
                                        (0413)     DISPATCHER USBUART_1_DT_h2d_std_ep, USBUART_1_DT_h2d_std_ep_Size, USBUART_1_Not_Supported
                                        (0414) 
                                        (0415) USBUART_1_GetTableEntry_Local_Std:
05CD: 7D 09 A0 LJMP  USBUART_1_GetTableEntry(0416)     LJMP    USBUART_1_GetTableEntry
                                        (0417) 
                                        (0418) USBUART_1_NoDataStageControlTransfer_Local_Std:
05D0: 7D 08 8D LJMP  _USBUART_1_InitNoDataStageControlTransfer|USBUART_1_NoDataStageControlTransfer|USBUART_1_InitNoDataStageControlTransfer(0419)     LJMP    USBUART_1_NoDataStageControlTransfer
                                        (0420) 
                                        (0421) ;-----------------------------------------------
                                        (0422) ; Add custom application code for routines
                                        (0423) ; redefined by USB_APP_SUPPLIED in USB_HID.INC
                                        (0424) ;-----------------------------------------------
                                        (0425) 
                                        (0426)    ;@PSoC_UserCode_BODY_1@ (Do not change this line.)
                                        (0427)    ;---------------------------------------------------
                                        (0428)    ; Insert your custom code below this banner
                                        (0429)    ;---------------------------------------------------
                                        (0430) 
                                        (0431)    ;---------------------------------------------------
                                        (0432)    ; Insert your custom code above this banner
                                        (0433)    ;---------------------------------------------------
                                        (0434)    ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0435) 
                                        (0436) ;-----------------------------------------------------------------------------
                                        (0437) ; FUNCTION NAME: USBUART_1_CB_d2h_std_dev_06
                                        (0438) ;
                                        (0439) ; DESCRIPTION:   Get Device Descriptor
                                        (0440) ;
                                        (0441) ;****************************************************************
                                        (0442) ; STANDARD DEVICE IN REQUEST: Get_Device_Descriptor
                                        (0443) ;****************************************************************
                                        (0444) ;
                                        (0445) ; bmRequestType  : (IN | STANDARD | DEVICE)       = 80h
                                        (0446) ; bRequest       : GET_DESCRIPTOR                 = 06h
                                        (0447) ; wValue         : DESCRIPTOR TYPE | INDEX        = xxxxh
                                        (0448) ; wIndex         : ZERO or LANG_ID                = xxxxh
                                        (0449) ; wLength        : SIZEOF_DESCRIPTOR              = --xxh
                                        (0450) ;
                                        (0451) ; The GET_DEVICE_DESCRIPTOR returns the specified descriptor if
                                        (0452) ; the descriptor exists.
                                        (0453) ;
                                        (0454) ; The upper byte of wValue contains the descriptor type and
                                        (0455) ; the lower byte contains the descriptor index. wIndex
                                        (0456) ; contains either 0000h or the Language ID. wLength contains
                                        (0457) ; the descriptor length. The actual descriptor information is
                                        (0458) ; transferred in subsequent data packets.
                                        (0459) ;
                                        (0460) ;****************************************************************
                                        (0461) ;
                                        (0462) ;-----------------------------------------------------------------------------
                                        (0463) ;
                                        (0464) ;  ARGUMENTS:
                                        (0465) ;
                                        (0466) ;  RETURNS:
                                        (0467) ;
                                        (0468) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0469) ;
                                        (0470) ;  THEORY of OPERATION or PROCEDURE:
                                        (0471) ;
                                        (0472) ;-----------------------------------------------------------------------------
                                        (0473) IF (USB_CB_SRC_d2h_std_dev_06 & USB_UM_SUPPLIED)
                                        (0474) export  USBUART_1_CB_d2h_std_dev_06
                                        (0475) USBUART_1_CB_d2h_std_dev_06:
                                        (0476) ;-----------------------------------------------------------------------------
                                        (0477) ; Dispatch to the proper handler
                                        (0478) ;-----------------------------------------------------------------------------
05D3: 5D 5B    MOV   A,REG[0x5B]        (0479)     MOV     A, REG[USBUART_1_EP0DATA+wValueHi] ; Get the descriptor type
05D5: 64       ASL   A                  (0480)     ASL     A                          ; Make it into a offset
05D6: 39 08    CMP   A,0x8              (0481)     CMP     A, GET_DESCR_DISPATCH_SIZE         ; Validity check
05D8: DF 15    JNC   _USBUART_1_Not_Supported|USBUART_1_CB_h2d_std_dev_08|USBUART_1_CB_h2d_std_dev_07|USBUART_1_CB_d2h_std_dev_07|USBUART_1_CB_h2d_std_dev_06|USBUART_1_CB_d2h_std_dev_05|USBUART_1_CB_h2d_std_dev_04|USBUART_1_CB_d2h_std_dev_04|USBUART_1_Not_Supported|...(0482)     JNC     USBUART_1_Not_Supported
                                        (0483) 
05DA: E0 01    JACC  0x05DC             (0484)     JACC    GET_DESCR_DISPATCH
                                        (0485) 
                                        (0486) GET_DESCR_DISPATCH:
05DC: 8F 11    JMP   _USBUART_1_Not_Supported|USBUART_1_CB_h2d_std_dev_08|USBUART_1_CB_h2d_std_dev_07|USBUART_1_CB_d2h_std_dev_07|USBUART_1_CB_h2d_std_dev_06|USBUART_1_CB_d2h_std_dev_05|USBUART_1_CB_h2d_std_dev_04|USBUART_1_CB_d2h_std_dev_04|USBUART_1_Not_Supported|...(0487)     JMP     USBUART_1_Not_Supported    ; Invalid
05DE: 80 28    JMP   0x0607             (0488)     JMP     USBUART_1_SendDeviceDescr  ; Device Descriptor
05E0: 80 03    JMP   0x05E4             (0489)     JMP     USBUART_1_SendConfigDescr  ; Configuration Descriptor
05E2: 80 34    JMP   0x0617             (0490)     JMP     USBUART_1_SendStringDescr  ; String Descriptor
                                        (0491) 
                                        (0492) GET_DESCR_DISPATCH_END:
                                        (0493) GET_DESCR_DISPATCH_SIZE: EQU (GET_DESCR_DISPATCH_END - GET_DESCR_DISPATCH)
                                        (0494) ;-----------------------------------------------------------------------------
                                        (0495) ; Configuration Descriptor Handler
                                        (0496) ;-----------------------------------------------------------------------------
                                        (0497) USBUART_1_SendConfigDescr:
05E4: 93 FF    CALL  USBUART_1_GET_DEVICE_TABLE_ENTRY(0498)     CALL    USBUART_1_GET_DEVICE_TABLE_ENTRY
05E6: 4B       SWAP  A,X                (0499)     SWAP    A, X
05E7: 01 02    ADD   A,0x2              (0500)     ADD     A, 2                       ; We want the pointer to the descriptor table (second entry)
05E9: 4B       SWAP  A,X                (0501)     SWAP    A, X
05EA: 09 00    ADC   A,0x0              (0502)     ADC     A, 0                       ; Don't forget the carry
05EC: 55 1F 20 MOV   [0x1F],0x20        (0503)     MOV    [USBUART_1_t2], USBUART_1_t1; Set up the destination
05EF: 93 E3    CALL  USBUART_1_GETWORD  (0504)     CALL    USBUART_1_GETWORD          ; Get the pointer
                                        (0505) 
05F1: 51 20    MOV   A,[0x20]           (0506)     MOV     A, [USBUART_1_t1]          ; Pointer MSB
05F3: 58 21    MOV   X,[0x21]           (0507)     MOV     X, [USBUART_1_t1+1]        ; Pointer LSB
                                        (0508) 
05F5: 08       PUSH  A                  (0509)     PUSH    A                          ; Save the MSB
                                        (0510) 
05F6: 5D 5A    MOV   A,REG[0x5A]        (0511)     MOV     A, REG[USBUART_1_EP0DATA+wValueLo]  ; Get the descriptor index
05F8: 53 1F    MOV   [0x1F],A           (0512)     MOV     [USBUART_1_t2], A          ; Use the UM temp var--Selector
05FA: 18       POP   A                  (0513)     POP     A                          ; Need the MSB for the range check
05FB: 08       PUSH  A                  (0514)     PUSH    A                          ; Save the MSB for after the range check
05FC: 28       ROMX                     (0515)     ROMX                               ; First entry is the table size (only a byte)
05FD: 3A 1F    CMP   A,[0x1F]           (0516)     CMP     A, [USBUART_1_t2]          ; Range check
05FF: D0 04    JNC   0x0604             (0517)     JNC     .range_ok
                                        (0518) 
0601: 18       POP   A                  (0519)     POP     A                          ; Fix the stack
0602: 8E EB    JMP   _USBUART_1_Not_Supported|USBUART_1_CB_h2d_std_dev_08|USBUART_1_CB_h2d_std_dev_07|USBUART_1_CB_d2h_std_dev_07|USBUART_1_CB_h2d_std_dev_06|USBUART_1_CB_d2h_std_dev_05|USBUART_1_CB_h2d_std_dev_04|USBUART_1_CB_d2h_std_dev_04|USBUART_1_Not_Supported|...(0520)     JMP    USBUART_1_Not_Supported
                                        (0521) 
                                        (0522) .range_ok:
0604: 18       POP   A                  (0523)     POP     A                          ; Get the MSB back
0605: 8F C7    JMP   0x05CD             (0524)     JMP     USBUART_1_GetTableEntry_Local_Std
                                        (0525) ;-----------------------------------------------------------------------------
                                        (0526) ; Device Descriptor Handler
                                        (0527) ;-----------------------------------------------------------------------------
                                        (0528) USBUART_1_SendDeviceDescr:
0607: 5F 1F 00 MOV   [0x1F],[0x0]       (0529)     MOV     [USBUART_1_t2], [USBUART_1_bCurrentDevice]  ; Use the UM temp var--Selector
060A: 50 01    MOV   A,0x1              (0530)     MOV     A,>USBUART_1_DEVICE_DESCR_TABLE  ; Get the ROM Address MSB
060C: 57 FA    MOV   X,0xFA             (0531)     MOV     X,<USBUART_1_DEVICE_DESCR_TABLE  ; Get the ROM Address LSB
060E: 28       ROMX                     (0532)     ROMX                               ; First entry is the table size (only a byte)
060F: 3A 1F    CMP   A,[0x1F]           (0533)     CMP     A, [USBUART_1_t2]          ; Range check
0611: CE DC    JC    _USBUART_1_Not_Supported|USBUART_1_CB_h2d_std_dev_08|USBUART_1_CB_h2d_std_dev_07|USBUART_1_CB_d2h_std_dev_07|USBUART_1_CB_h2d_std_dev_06|USBUART_1_CB_d2h_std_dev_05|USBUART_1_CB_h2d_std_dev_04|USBUART_1_CB_d2h_std_dev_04|USBUART_1_Not_Supported|...(0534)     JC      USBUART_1_Not_Supported
                                        (0535) 
0613: 50 01    MOV   A,0x1              (0536)     MOV     A,>USBUART_1_DEVICE_DESCR_TABLE  ; Get the ROM Address MSB
                                        (0537) 
0615: 8F B7    JMP   0x05CD             (0538)     JMP     USBUART_1_GetTableEntry_Local_Std
                                        (0539) ;-----------------------------------------------------------------------------
                                        (0540) ; String Descriptor Handler
                                        (0541) ;-----------------------------------------------------------------------------
                                        (0542) USBUART_1_SendStringDescr:
0617: 5D 5A    MOV   A,REG[0x5A]        (0543)     MOV     A, REG[USBUART_1_EP0DATA+wValueLo]  ; Get the descriptor index
0619: 53 1F    MOV   [0x1F],A           (0544)     MOV     [USBUART_1_t2], A          ; Use the UM temp var--Selector
                                        (0545) 
061B: 50 02    MOV   A,0x2              (0546)     MOV     A,>USBUART_1_StringTable   ; Get the ROM Address MSB
061D: 57 58    MOV   X,0x58             (0547)     MOV     X,<USBUART_1_StringTable   ; Get the ROM Address LSB
061F: 28       ROMX                     (0548)     ROMX                               ; First entry is the table size (only a byte)
0620: 3A 1F    CMP   A,[0x1F]           (0549)     CMP     A, [USBUART_1_t2]          ; Range check
0622: CE CB    JC    _USBUART_1_Not_Supported|USBUART_1_CB_h2d_std_dev_08|USBUART_1_CB_h2d_std_dev_07|USBUART_1_CB_d2h_std_dev_07|USBUART_1_CB_h2d_std_dev_06|USBUART_1_CB_d2h_std_dev_05|USBUART_1_CB_h2d_std_dev_04|USBUART_1_CB_d2h_std_dev_04|USBUART_1_Not_Supported|...(0550)     JC      USBUART_1_Not_Supported
                                        (0551) 
0624: 50 02    MOV   A,0x2              (0552)     MOV     A,>USBUART_1_StringTable   ; Get the ROM Address MSB
                                        (0553) 
0626: 8F A6    JMP   0x05CD             (0554)     JMP     USBUART_1_GetTableEntry_Local_Std
                                        (0555) ENDIF
                                        (0556) ;-----------------------------------------------------------------------------
                                        (0557) ;  FUNCTION NAME: USBUART_1_CB_d2h_std_dev_08
                                        (0558) ;
                                        (0559) ;  DESCRIPTION:   Get Device Configuration
                                        (0560) ;
                                        (0561) ;****************************************************************
                                        (0562) ; STANDARD DEVICE IN REQUEST: Get_Device_Configuration
                                        (0563) ;****************************************************************
                                        (0564) ;
                                        (0565) ; bmRequestType  : (IN | STANDARD | DEVICE)       = 80h
                                        (0566) ; bRequest       : GET_CONFIGURATION              = 08h
                                        (0567) ; wValue         : RESERVED                       = 0000h
                                        (0568) ; wIndex         : RESERVED                       = 0000h
                                        (0569) ; wLength        : SIZEOF_DEVICE_CONFIGURATION    = 0001h
                                        (0570) ;
                                        (0571) ; The GET_DEVICE_CONFIGURATION request returns the currently
                                        (0572) ; selected device configuration number.
                                        (0573) ;
                                        (0574) ; request_value and request_index contain 0000h. request_length
                                        (0575) ; contains 0001h and the one-byte configuration number is returned
                                        (0576) ; in a separate data transfer.
                                        (0577) ;
                                        (0578) ;-----------------------------------------------------------------------------
                                        (0579) ;
                                        (0580) ;  ARGUMENTS:
                                        (0581) ;
                                        (0582) ;  RETURNS:
                                        (0583) ;
                                        (0584) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0585) ;
                                        (0586) ;  THEORY of OPERATION or PROCEDURE:
                                        (0587) ;
                                        (0588) ;-----------------------------------------------------------------------------
                                        (0589) IF (USB_CB_SRC_d2h_std_dev_08 & USB_UM_SUPPLIED)
                                        (0590) .LITERAL
                                        (0591) GetConfigTransferDescrTable:
                                        (0592)     TD_START_TABLE  1                  ; One entry
                                        (0593)     TD_ENTRY    USB_DS_RAM, 1, USBUART_1_Configuration, NULL_PTR  ; Current configuration
                                        (0594) .ENDLITERAL
                                        (0595) export  USBUART_1_CB_d2h_std_dev_08
                                        (0596) USBUART_1_CB_d2h_std_dev_08:
0631: 55 1F 00 MOV   [0x1F],0x0         (0597)     MOV     [USBUART_1_t2], 0          ; Use the UM temp var--Selector
0634: 50 06    MOV   A,0x6              (0598)     MOV     A,>GetConfigTransferDescrTable  ; Get the ROM Address MSB
0636: 57 28    MOV   X,0x28             (0599)     MOV     X,<GetConfigTransferDescrTable  ; Get the ROM Address LSB
0638: 8F 94    JMP   0x05CD             (0600)     JMP     USBUART_1_GetTableEntry_Local_Std
                                        (0601) ENDIF
                                        (0602) ;-----------------------------------------------------------------------------
                                        (0603) ;  FUNCTION NAME: USBUART_1_CB_h2d_std_dev_01
                                        (0604) ;
                                        (0605) ;  DESCRIPTION:   Clear Device Feature
                                        (0606) ;
                                        (0607) ;****************************************************************
                                        (0608) ; STANDARD DEVICE OUT REQUEST: Clear_Device_Feature
                                        (0609) ;****************************************************************
                                        (0610) ;
                                        (0611) ; bmRequestType  : (OUT | STANDARD | DEVICE)      = 00h
                                        (0612) ; bRequest       : CLEAR_FEATURE                  = 01h
                                        (0613) ; wValue         : FEATURE_SELECTOR               = --xxh
                                        (0614) ; wIndex         : RESERVED                       = 0000h
                                        (0615) ; wLength        : RESERVED                       = 0000h
                                        (0616) ;
                                        (0617) ; The CLEAR_DEVICE_FEATURE request disables a particular feature
                                        (0618) ; for a device. The only feature supported for a device is the
                                        (0619) ; REMOTE_WAKEUP feature.
                                        (0620) ;
                                        (0621) ;****************************************************************
                                        (0622) ;-----------------------------------------------------------------------------
                                        (0623) ;
                                        (0624) ;  ARGUMENTS:
                                        (0625) ;
                                        (0626) ;  RETURNS:
                                        (0627) ;
                                        (0628) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0629) ;
                                        (0630) ;  THEORY of OPERATION or PROCEDURE:
                                        (0631) ;
                                        (0632) ;-----------------------------------------------------------------------------
                                        (0633) IF (USB_CB_SRC_h2d_std_dev_01 & USB_UM_SUPPLIED)
                                        (0634) export  USBUART_1_CB_h2d_std_dev_01
                                        (0635) USBUART_1_CB_h2d_std_dev_01:
063A: 5D 5A    MOV   A,REG[0x5A]        (0636)     MOV     A, REG[USBUART_1_EP0DATA+wValueLo]  ; Get the Feature Selector
                                        (0637)                                        ; Check against valid features
                                        (0638)                                        ;  for device recipient
063C: 39 01    CMP   A,0x1              (0639)     CMP     A, USB_DEVICE_REMOTE_WAKEUP  ; Only remote wakeup is defined for clear
063E: BE AF    JNZ   _USBUART_1_Not_Supported|USBUART_1_CB_h2d_std_dev_08|USBUART_1_CB_h2d_std_dev_07|USBUART_1_CB_d2h_std_dev_07|USBUART_1_CB_h2d_std_dev_06|USBUART_1_CB_d2h_std_dev_05|USBUART_1_CB_h2d_std_dev_04|USBUART_1_CB_d2h_std_dev_04|USBUART_1_Not_Supported|...(0640)     JNZ     USBUART_1_Not_Supported    ;
0640: 26 02 FD AND   [0x2],0xFD         (0641)     AND     [USBUART_1_DeviceStatus], ~USB_DEVICE_STATUS_REMOTE_WAKEUP
0643: 8F 8C    JMP   0x05D0             (0642)     JMP     USBUART_1_NoDataStageControlTransfer_Local_Std
                                        (0643) ENDIF
                                        (0644) ;-----------------------------------------------------------------------------
                                        (0645) ;  FUNCTION NAME: USBUART_1_CB_h2d_std_dev_03
                                        (0646) ;
                                        (0647) ;  DESCRIPTION:   Set Device Feature
                                        (0648) ;
                                        (0649) ;****************************************************************
                                        (0650) ; STANDARD DEVICE OUT REQUEST: Set_Device_Feature
                                        (0651) ;****************************************************************
                                        (0652) ;
                                        (0653) ; bmRequestType  : (OUT | STANDARD | DEVICE)      = 00h
                                        (0654) ; bRequest       : SET_FEATURE                    = 03h
                                        (0655) ; wValue         : FEATURE_SELECTOR               = --xxh
                                        (0656) ; wIndex         : RESERVED                       = 0000h
                                        (0657) ; wLength        : RESERVED                       = 0000h
                                        (0658) ;
                                        (0659) ; The SET_DEVICE_FEATURE request enables a particular feature
                                        (0660) ; on a device. The only feature supported for a device is the
                                        (0661) ; REMOTE_WAKEUP feature.
                                        (0662) ;
                                        (0663) ;****************************************************************
                                        (0664) ;-----------------------------------------------------------------------------
                                        (0665) ;
                                        (0666) ;  ARGUMENTS:
                                        (0667) ;
                                        (0668) ;  RETURNS:
                                        (0669) ;
                                        (0670) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0671) ;
                                        (0672) ;  THEORY of OPERATION or PROCEDURE:
                                        (0673) ;
                                        (0674) ;-----------------------------------------------------------------------------
                                        (0675) IF (USB_CB_SRC_h2d_std_dev_03 & USB_UM_SUPPLIED)
                                        (0676) export  USBUART_1_CB_h2d_std_dev_03
                                        (0677) USBUART_1_CB_h2d_std_dev_03:
0645: 5D 5A    MOV   A,REG[0x5A]        (0678)     MOV     A, REG[USBUART_1_EP0DATA+wValueLo]  ; Get the Feature Selector
                                        (0679)                                        ; Check against valid features
                                        (0680)                                        ;  for device recipient
0647: 39 01    CMP   A,0x1              (0681)     CMP     A, USB_DEVICE_REMOTE_WAKEUP  ; Remote wakeup?
0649: A0 07    JZ    0x0651             (0682)     JZ      .remote_wakeup
                                        (0683) 
064B: 39 02    CMP   A,0x2              (0684)     CMP     A, USB_TEST_MODE           ; Test Mode
064D: A0 08    JZ    0x0656             (0685)     JZ      .test_mode
                                        (0686) ; Flow here for any other selector is invalid for device recipient
064F: 8E 9E    JMP   _USBUART_1_Not_Supported|USBUART_1_CB_h2d_std_dev_08|USBUART_1_CB_h2d_std_dev_07|USBUART_1_CB_d2h_std_dev_07|USBUART_1_CB_h2d_std_dev_06|USBUART_1_CB_d2h_std_dev_05|USBUART_1_CB_h2d_std_dev_04|USBUART_1_CB_d2h_std_dev_04|USBUART_1_Not_Supported|...(0687)     JMP     USBUART_1_Not_Supported
                                        (0688) ; Jump here to enable remote wake up
                                        (0689) .remote_wakeup:
0651: 2E 02 02 OR    [0x2],0x2          (0690)     OR      [USBUART_1_DeviceStatus], USB_DEVICE_STATUS_REMOTE_WAKEUP
0654: 80 03    JMP   0x0658             (0691)     JMP     .finish
                                        (0692) ; Jump here to enable test mode
                                        (0693) .test_mode:
0656: 8E 97    JMP   _USBUART_1_Not_Supported|USBUART_1_CB_h2d_std_dev_08|USBUART_1_CB_h2d_std_dev_07|USBUART_1_CB_d2h_std_dev_07|USBUART_1_CB_h2d_std_dev_06|USBUART_1_CB_d2h_std_dev_05|USBUART_1_CB_h2d_std_dev_04|USBUART_1_CB_d2h_std_dev_04|USBUART_1_Not_Supported|...(0694)     JMP     USBUART_1_Not_Supported
                                        (0695) .finish:
0658: 8F 77    JMP   0x05D0             (0696)     JMP     USBUART_1_NoDataStageControlTransfer_Local_Std
                                        (0697) ENDIF
                                        (0698) ;-----------------------------------------------------------------------------
                                        (0699) ;  FUNCTION NAME: USBUART_1_CB_h2d_std_dev_05
                                        (0700) ;
                                        (0701) ;  DESCRIPTION:   Set Device Address
                                        (0702) ;
                                        (0703) ;****************************************************************
                                        (0704) ; STANDARD DEVICE OUT REQUEST: Set_Device_Address
                                        (0705) ;****************************************************************
                                        (0706) ;
                                        (0707) ; bmRequestType  : (OUT | STANDARD | DEVICE)      = 00h
                                        (0708) ; bRequest       : SET_ADDRESS                    = 05h
                                        (0709) ; wValue         : DEVICE_ADDRESS                 = 00xxh
                                        (0710) ; wIndex         : RESERVED                       = 0000h
                                        (0711) ; wLength        : RESERVED                       = 0000h
                                        (0712) ;
                                        (0713) ; The SET_DEVICE_ADDRESS request sets the USB device address
                                        (0714) ; for all future USB accesses.
                                        (0715) ;
                                        (0716) ;****************************************************************
                                        (0717) ;
                                        (0718) ;-----------------------------------------------------------------------------
                                        (0719) ;
                                        (0720) ;  ARGUMENTS:
                                        (0721) ;
                                        (0722) ;  RETURNS:
                                        (0723) ;
                                        (0724) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0725) ;
                                        (0726) ;  THEORY of OPERATION or PROCEDURE:
                                        (0727) ;
                                        (0728) ;-----------------------------------------------------------------------------
                                        (0729) 
                                        (0730) IF (USB_CB_SRC_h2d_std_dev_05 & USB_UM_SUPPLIED)
                                        (0731) export  USBUART_1_CB_h2d_std_dev_05
                                        (0732) USBUART_1_CB_h2d_std_dev_05:
                                        (0733)       
065A: 55 1E 01 MOV   [0x1E],0x1         (0734)     MOV     [USBUART_1_fDataPending], USB_ADDRESS_CHANGE_PENDING       
065D: 5D 5A    MOV   A,REG[0x5A]        (0735)     MOV     A, REG[USBUART_1_EP0DATA+wValueLo]       
065F: 53 0C    MOV   [0xC],A            (0736)     MOV     [USBUART_1_TransferBuffer],A       
                                        (0737)                                                    
0661: 8F 6E    JMP   0x05D0             (0738)     JMP     USBUART_1_NoDataStageControlTransfer_Local_Std
                                        (0739) ENDIF
                                        (0740) 
                                        (0741) 
                                        (0742) ;-----------------------------------------------------------------------------
                                        (0743) ;  FUNCTION NAME: USBUART_1_CB_h2d_std_dev_09
                                        (0744) ;
                                        (0745) ;  DESCRIPTION:   Set Configuration
                                        (0746) ;
                                        (0747) ;****************************************************************
                                        (0748) ; STANDARD DEVICE OUT REQUEST: Set_Device_Configuration
                                        (0749) ;****************************************************************
                                        (0750) ;
                                        (0751) ; bmRequestType  : (OUT | STANDARD | DEVICE)      = 00h
                                        (0752) ; bRequest       : SET_CONFIGURATION              = 09h
                                        (0753) ; wValue         : CONFIGURATION_VALUE            = --xxh
                                        (0754) ; wIndex         : RESERVED                       = 0000h
                                        (0755) ; wLength        : RESERVED                       = 0000h
                                        (0756) ;
                                        (0757) ; The SET_DEVICE_CONFIGURATION request selects a device
                                        (0758) ; configuration to be activated as the current configuration.
                                        (0759) ;
                                        (0760) ;****************************************************************
                                        (0761) ;-----------------------------------------------------------------------------
                                        (0762) ;
                                        (0763) ;  ARGUMENTS:
                                        (0764) ;
                                        (0765) ;  RETURNS:
                                        (0766) ;
                                        (0767) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0768) ;
                                        (0769) ;  THEORY of OPERATION or PROCEDURE:
                                        (0770) ;
                                        (0771) ;-----------------------------------------------------------------------------
                                        (0772) 
                                        (0773) IF (USB_CB_SRC_h2d_std_dev_09 & USB_UM_SUPPLIED)
                                        (0774) export  USBUART_1_CB_h2d_std_dev_09
                                        (0775) USBUART_1_CB_h2d_std_dev_09:
0663: 93 80    CALL  USBUART_1_GET_DEVICE_TABLE_ENTRY(0776)     CALL    USBUART_1_GET_DEVICE_TABLE_ENTRY  ; Get the selected device
0665: 55 1F 20 MOV   [0x1F],0x20        (0777)     MOV     [USBUART_1_t2],USBUART_1_t1  ; Set the GETWORD destination
0668: 93 6A    CALL  USBUART_1_GETWORD  (0778)     CALL    USBUART_1_GETWORD          ; Get the pointer to the CONFIG_LOOKUP table
                                        (0779)                                        ; ITempW has the address
066A: 5D 5A    MOV   A,REG[0x5A]        (0780)     MOV     A, REG[USBUART_1_EP0DATA+wValueLo]  ; Get the configuration number
066C: 53 1F    MOV   [0x1F],A           (0781)     MOV     [USBUART_1_t2],A           ; Save it
066E: 51 20    MOV   A,[0x20]           (0782)     MOV     A, [USBUART_1_t1]          ; Get the CONFIG_LOOKUP ROM Address MSB
0670: 58 21    MOV   X,[0x21]           (0783)     MOV     X, [USBUART_1_t1+1]        ; Get the CONFIG_LOOKUP ROM Address LSB
0672: 28       ROMX                     (0784)     ROMX                               ; First entry is the table size (only a byte)
0673: 3A 1F    CMP   A,[0x1F]           (0785)     CMP     A, [USBUART_1_t2]          ; Range check
0675: CE 78    JC    _USBUART_1_Not_Supported|USBUART_1_CB_h2d_std_dev_08|USBUART_1_CB_h2d_std_dev_07|USBUART_1_CB_d2h_std_dev_07|USBUART_1_CB_h2d_std_dev_06|USBUART_1_CB_d2h_std_dev_05|USBUART_1_CB_h2d_std_dev_04|USBUART_1_CB_d2h_std_dev_04|USBUART_1_Not_Supported|...(0786)     JC      USBUART_1_Not_Supported
                                        (0787) 
                                        (0788) ; Refactored from the two loops below
0677: 5F 01 1F MOV   [0x1],[0x1F]       (0789)     MOV     [USBUART_1_Configuration],[USBUART_1_t2]  ; Save the config number
                                        (0790) 
067A: 3C 1F 00 CMP   [0x1F],0x0         (0791)     CMP     [USBUART_1_t2], 0          ; Unconfigure?
067D: A0 25    JZ    0x06A3             (0792)     JZ      .unconfigure
                                        (0793) 
                                        (0794) ; Flow here to configure the endpoints
067F: 51 20    MOV   A,[0x20]           (0795)     MOV     A, [USBUART_1_t1]          ; Get the CONFIG_LOOKUP ROM Address MSB
0681: 58 21    MOV   X,[0x21]           (0796)     MOV     X, [USBUART_1_t1+1]        ; Get the CONFIG_LOOKUP ROM Address LSB
0683: 75       INC   X                  (0797)     INC     X                          ; Point to the first table entry
0684: 09 00    ADC   A,0x0              (0798)     ADC     A, 0                       ;
0686: 55 1F 20 MOV   [0x1F],0x20        (0799)     MOV    [USBUART_1_t2], USBUART_1_t1; Set up the destination
0689: 93 49    CALL  USBUART_1_GETWORD  (0800)     CALL    USBUART_1_GETWORD          ; Get the pointer to the CONFIG_LOOKUP table
                                        (0801)                                        ; ITempW has the address
068B: 57 00    MOV   X,0x0              (0802)     MOV     X, 0                       ; Start the index at 0, but we INC first
                                        (0803) .configure_next:
068D: 75       INC   X                  (0804)     INC     X                          ; Do the next one
068E: 10       PUSH  X                  (0805)     PUSH    X                          ; Save the endpoint number
068F: 51 20    MOV   A,[0x20]           (0806)     MOV     A, [USBUART_1_t1]          ; Get the CONFIG_LOOKUP ROM Address MSB
0691: 58 21    MOV   X,[0x21]           (0807)     MOV     X, [USBUART_1_t1+1]        ; Get the CONFIG_LOOKUP ROM Address LSB
0693: 28       ROMX                     (0808)     ROMX
0694: 76 21    INC   [0x21]             (0809)     INC     [USBUART_1_t1+1]           ; Point to the next
0696: 0E 20 00 ADC   [0x20],0x0         (0810)     ADC     [USBUART_1_t1], 0          ;
0699: 20       POP   X                  (0811)     POP     X
069A: 90 C7    CALL  0x0763             (0812)     CALL    ConfigureEP                ; X contains the EP number
                                        (0813)                                        ; A contains the EP Direction
069C: 5B       MOV   A,X                (0814)     MOV     A, X                       ;
069D: 39 04    CMP   A,0x4              (0815)     CMP     A, USB_MAX_EP_NUMBER       ; Configure each of the endpoints
069F: BF ED    JNZ   0x068D             (0816)     JNZ     .configure_next            ; Do another one?
                                        (0817) ; Flow here when we are done
06A1: 80 10    JMP   0x06B2             (0818)     JMP     .done
06A3: 71 10    OR    F,0x10             
                                        (0819) 
                                        (0820) ; Jump here to unconfigure the endpoints
                                        (0821) .unconfigure:
                                        (0822)     M8C_SetBank1	; _EP1MODE is in Bank 1
06A5: 57 04    MOV   X,0x4              (0823)     MOV     X, USB_MAX_EP_NUMBER       ; Configure each of the endpoints
                                        (0824) .unconfigure_next:
06A7: 56 22 02 MOV   [X+34],0x2         (0825)     MOV     [X+USBUART_1_EndpointAPIStatus], NO_EVENT_ALLOWED ; For the API
06AA: 63 C3 00 MOV   REG[X+0xC3],0x0    (0826)     MOV     REG[X+USBUART_1_EP1MODE-1], USB_MODE_DISABLE ; Disable the endpoint
06AD: 79       DEC   X                  (0827)     DEC     X                          ; One more down
06AE: BF F8    JNZ   0x06A7             (0828)     JNZ     .unconfigure_next          ; Don't unconfigure EP0
06B0: 70 EF    AND   F,0xEF             
                                        (0829) 	M8C_SetBank0
                                        (0830) .done:
06B2: 8F 1D    JMP   0x05D0             (0831)     JMP     USBUART_1_NoDataStageControlTransfer_Local_Std
                                        (0832) ENDIF
                                        (0833) 
                                        (0834) 
                                        (0835) ;-----------------------------------------------------------------------------
                                        (0836) ;  FUNCTION NAME: USBUART_1_CB_d2h_std_ifc_00
                                        (0837) ;
                                        (0838) ;  DESCRIPTION:   Get Interface Status
                                        (0839) ;
                                        (0840) ;****************************************************************
                                        (0841) ; STANDARD INTERFACE IN REQUEST: Get_Interface_Status
                                        (0842) ;****************************************************************
                                        (0843) ;
                                        (0844) ; bmRequestType  : (IN | STANDARD | INTERFACE)    = 81h
                                        (0845) ; bRequest       : GET_STATUS                     = 00h
                                        (0846) ; wValue         : RESERVED                       = 0000h
                                        (0847) ; wIndex         : INTERFACE                      = --xxh
                                        (0848) ; wLength        : SIZEOF_INTERFACE_STATUS        = 0002h
                                        (0849) ;
                                        (0850) ; The GET_INTERFACE_STATUS request returns status for the
                                        (0851) ; specified interface.
                                        (0852) ;
                                        (0853) ;****************************************************************
                                        (0854) ;-----------------------------------------------------------------------------
                                        (0855) ;
                                        (0856) ;  ARGUMENTS:
                                        (0857) ;
                                        (0858) ;  RETURNS:
                                        (0859) ;
                                        (0860) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0861) ;
                                        (0862) ;  THEORY of OPERATION or PROCEDURE:
                                        (0863) ;
                                        (0864) ;-----------------------------------------------------------------------------
                                        (0865) IF (USB_CB_SRC_d2h_std_ifc_00 & USB_UM_SUPPLIED)
                                        (0866) .LITERAL
                                        (0867) GetInterfaceStatusTransferDescrTable:
                                        (0868)     TD_START_TABLE  1                  ; One entry
                                        (0869)     TD_ENTRY        USB_DS_RAM, 2, USBUART_1_TransferBuffer, NULL_PTR  ; Reuse the transfer buffer
                                        (0870) .ENDLITERAL
                                        (0871) export  USBUART_1_CB_d2h_std_ifc_00
                                        (0872) USBUART_1_CB_d2h_std_ifc_00:
                                        (0873) 
06BD: 55 0C 00 MOV   [0xC],0x0          (0874)     MOV     [USBUART_1_TransferBuffer], 0     ; Zero the transfer buffer
06C0: 55 0D 00 MOV   [0xD],0x0          (0875)     MOV     [USBUART_1_TransferBuffer+1], 0  ;
                                        (0876) 
06C3: 55 1F 00 MOV   [0x1F],0x0         (0877)     MOV     [USBUART_1_t2], 0          ; Use the UM temp var--Selector
06C6: 50 06    MOV   A,0x6              (0878)     MOV     A,>GetInterfaceStatusTransferDescrTable  ; Get the ROM Address MSB
06C8: 57 B4    MOV   X,0xB4             (0879)     MOV     X,<GetInterfaceStatusTransferDescrTable  ; Get the ROM Address LSB
                                        (0880) 
06CA: 8F 02    JMP   0x05CD             (0881)     JMP     USBUART_1_GetTableEntry_Local_Std
                                        (0882) ENDIF
                                        (0883) ;-----------------------------------------------------------------------------
                                        (0884) ;  FUNCTION NAME: USBUART_1_CB_d2h_std_ifc_10
                                        (0885) ;
                                        (0886) ;  DESCRIPTION:   Get Interface
                                        (0887) ;
                                        (0888) ;****************************************************************
                                        (0889) ; STANDARD INTERFACE IN REQUEST: Get_Interface
                                        (0890) ;****************************************************************
                                        (0891) ;
                                        (0892) ; bmRequestType  : (IN | STANDARD | INTERFACE)    = 81h
                                        (0893) ; bRequest       : GET_INTERFACE                  = 0Ah
                                        (0894) ; wValue         : RESERVED                       = 0000h
                                        (0895) ; wIndex         : INTERFACE                      = xxxxh
                                        (0896) ; wLength        : SIZEOF_GET_INTERFACE           = 0001h
                                        (0897) ;
                                        (0898) ; The GET_INTERFACE request returns the selected alternate
                                        (0899) ; setting for the specified interface.
                                        (0900) ;
                                        (0901) ;****************************************************************
                                        (0902) ;-----------------------------------------------------------------------------
                                        (0903) ;
                                        (0904) ;  ARGUMENTS:
                                        (0905) ;
                                        (0906) ;  RETURNS:
                                        (0907) ;
                                        (0908) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0909) ;
                                        (0910) ;  THEORY of OPERATION or PROCEDURE:
                                        (0911) ;
                                        (0912) ;-----------------------------------------------------------------------------
                                        (0913) 
                                        (0914) IF (USB_CB_SRC_d2h_std_ifc_10 & USB_UM_SUPPLIED)
                                        (0915) .LITERAL
                                        (0916) GetInterfaceTransferDescrTable:
                                        (0917)     TD_START_TABLE  1                  ; One entry
                                        (0918)     TD_ENTRY        USB_DS_RAM, 1, USBUART_1_TransferBuffer, NULL_PTR  ; Reuse the transfer buffer
                                        (0919) .ENDLITERAL
                                        (0920) export  USBUART_1_CB_d2h_std_ifc_10
                                        (0921) USBUART_1_CB_d2h_std_ifc_10:
06D5: 5D 5C    MOV   A,REG[0x5C]        (0922)     MOV     A, REG[USBUART_1_EP0DATA+wIndexLo]  ; Get the interface number
06D7: 39 02    CMP   A,0x2              (0923)     CMP     A, 2                       ; Valid interface number? (UM Parameter: NumInterfaces)
06D9: DE 14    JNC   _USBUART_1_Not_Supported|USBUART_1_CB_h2d_std_dev_08|USBUART_1_CB_h2d_std_dev_07|USBUART_1_CB_d2h_std_dev_07|USBUART_1_CB_h2d_std_dev_06|USBUART_1_CB_d2h_std_dev_05|USBUART_1_CB_h2d_std_dev_04|USBUART_1_CB_d2h_std_dev_04|USBUART_1_Not_Supported|...(0924)     JNC     USBUART_1_Not_Supported
                                        (0925) 
06DB: 5C       MOV   X,A                (0926)     MOV     X, A                       ; The interface number is the index into alternates settings table
                                        (0927) 
06DC: 52 03    MOV   A,[X+3]            (0928)     MOV     A, [X + USBUART_1_InterfaceSetting]  ; Save the current interface setting
06DE: 53 0C    MOV   [0xC],A            (0929)     MOV     [USBUART_1_TransferBuffer], A     ; into the transfer buffer
                                        (0930) 
06E0: 55 1F 00 MOV   [0x1F],0x0         (0931)     MOV     [USBUART_1_t2], 0          ; Use the UM temp var--Selector
06E3: 50 06    MOV   A,0x6              (0932)     MOV     A,>GetInterfaceTransferDescrTable  ; Get the ROM Address MSB
06E5: 57 CC    MOV   X,0xCC             (0933)     MOV     X,<GetInterfaceTransferDescrTable  ; Get the ROM Address LSB
                                        (0934) 
06E7: 8E E5    JMP   0x05CD             (0935)     JMP     USBUART_1_GetTableEntry_Local_Std
                                        (0936) ENDIF
                                        (0937) 
                                        (0938) 
                                        (0939) ;-----------------------------------------------------------------------------
                                        (0940) ;  FUNCTION NAME: USBUART_1_CB_d2h_std_ep_00
                                        (0941) ;
                                        (0942) ;  DESCRIPTION:   Get Endpoint Status
                                        (0943) ;
                                        (0944) ;****************************************************************
                                        (0945) ; STANDARD ENDPOINT IN REQUEST: Get_Endpoint_Status
                                        (0946) ;****************************************************************
                                        (0947) ;
                                        (0948) ; bmRequestType  : (IN | STANDARD | ENDPOINT)     = 82h
                                        (0949) ; bRequest       : GET_STATUS                     = 00h
                                        (0950) ; wValue         : RESERVED                       = 0000h
                                        (0951) ; wIndex         : ENDPOINT                       = 00xxh
                                        (0952) ; wLength        : SIZEOF_ENDPOINT_STATUS         = 0002h
                                        (0953) ;
                                        (0954) ; The GET_ENDPOINT_STATUS request returns status for the specified
                                        (0955) ; endpoint.
                                        (0956) ;
                                        (0957) ;****************************************************************
                                        (0958) ;-----------------------------------------------------------------------------
                                        (0959) ;
                                        (0960) ;  ARGUMENTS:
                                        (0961) ;
                                        (0962) ;  RETURNS:
                                        (0963) ;
                                        (0964) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0965) ;
                                        (0966) ;  THEORY of OPERATION or PROCEDURE:
                                        (0967) ;
                                        (0968) ;-----------------------------------------------------------------------------
                                        (0969) IF (USB_CB_SRC_d2h_std_ep_00 & USB_UM_SUPPLIED)
                                        (0970) export  USBUART_1_CB_d2h_std_ep_00
                                        (0971) USBUART_1_CB_d2h_std_ep_00:
06E9: 5D 5C    MOV   A,REG[0x5C]        (0972)     MOV     A, REG[USBUART_1_EP0DATA+wIndexLo]  ; Get the endpoint number
06EB: 21 7F    AND   A,0x7F             (0973)     AND     A, ~USB_DIR_IN             ; Strip off the direction bit
06ED: 39 05    CMP   A,0x5              (0974)     CMP     A, USB_NUM_ENDPOINTS       ; Range check
06EF: DD FE    JNC   _USBUART_1_Not_Supported|USBUART_1_CB_h2d_std_dev_08|USBUART_1_CB_h2d_std_dev_07|USBUART_1_CB_d2h_std_dev_07|USBUART_1_CB_h2d_std_dev_06|USBUART_1_CB_d2h_std_dev_05|USBUART_1_CB_h2d_std_dev_04|USBUART_1_CB_d2h_std_dev_04|USBUART_1_Not_Supported|...(0975)     JNC     USBUART_1_Not_Supported
                                        (0976) 
06F1: 5C       MOV   X,A                (0977)     MOV     X, A                       ; The endpoint number is the index
                                        (0978) 
06F2: 55 1F 00 MOV   [0x1F],0x0         (0979)     MOV     [USBUART_1_t2], 0          ; Use the UM temp var--Selector
                                        (0980) 
06F5: 55 0D 00 MOV   [0xD],0x0          (0981)     MOV     [USBUART_1_TransferBuffer + 1], 0  ; Use the UM Transfer Buffer
06F8: 52 05    MOV   A,[X+5]            (0982)     MOV     A, [X + USBUART_1_EndpointStatus]  ; Get the status
06FA: 53 0C    MOV   [0xC],A            (0983)     MOV     [USBUART_1_TransferBuffer], A  ; Save it in the report
                                        (0984) 
06FC: 50 04    MOV   A,0x4              (0985)     MOV     A,>GetStatusTransferDescrTable  ; Get the ROM Address MSB
06FE: 57 F5    MOV   X,0xF5             (0986)     MOV     X,<GetStatusTransferDescrTable  ; Get the ROM Address LSB
                                        (0987) 
0700: 8E CC    JMP   0x05CD             (0988)     JMP     USBUART_1_GetTableEntry_Local_Std
                                        (0989) ENDIF
                                        (0990) 
                                        (0991) ;-----------------------------------------------------------------------------
                                        (0992) ;  FUNCTION NAME: USBUART_1_CB_h2d_std_ep_01
                                        (0993) ;
                                        (0994) ;  DESCRIPTION:   Clear Endpoint Feature
                                        (0995) ;
                                        (0996) ;****************************************************************
                                        (0997) ; STANDARD ENDPOINT OUT REQUEST: Clear_Endpoint_Feature
                                        (0998) ;****************************************************************
                                        (0999) ;
                                        (1000) ; bmRequestType  : (OUT | STANDARD | ENDPOINT)    = 02h
                                        (1001) ; bRequest       : CLEAR_FEATURE                  = 01h
                                        (1002) ; wValue         : FEATURE_SELECTOR               = --xxh
                                        (1003) ; wIndex         : ENDPOINT                       = 00xxh
                                        (1004) ; wLength        : RESERVED                       = 0000h
                                        (1005) ;
                                        (1006) ; The CLEAR_ENDPOINT_FEATURE request disables a particular
                                        (1007) ; feature for an endpoint.
                                        (1008) ;
                                        (1009) ; The only feature supported for an endpoint is the EP_HALT
                                        (1010) ; feature.
                                        (1011) ;
                                        (1012) ;****************************************************************
                                        (1013) ;-----------------------------------------------------------------------------
                                        (1014) ;
                                        (1015) ;  ARGUMENTS:
                                        (1016) ;
                                        (1017) ;  RETURNS:
                                        (1018) ;
                                        (1019) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (1020) ;
                                        (1021) ;  THEORY of OPERATION or PROCEDURE:
                                        (1022) ;
                                        (1023) ;-----------------------------------------------------------------------------
                                        (1024) IF (USB_CB_SRC_h2d_std_ep_01 & USB_UM_SUPPLIED)
                                        (1025) export  USBUART_1_CB_h2d_std_ep_01
                                        (1026) USBUART_1_CB_h2d_std_ep_01:
0702: 5D 5A    MOV   A,REG[0x5A]        (1027)     MOV     A, REG[USBUART_1_EP0DATA+wValueLo]  ; Get the feature selector
0704: 39 00    CMP   A,0x0              (1028)     CMP     A, USB_ENDPOINT_HALT       ; Halt is the only selector defined for endpoints
0706: BD E7    JNZ   _USBUART_1_Not_Supported|USBUART_1_CB_h2d_std_dev_08|USBUART_1_CB_h2d_std_dev_07|USBUART_1_CB_d2h_std_dev_07|USBUART_1_CB_h2d_std_dev_06|USBUART_1_CB_d2h_std_dev_05|USBUART_1_CB_h2d_std_dev_04|USBUART_1_CB_d2h_std_dev_04|USBUART_1_Not_Supported|...(1029)     JNZ     USBUART_1_Not_Supported
                                        (1030) 
0708: 5D 5C    MOV   A,REG[0x5C]        (1031)     MOV     A, REG[USBUART_1_EP0DATA+wIndexLo]  ; Get the Endpoint number
070A: 21 7F    AND   A,0x7F             (1032)     AND     A, ~USB_DIR_IN             ; Strip off the direction bit
070C: 39 00    CMP   A,0x0              (1033)     CMP     A, 0                       ; Since we can't halt the Control Endpoint
070E: A0 24    JZ    0x0733             (1034)     JZ      .done
                                        (1035) 
0710: 39 05    CMP   A,0x5              (1036)     CMP     A, USB_NUM_ENDPOINTS       ; Range check
0712: DD DB    JNC   _USBUART_1_Not_Supported|USBUART_1_CB_h2d_std_dev_08|USBUART_1_CB_h2d_std_dev_07|USBUART_1_CB_d2h_std_dev_07|USBUART_1_CB_h2d_std_dev_06|USBUART_1_CB_d2h_std_dev_05|USBUART_1_CB_h2d_std_dev_04|USBUART_1_CB_d2h_std_dev_04|USBUART_1_Not_Supported|...(1037)     JNC     USBUART_1_Not_Supported
                                        (1038) 
0714: 5C       MOV   X,A                (1039)     MOV     X, A                       ; Endpoint number is the index
0715: 27 05 FE AND   [X+5],0xFE         (1040)     AND     [X+USBUART_1_EndpointStatus], ~USB_ENDPOINT_STATUS_HALT  ; Clear the endpoint halt
                                        (1041) 
0718: F4 77    INDEX USBUART_1_USB_EP_BIT_LOOKUP(1042)     index   USBUART_1_USB_EP_BIT_LOOKUP	   ; Find bit position for endpoint
071A: 31 FF    XOR   A,0xFF             (1043)     xor     A, FFh
071C: 24 1D    AND   [0x1D],A           (1044)     and     [USBUART_1_EPDataToggle], A ; Clear the data toggle for this endpoint
071E: 49 5C 80 TST   REG[0x5C],0x80     (1045)     TST     REG[USBUART_1_EP0DATA+wIndexLo], USB_DIR_IN  ; IN or OUT endpoint?
0721: 71 10    OR    F,0x10             
                                        (1046)     M8C_SetBank1	                      ; For EP1_MODE register
0723: B0 09    JNZ   0x072D             (1047)     JNZ     .in
                                        (1048) 
                                        (1049)     ; Mark endpoint as empty so it will be reloaded
0725: 56 22 00 MOV   [X+34],0x0         (1050)     mov     [X+USBUART_1_EndpointAPIStatus], NO_EVENT_PENDING
0728: 63 C3 09 MOV   REG[X+0xC3],0x9    (1051)     mov     reg[X + USBUART_1_EP1MODE - 1], USB_MODE_ACK_OUT    ; ACK the endpoint
072B: 80 07    JMP   0x0733             (1052)     JMP     .done
                                        (1053) .in:
072D: 56 22 01 MOV   [X+34],0x1         (1054)     mov     [X+USBUART_1_EndpointAPIStatus], EVENT_PENDING
0730: 63 C3 0C MOV   REG[X+0xC3],0xC    (1055)     MOV     REG[X + USBUART_1_EP1MODE - 1], USB_MODE_NAK_IN  ; NAK the endpoint
0733: 70 EF    AND   F,0xEF             
                                        (1056) .done:
                                        (1057) 	M8C_SetBank0
0735: 8E 9A    JMP   0x05D0             (1058)     JMP     USBUART_1_NoDataStageControlTransfer_Local_Std
                                        (1059) ENDIF
                                        (1060) ;-----------------------------------------------------------------------------
                                        (1061) ;  FUNCTION NAME: USBUART_1_CB_h2d_std_ep_03
                                        (1062) ;
                                        (1063) ;  DESCRIPTION:   Set Endpoint Feature
                                        (1064) ;
                                        (1065) ;****************************************************************
                                        (1066) ; STANDARD ENDPOINT OUT REQUEST: Set_Endpoint_Feature
                                        (1067) ;****************************************************************
                                        (1068) ;
                                        (1069) ; bmRequestType  : (OUT | STANDARD | ENDPOINT)    = 02h
                                        (1070) ; bRequest       : SET_FEATURE                    = 03h
                                        (1071) ; wValue         : FEATURE_SELECTOR               = --xxh
                                        (1072) ; wIndex         : ENDPOINT                       = 00xxh
                                        (1073) ; wLength        : RESERVED                       = 0000h
                                        (1074) ;
                                        (1075) ; The SET_ENDPOINT_FEATURE request enables a particular feature
                                        (1076) ; for a specific endpoint. The only feature supported for an
                                        (1077) ; endpoint is the EP_HALT feature.
                                        (1078) ;
                                        (1079) ;****************************************************************
                                        (1080) ;-----------------------------------------------------------------------------
                                        (1081) ;
                                        (1082) ;  ARGUMENTS:
                                        (1083) ;
                                        (1084) ;  RETURNS:
                                        (1085) ;
                                        (1086) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (1087) ;
                                        (1088) ;  THEORY of OPERATION or PROCEDURE:
                                        (1089) ;
                                        (1090) ;-----------------------------------------------------------------------------
                                        (1091) IF (USB_CB_SRC_h2d_std_ep_03 & USB_UM_SUPPLIED)
                                        (1092) export  USBUART_1_CB_h2d_std_ep_03
                                        (1093) USBUART_1_CB_h2d_std_ep_03:
0737: 5D 5A    MOV   A,REG[0x5A]        (1094)     MOV     A, REG[USBUART_1_EP0DATA+wValueLo]  ; Get the feature selector
0739: 39 00    CMP   A,0x0              (1095)     CMP     A, USB_ENDPOINT_HALT       ; Halt is the only selector defined for endpoints
073B: BD B2    JNZ   _USBUART_1_Not_Supported|USBUART_1_CB_h2d_std_dev_08|USBUART_1_CB_h2d_std_dev_07|USBUART_1_CB_d2h_std_dev_07|USBUART_1_CB_h2d_std_dev_06|USBUART_1_CB_d2h_std_dev_05|USBUART_1_CB_h2d_std_dev_04|USBUART_1_CB_d2h_std_dev_04|USBUART_1_Not_Supported|...(1096)     JNZ     USBUART_1_Not_Supported
                                        (1097) 
073D: 5D 5C    MOV   A,REG[0x5C]        (1098)     MOV     A, REG[USBUART_1_EP0DATA+wIndexLo]  ; Get the Endpoint number
073F: 21 7F    AND   A,0x7F             (1099)     AND     A, ~USB_DIR_IN             ; Strip off the direction bit
0741: 39 00    CMP   A,0x0              (1100)     CMP     A, 0                       ; Never halt the Control Endpoint
0743: A0 1B    JZ    0x075F             (1101)     JZ      .done
                                        (1102) 
0745: 39 05    CMP   A,0x5              (1103)     CMP     A, USB_NUM_ENDPOINTS       ; Range check
0747: DD A6    JNC   _USBUART_1_Not_Supported|USBUART_1_CB_h2d_std_dev_08|USBUART_1_CB_h2d_std_dev_07|USBUART_1_CB_d2h_std_dev_07|USBUART_1_CB_h2d_std_dev_06|USBUART_1_CB_d2h_std_dev_05|USBUART_1_CB_h2d_std_dev_04|USBUART_1_CB_d2h_std_dev_04|USBUART_1_Not_Supported|...(1104)     JNC     USBUART_1_Not_Supported
                                        (1105) 
0749: 5C       MOV   X,A                (1106)     MOV     X, A                       ; Endpoint number is the index
                                        (1107) 
074A: 2F 05 01 OR    [X+5],0x1          (1108)     OR      [X+USBUART_1_EndpointStatus], USB_ENDPOINT_STATUS_HALT  ; Halt the endpoint
074D: 56 22 02 MOV   [X+34],0x2         (1109)     mov     [X+USBUART_1_EndpointAPIStatus], NO_EVENT_ALLOWED
                                        (1110) 
0750: 49 5C 80 TST   REG[0x5C],0x80     (1111)     TST     REG[USBUART_1_EP0DATA+wIndexLo], USB_DIR_IN  ; IN or OUT endpoint?
0753: 71 10    OR    F,0x10             
                                        (1112)     M8C_SetBank1	                      ; For EP1_MODE register
0755: B0 06    JNZ   0x075C             (1113)     JNZ     .in
                                        (1114) 
0757: 63 C3 89 MOV   REG[X+0xC3],0x89   (1115)     MOV     REG[X + USBUART_1_EP1MODE - 1], USB_MODE_STALL_DATA_EP | USB_MODE_ACK_OUT  ; Stall the endpoint
075A: 80 04    JMP   0x075F             (1116)     JMP     .done
                                        (1117) .in:
075C: 63 C3 8D MOV   REG[X+0xC3],0x8D   (1118)     MOV     REG[X + USBUART_1_EP1MODE - 1], USB_MODE_STALL_DATA_EP | USB_MODE_ACK_IN  ; Stall the endpoint
075F: 70 EF    AND   F,0xEF             
                                        (1119) .done:
                                        (1120) 	M8C_SetBank0
0761: 8E 6E    JMP   0x05D0             (1121)     JMP     USBUART_1_NoDataStageControlTransfer_Local_Std
                                        (1122) ENDIF
                                        (1123) ;-----------------------------------------------------------------------------
                                        (1124) ;  FUNCTION NAME: ConfigureEP
                                        (1125) ;
                                        (1126) ;  DESCRIPTION:   Configure an endpoint
                                        (1127) ;
                                        (1128) ;  ARGUMENTS:    A contains the endpoint direction
                                        (1129) ;                X contains the endpoint number
                                        (1130) ;
                                        (1131) ;  RETURNS:
                                        (1132) ;
                                        (1133) ;  SIDE EFFECTS:  The A REGISTER IS VOLATILE.  X REGISTER IS MAINTAINED!
                                        (1134) ;
                                        (1135) ;  THEORY of OPERATION or PROCEDURE:
                                        (1136) ;
                                        (1137) ;-----------------------------------------------------------------------------
                                        (1138) ConfigureEP:
0763: 39 7F    CMP   A,0x7F             (1139)     CMP     A, USB_DIR_UNUSED          ; Is this endpoint unused?
0765: B0 02    JNZ   0x0768             (1140)     JNZ     .enable                    ; Only enable it if it is used
0767: 7F       RET                      (1141)     RET                                ; Quick exit if this endpoint is unused
                                        (1142) 
                                        (1143) ; Jump here to enable an endpoint
                                        (1144) .enable:
0768: 08       PUSH  A                  (1145)     PUSH    A		                        ; Save the endpoint direction
0769: 5B       MOV   A,X                (1146)     MOV     A, X	                      ; We are using a JACC to dispatch to enable the interrupt
076A: 64       ASL   A                  (1147)     ASL     A		                        ;
076B: E0 01    JACC  0x076D             (1148)     JACC    .EP_INT_ENABLE             ;
                                        (1149) 
                                        (1150) 
                                        (1151) .EP_INT_ENABLE:
076D: 80 09    JMP   0x0777             (1152)     JMP     .EP0IntEnable              ; Enable EP0
076F: 80 0C    JMP   0x077C             (1153)     JMP     .EP1IntEnable              ; Enable EP1
0771: 80 0F    JMP   0x0781             (1154)     JMP     .EP2IntEnable              ; Enable EP2
0773: 80 12    JMP   0x0786             (1155)     JMP     .EP3IntEnable              ; Enable EP3
0775: 80 15    JMP   0x078B             (1156)     JMP     .EP4IntEnable              ; Enable EP4
0777: 43 DF 04 OR    REG[0xDF],0x4      
                                        (1157) 
                                        (1158) ; Jump here to enable EP0 Interrupts
                                        (1159) .EP0IntEnable:
                                        (1160)     M8C_EnableIntMask USBUART_1_INT_REG, USBUART_1_INT_EP0_MASK
                                        (1161) ;    JMP   .exit2
077A: 80 15    JMP   0x0790             (1162)     JMP   .cont
077C: 43 DF 08 OR    REG[0xDF],0x8      
                                        (1163) .EP1IntEnable:
                                        (1164)     M8C_EnableIntMask USBUART_1_INT_REG, USBUART_1_INT_EP1_MASK
077F: 80 10    JMP   0x0790             (1165)     JMP   .cont
0781: 43 DF 10 OR    REG[0xDF],0x10     
                                        (1166) .EP2IntEnable:
                                        (1167)     M8C_EnableIntMask USBUART_1_INT_REG, USBUART_1_INT_EP2_MASK
0784: 80 0B    JMP   0x0790             (1168)     JMP   .cont
0786: 43 DF 20 OR    REG[0xDF],0x20     
                                        (1169) .EP3IntEnable:
                                        (1170)     M8C_EnableIntMask USBUART_1_INT_REG, USBUART_1_INT_EP3_MASK
0789: 80 06    JMP   0x0790             (1171)     JMP   .cont
078B: 43 DF 40 OR    REG[0xDF],0x40     
                                        (1172) .EP4IntEnable:
                                        (1173)     M8C_EnableIntMask USBUART_1_INT_REG, USBUART_1_INT_EP4_MASK
078E: 80 01    JMP   0x0790             (1174) 	JMP   .cont
                                        (1175) ; Jump or flow here to continue configuring the endpoint
                                        (1176) .cont:
0790: 5B       MOV   A,X                (1177)     MOV     A, X	                      ; Get the endpoint number from X
0791: F3 FE    INDEX USBUART_1_USB_EP_BIT_LOOKUP(1178)     INDEX   USBUART_1_USB_EP_BIT_LOOKUP	 ; Find bit position for endpoint
0793: 31 FF    XOR   A,0xFF             (1179)     XOR     A, FFh
0795: 24 1D    AND   [0x1D],A           (1180)     AND     [USBUART_1_EPDataToggle], A ; Clear the data toggle for this endpoint
0797: 27 05 FE AND   [X+5],0xFE         (1181)     and     [X+USBUART_1_EndpointStatus], ~USB_ENDPOINT_STATUS_HALT    ; Clear any endpoint halts
079A: 71 10    OR    F,0x10             
                                        (1182) 
                                        (1183) ; if endpoint 0 set EP0MODE
                                        (1184) ; then exit
                                        (1185) ;    mov     A, X	                     ; Get the endpoint number from X
                                        (1186) ;    cmp     A, EP0	                   ; Is this endpoint zero?
                                        (1187) ;    jnz     .enable                   ; Only enable it if it is used
                                        (1188)     M8C_SetBank1
079C: 18       POP   A                  (1189)     POP   A                            ; Get the endpoint direction back
079D: 21 80    AND   A,0x80             (1190)     AND   A, USB_DIR_IN                ; Is it an IN endpoint?
079F: B0 09    JNZ   0x07A9             (1191)     JNZ   .in                          ; Jump on IN
                                        (1192) ; Flow here for an OUT Endpoint
07A1: 63 C3 09 MOV   REG[X+0xC3],0x9    (1193)     mov     reg[X+USBUART_1_EP1MODE-1], USB_MODE_ACK_OUT   ; ACK the endpoint
07A4: 56 22 00 MOV   [X+34],0x0         (1194)     MOV   [X+USBUART_1_EndpointAPIStatus], NO_EVENT_PENDING ; For the API
07A7: 80 07    JMP   0x07AF             (1195)     JMP   .exit1
                                        (1196) ; Jump here for an IN Endpoint
                                        (1197) .in:
07A9: 63 C3 0C MOV   REG[X+0xC3],0xC    (1198)     MOV   REG[X+USBUART_1_EP1MODE-1], USB_MODE_NAK_IN ; NAK the endpoint
07AC: 56 22 01 MOV   [X+34],0x1         (1199)     MOV   [X+USBUART_1_EndpointAPIStatus], EVENT_PENDING ; For the API
07AF: 70 EF    AND   F,0xEF             
                                        (1200) ; Jump or flow here to set the API event and exit
                                        (1201) .exit1:
                                        (1202) 	M8C_SetBank0
                                        (1203) .exit2:
07B1: 7F       RET                      (1204)     RET
                                        (1205) 
                                        (1206) 
                                        (1207) ; End of File USBUART_1_std.asm
FILE: lib\usbuart_1_drv.asm             (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME: USBUART_1_drv.asm
                                        (0004) ;;  Version: 1.40, Updated on 2011/3/29 at 14:31:18
                                        (0005) ;;  Generated by PSoC Designer 5.1.2110.0
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: USBUART control endpoint driver
                                        (0008) ;;
                                        (0009) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                        (0010) ;;        arguments and observe the associated "Registers are volatile" policy.
                                        (0011) ;;        This means it is the caller's responsibility to preserve any values
                                        (0012) ;;        in the X and A registers that are still needed after the API functions
                                        (0013) ;;        returns. For Large Memory Model devices it is also the caller's
                                        (0014) ;;        responsibility to preserve any value in the CUR_PP, IDX_PP, MVR_PP and
                                        (0015) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                        (0016) ;;        now, there is no guarantee that will remain the case in future releases.
                                        (0017) ;;-----------------------------------------------------------------------------
                                        (0018) ;;  Copyright (c) Cypress Semiconductor 2011. All Rights Reserved.
                                        (0019) ;;*****************************************************************************
                                        (0020) ;;*****************************************************************************
                                        (0021) 
                                        (0022) include "m8c.inc"
                                        (0023) include "memory.inc"
                                        (0024) include "USBUART_1_macros.inc"
                                        (0025) include "USBUART_1.inc"
                                        (0026) 
                                        (0027) ;-----------------------------------------------
                                        (0028) ;  Global Symbols
                                        (0029) ;-----------------------------------------------
                                        (0030) export  USBUART_1_EP0_ISR
                                        (0031) export _USBUART_1_EP0_ISR
                                        (0032) export  USBUART_1_InitControlRead
                                        (0033) export _USBUART_1_InitControlRead
                                        (0034) export  USBUART_1_InitControlWrite
                                        (0035) export _USBUART_1_InitControlWrite
                                        (0036) export  USBUART_1_InitNoDataStageControlTransfer
                                        (0037) export _USBUART_1_InitNoDataStageControlTransfer
                                        (0038) export  USBUART_1_NoDataStageControlTransfer
                                        (0039) 
                                        (0040) ;-----------------------------------------------
                                        (0041) ;  Macro Definitions
                                        (0042) ;-----------------------------------------------
                                        (0043) 
                                        (0044) ;-----------------------------------------------
                                        (0045) ;  Constant Definitions
                                        (0046) ;-----------------------------------------------
                                        (0047) 
                                        (0048) ;-----------------------------------------------
                                        (0049) ; Variable Allocation
                                        (0050) ;-----------------------------------------------
                                        (0051) AREA InterruptRAM (RAM,REL,CON)
                                        (0052) ;----------------------------------------------------------------------------
                                        (0053) ; Current Device
                                        (0054) ;----------------------------------------------------------------------------
                                        (0055) EXPORT USBUART_1_bCurrentDevice, _USBUART_1_bCurrentDevice
                                        (0056)  USBUART_1_bCurrentDevice:
                                        (0057) _USBUART_1_bCurrentDevice:              BLK   1    ;  Current Device
                                        (0058) ;----------------------------------------------------------------------------
                                        (0059) ; Current Configuration
                                        (0060) ;----------------------------------------------------------------------------
                                        (0061) EXPORT USBUART_1_Configuration, _USBUART_1_Configuration
                                        (0062)  USBUART_1_Configuration:
                                        (0063) _USBUART_1_Configuration:               BLK   1    ;  Current Configuration
                                        (0064) ;----------------------------------------------------------------------------
                                        (0065) ; Current Device Status
                                        (0066) ;----------------------------------------------------------------------------
                                        (0067) EXPORT USBUART_1_DeviceStatus, _USBUART_1_DeviceStatus
                                        (0068)  USBUART_1_DeviceStatus:
                                        (0069) _USBUART_1_DeviceStatus:                BLK   1    ;  Current Device Status
                                        (0070) ;----------------------------------------------------------------------------
                                        (0071) ; Interface Setting
                                        (0072) ;----------------------------------------------------------------------------
                                        (0073) EXPORT USBUART_1_InterfaceSetting, _USBUART_1_InterfaceSetting
                                        (0074)  USBUART_1_InterfaceSetting:
                                        (0075) _USBUART_1_InterfaceSetting:            BLK   2    ; Interface Setting
                                        (0076) ;----------------------------------------------------------------------------
                                        (0077) ; Endpoint Status--USB Status
                                        (0078) ;----------------------------------------------------------------------------
                                        (0079) EXPORT USBUART_1_EndpointStatus, _USBUART_1_EndpointStatus
                                        (0080)  USBUART_1_EndpointStatus:
                                        (0081) _USBUART_1_EndpointStatus:              BLK   USB_NUM_ENDPOINTS    ; Endpoint Status
                                        (0082) ;----------------------------------------------------------------------------
                                        (0083) ; Last Packet Size
                                        (0084) ;----------------------------------------------------------------------------
                                        (0085) EXPORT USBUART_1_LastSize 
                                        (0086)  USBUART_1_LastSize:                    BLK   1    ; Last Packet Size
                                        (0087) ;----------------------------------------------------------------------------
                                        (0088) ; Control Transfer State Machine
                                        (0089) ; State values for Control Write
                                        (0090) ; State values for Control Read
                                        (0091) ;----------------------------------------------------------------------------
                                        (0092) EXPORT USBUART_1_TransferType 
                                        (0093)  USBUART_1_TransferType:                BLK   1    ; Control Transfer State Machine
                                        (0094) ;----------------------------------------------------------------------------
                                        (0095) ; Control Transfer Intermediate Buffer--Shared among the requests
                                        (0096) ;----------------------------------------------------------------------------
                                        (0097) EXPORT USBUART_1_TransferBuffer 
                                        (0098)  USBUART_1_TransferBuffer:              BLK   8
                                        (0099) ;----------------------------------------------------------------------------
                                        (0100) ; Transfer Descriptor Data for Control Transfer
                                        (0101) ;  --The following data have the same format as the first 5 bytes of the TD_ENTRY
                                        (0102) ;----------------------------------------------------------------------------
                                        (0103) ; Control Transfer Data Source
                                        (0104) ;   USB_DS_ROM
                                        (0105) ;   USB_DS_RAM
                                        (0106) ;   USB_DS_RAM_AS_NEEDED
                                        (0107) ;----------------------------------------------------------------------------
                                        (0108) EXPORT USBUART_1_CurrentTD, _USBUART_1_CurrentTD
                                        (0109) _USBUART_1_CurrentTD:
                                        (0110)  USBUART_1_CurrentTD:
                                        (0111) EXPORT USBUART_1_DataSource, _USBUART_1_DataSource
                                        (0112) _USBUART_1_DataSource:
                                        (0113)  USBUART_1_DataSource:                  BLK   1
                                        (0114) ;----------------------------------------------------------------------------
                                        (0115) ; Control Transfer Data Size
                                        (0116) ;----------------------------------------------------------------------------
                                        (0117) EXPORT USBUART_1_TransferSize, _USBUART_1_TransferSize
                                        (0118) _USBUART_1_TransferSize:
                                        (0119)  USBUART_1_TransferSize:                BLK   2
                                        (0120) ;----------------------------------------------------------------------------
                                        (0121) ; Control Transfer Data Pointer
                                        (0122) ;   Source for Control Read
                                        (0123) ;   Destination for Control Write
                                        (0124) ;----------------------------------------------------------------------------
                                        (0125) EXPORT USBUART_1_DataPtr, _USBUART_1_DataPtr
                                        (0126) _USBUART_1_DataPtr: 
                                        (0127)  USBUART_1_DataPtr:                     BLK   2
                                        (0128) ;----------------------------------------------------------------------------
                                        (0129) ; Transfer Completion Notification
                                        (0130) ;----------------------------------------------------------------------------
                                        (0131) EXPORT USBUART_1_StatusBlockPtr, _USBUART_1_StatusBlockPtr
                                        (0132) _USBUART_1_StatusBlockPtr: 
                                        (0133)  USBUART_1_StatusBlockPtr:              BLK   2
                                        (0134) 
                                        (0135) ;----------------------------------------------------------------------------
                                        (0136) ; Control Transfer _TransferByteCount (Actually transferred)
                                        (0137) ;----------------------------------------------------------------------------
                                        (0138)  USBUART_1_TransferByteCount:              BLK   2
                                        (0139) 
                                        (0140) ;----------------------------------------------------------------------------
                                        (0141) ; Control Endpoint Data toggle
                                        (0142) EXPORT USBUART_1_EPDataToggle, _USBUART_1_EPDataToggle
                                        (0143)  _USBUART_1_EPDataToggle:
                                        (0144)  USBUART_1_EPDataToggle:
                                        (0145)  USBUART_1_EP0DataToggle:               BLK   1
                                        (0146) ;----------------------------------------------------------------------------
                                        (0147) ; Control Endpoint Data Pending Flag
                                        (0148) EXPORT USBUART_1_fDataPending
                                        (0149)  USBUART_1_fDataPending:                BLK   1
                                        (0150) ;----------------------------------------------------------------------------
                                        (0151) ; Control Endpoint Data Pending Flag
                                        (0152) ;EXPORT USBUART_1_PendingData
                                        (0153) ;  USBUART_1_PendingData:               BLK   1
                                        (0154) ;----------------------------------------------------------------------------
                                        (0155) ; Temporary Data registers
                                        (0156) EXPORT USBUART_1_t2, USBUART_1_t1, USBUART_1_t0
                                        (0157)  USBUART_1_t2:                          BLK   1    ; Temporary shared by the UM
                                        (0158)  USBUART_1_t1:                          BLK   1    ; Temporary shared by the UM
                                        (0159)  USBUART_1_t0:                          BLK   1    ; Temporary shared by the UM
                                        (0160) 
                                        (0161) ;EXPORT USBUART_1_IntState
                                        (0162) ; USBUART_1_IntState:                   BLK  1
                                        (0163) ;EXPORT USBUART_1_StackPointer
                                        (0164) ; USBUART_1_StackPointer:               BLK  1
                                        (0165) ;EXPORT USBUART_1_TempMode
                                        (0166) ; USBUART_1_TempMode:                   BLK 1
                                        (0167) ;----------------------------------------------------------------------------
                                        (0168) ; Endpoint Transfer--API Status
                                        (0169) ;----------------------------------------------------------------------------
                                        (0170) EXPORT USBUART_1_EndpointAPIStatus, _USBUART_1_EndpointAPIStatus
                                        (0171)  USBUART_1_EndpointAPIStatus:
                                        (0172) _USBUART_1_EndpointAPIStatus:           BLK   USB_NUM_ENDPOINTS    ; Endpoint Status
                                        (0173) 
                                        (0174) AREA UserModules (ROM, REL)
                                        (0175) ;-----------------------------------------------------------------------------
                                        (0176) ;  FUNCTION NAME: USBUART_1_EP0_ISR
                                        (0177) 
                                        (0178) ;
                                        (0179) ;  DESCRIPTION:   The EPO ISR serves the control endpoint interrupts and
                                        (0180) ;                 dispatches all SETUP, IN, and OUT transfers to the proper
                                        (0181) ;                 dispatch routines for all supported USB requests.
                                        (0182) ;
                                        (0183) ;-----------------------------------------------------------------------------
                                        (0184) ;
                                        (0185) ;  ARGUMENTS:   n/a
                                        (0186) ;
                                        (0187) ;  RETURNS:     n/a
                                        (0188) ;
                                        (0189) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0190) ;
                                        (0191) ;  THEORY of OPERATION or PROCEDURE:
                                        (0192) ;
                                        (0193) ;-----------------------------------------------------------------------------
                                        (0194)  USBUART_1_EP0_ISR:
                                        (0195) _USBUART_1_EP0_ISR:
07B2: 08       PUSH  A                  (0196)     PUSH A
07B3: 10       PUSH  X                  (0197)     PUSH X
07B4: 5D D5    MOV   A,REG[0xD5]        
07B6: 08       PUSH  A                  
07B7: 5D D4    MOV   A,REG[0xD4]        
07B9: 08       PUSH  A                  
07BA: 62 D5 00 MOV   REG[0xD5],0x0      
07BD: 62 D4 00 MOV   REG[0xD4],0x0      
                                        (0198)     REG_PRESERVE MVW_PP
                                        (0199)     REG_PRESERVE MVR_PP
                                        (0200) 
                                        (0201)     RAM_SETPAGE_MVW 0
                                        (0202)     RAM_SETPAGE_MVR 0
                                        (0203) 
                                        (0204)     ; Dispatch to setup/in/out handlers
07C0: 5D 56    MOV   A,REG[0x56]        (0205)     MOV  A, reg[USBUART_1_EP0MODE]      ; Get the mode reg
                                        (0206) 
07C2: 5C       MOV   X,A                (0207)     MOV     X, A ; store for later
                                        (0208)     ; Check EP0_CR for the following cases:
                                        (0209)     ; bit 7 is set but ack is not set or mode is not 1 => invalid setup
                                        (0210)     ; bit 7 is not set, bit 5 or 6 is set, but bit 4 is not set => invalid in/out
07C3: 21 9F    AND   A,0x9F             (0211)     AND     A, 9Fh
07C5: 39 91    CMP   A,0x91             (0212)     CMP     A, 91h
07C7: A0 43    JZ    0x080B             (0213)     JZ      USBUART_1_EP0_Setup
                                        (0214)     ; Check if setup bit is set--if so then invalid EP0_CR reg read so exit
07C9: 21 80    AND   A,0x80             (0215)     AND     A, 80h
                                        (0216)     ; Getting here means there is an invalid setup; exit without modifying the mode
07CB: B0 36    JNZ   0x0802             (0217)     JNZ     USBUART_1_EP0_ISR_EXIT
                                        (0218)     ; Getting here means the setup bit is not set, now check in/out
07CD: 5B       MOV   A,X                (0219)     MOV     A, X   ; restore EP0_CR reg as read
07CE: 21 70    AND   A,0x70             (0220)     AND     A, 70h
07D0: 39 50    CMP   A,0x50             (0221)     CMP     A, 50h
07D2: A0 62    JZ    0x0835             (0222)     JZ      USBUART_1_EP0_IN
07D4: 39 30    CMP   A,0x30             (0223)     CMP     A, 30h
07D6: A0 6C    JZ    0x0843             (0224)     JZ      USBUART_1_EP0_OUT
                                        (0225)     ; Getting here means there is an invalid in/out; exit without modifying the mode
07D8: 80 29    JMP   0x0802             (0226)     JMP     USBUART_1_EP0_ISR_EXIT  
                                        (0227) 
                                        (0228) ; ISR Exit Point to update the mode register
                                        (0229) ;   mode and count have been pushed onto the stack
                                        (0230) EXPORT USBUART_1_EP0_UPD_MODE_EXIT
                                        (0231) USBUART_1_EP0_UPD_MODE_EXIT:
07DA: 53 21    MOV   [0x21],A           (0232)     MOV     [USBUART_1_t0], A                    ; store EP0_CNT reg value for later
07DC: 5D 56    MOV   A,REG[0x56]        (0233)     MOV     A, REG[USBUART_1_EP0MODE]            ; unlock registers  
07DE: 21 80    AND   A,0x80             (0234)     AND     A, 80h                                      ; Check if SETUP bit is set
07E0: B0 21    JNZ   0x0802             (0235)     JNZ     USBUART_1_EP0_ISR_EXIT                ;          then EXIT from the ISR	
07E2: 51 21    MOV   A,[0x21]           (0236)     MOV     A, [USBUART_1_t0]                    ; restore EP0_CNT reg value
07E4: 60 57    MOV   REG[0x57],A        (0237)     MOV     REG[USBUART_1_EP0CNT], A             ; Update the count register
07E6: 5D 57    MOV   A,REG[0x57]        (0238)     MOV     A, REG[USBUART_1_EP0CNT]             ; writing check
07E8: 3A 21    CMP   A,[0x21]           (0239)     CMP     A, [USBUART_1_t0]                    ; if writing was not succesful,
07EA: B0 17    JNZ   0x0802             (0240)     JNZ     USBUART_1_EP0_ISR_EXIT               ;         then abort the ISR    
                                        (0241) 
07EC: 5A 21    MOV   [0x21],X           (0242)     MOV     [USBUART_1_t0], X                     ; store EP0_MODE reg value for later
                                        (0243) .ReWriteMODE:
07EE: 5D 56    MOV   A,REG[0x56]        (0244)     MOV     A, REG[USBUART_1_EP0MODE]             ; unblock registers    
07F0: 21 80    AND   A,0x80             (0245)     AND     A, 80h                                      ; Check if SETUP bit is set
07F2: B0 0F    JNZ   0x0802             (0246)     JNZ     USBUART_1_EP0_ISR_EXIT                ;          then EXIT from the ISR
                                        (0247)     
07F4: 51 21    MOV   A,[0x21]           (0248)     MOV     A, [USBUART_1_t0]                     ; restore the new MODE
07F6: 60 56    MOV   REG[0x56],A        (0249)     MOV     REG[USBUART_1_EP0MODE], A             ; Update the mode regiter
                                        (0250)     
07F8: 5D 56    MOV   A,REG[0x56]        (0251)     MOV     A, REG[USBUART_1_EP0MODE]             ; writing check
07FA: 21 0F    AND   A,0xF              (0252)     AND     A,  0Fh                                     ; clear 7-4 bits
07FC: 3A 21    CMP   A,[0x21]           (0253)     CMP     A, [USBUART_1_t0]                     ; if writing was succesful,
07FE: A0 03    JZ    0x0802             (0254)     JZ      USBUART_1_EP0_ISR_EXIT                ;          then EXIT from the ISR
                                        (0255)                                                          ; if writing was not succesful,
0800: 8F ED    JMP   0x07EE             (0256)     JMP      .ReWriteMODE                                 ;           then repeat write operation   
0802: 18       POP   A                  
0803: 60 D4    MOV   REG[0xD4],A        
0805: 18       POP   A                  
0806: 60 D5    MOV   REG[0xD5],A        
                                        (0257) 
                                        (0258) ; Common Exit Point
                                        (0259) USBUART_1_EP0_ISR_EXIT:
                                        (0260)     REG_RESTORE MVR_PP
                                        (0261)     REG_RESTORE MVW_PP
0808: 20       POP   X                  (0262)     POP  X                              ;
0809: 18       POP   A                  (0263)     POP  A                              ; Restore Context
080A: 7E       RETI                     (0264)     RETI
                                        (0265) 
                                        (0266) 
                                        (0267) ;-----------------------------------------------------------------------------
                                        (0268) ;  FUNCTION NAME: USBUART_1_EP0_Setup
                                        (0269) ;
                                        (0270) ;  DESCRIPTION:   Dispatch a USB SETUP
                                        (0271) ;
                                        (0272) ;-----------------------------------------------------------------------------
                                        (0273)  USBUART_1_EP0_Setup:
                                        (0274) _USBUART_1_EP0_Setup:
                                        (0275) ; Check the byte count and validity.  All SETUP are 8 bytes and 0 toggle
080B: 5D 56    MOV   A,REG[0x56]        (0276)     MOV     A, REG[USBUART_1_EP0MODE]    ; unlock registers
080D: 60 56    MOV   REG[0x56],A        (0277)     MOV     REG[USBUART_1_EP0MODE], A ; clear setup bit 
080F: 5D 56    MOV   A,REG[0x56]        (0278)     MOV     A, REG[USBUART_1_EP0MODE]    ; (re)read register
0811: 21 80    AND   A,0x80             (0279)     AND     A, 80h                              ; Check if SETUP bit is set
0813: BF EE    JNZ   0x0802             (0280)     JNZ     USBUART_1_EP0_ISR_EXIT       ; if SETUP bit set -> exit without modifying the mode    
0815: 08       PUSH  A                  (0281)     PUSH    A                          ; Save the mode register
0816: 50 02    MOV   A,0x2              (0282)     MOV     A, USB_XFER_PREMATURE      ; Return a Premature Completion?
0818: 91 F3    CALL  0x0A0D             (0283)     CALL    USBUART_1_UpdateStatusBlock
081A: 18       POP   A                  (0284)     POP     A                          ; Restore the mode register
081B: 5D 57    MOV   A,REG[0x57]        (0285)     MOV    A, REG[USBUART_1_EP0CNT]          ; Get the count reg
081D: 39 4A    CMP   A,0x4A             (0286)     CMP    A, (USB_CNT_VALID | 0x0A)
081F: A0 03    JZ    0x0823             (0287)     JZ      .dispatch
                                        (0288) 
0821: 82 5C    JMP   0x0A7E             (0289)     JMP    USBUART_1_Not_Supported_Local_Drv
                                        (0290) 
                                        (0291) 
                                        (0292) ;-----------------------------------------------------------------------------
                                        (0293) ; Jump here to dispatch the request
                                        (0294) ; The SETUP request is encoded in [bmRequestType]. Among the 8 bits in [bmRequestType], only bits
                                        (0295) ; 7,6,5,1,0 determine what the request is. Bits [2:4] are default to zero. The below code
                                        (0296) ; re-organizes [bmRequestType] to the following format:
                                        (0297) ; ( Zero, Zero, Bit7, Bit6, Bit5, Bit1, Bit0, Zero ), and depending on the value of this
                                        (0298) ; "re-organization", the firmware will jump to an appropriate table to handle the request.
                                        (0299) ;-----------------------------------------------------------------------------
                                        (0300) .dispatch:
0823: 5D 58    MOV   A,REG[0x58]        (0301)     MOV     A, REG[USBUART_1_EP0DATA+bmRequestType]   ; Get bmRequestType
0825: 21 E3    AND   A,0xE3             (0302)     AND     A, E3h                           ; clear bits 4-3-2, these unused for our purposes
0827: 08       PUSH  A                  (0303)     PUSH    A                                ; store value on the stack
0828: 67       ASR   A                  (0304)     ASR     A                                ; move bits 7-6-5 into 4-3-2's place
0829: 67       ASR   A                  (0305)     ASR     A                                ; "asr" instruction shift all bits one place to the right.
082A: 67       ASR   A                  (0306)     ASR     A                                ; Bit7 remains the same.
082B: 53 1F    MOV   [0x1F],A           (0307)     MOV     [USBUART_1_t2], A                ; store shifted value
082D: 18       POP   A                  (0308)     POP     A                                ; get original value
082E: 2A 1F    OR    A,[0x1F]           (0309)     OR      A, [USBUART_1_t2]                ; or the two to get the 5-bit field
0830: 21 1F    AND   A,0x1F             (0310)     AND     A, 1Fh                           ; clear bits 7-6-5 (asr wraps bit7)
                                        (0311)                                              ; Bit0 is loaded with a Zero. This results in multiplying
                                        (0312)                                              ; the accumulator by 2, and the reason to multiply it by 2
                                        (0313)                                              ; is that each "jmp" instruction in the tables is two bytes long.
                                        (0314) 
0832: 7D 0A 74 LJMP  USBUART_1_bmRequestType_Dispatch(0315)     LJMP USBUART_1_bmRequestType_Dispatch
                                        (0316) 
                                        (0317) 
                                        (0318) ;-----------------------------------------------------------------------------
                                        (0319) ;  FUNCTION NAME: USBUART_1_EP0_IN
                                        (0320) ;
                                        (0321) ;  DESCRIPTION: Handles an IN request.  Depending on the state of the
                                        (0322) ;               enumeration sequence it decides what to do next
                                        (0323) ;
                                        (0324) ;-----------------------------------------------------------------------------
                                        (0325)  USBUART_1_EP0_IN:
                                        (0326) _USBUART_1_EP0_IN:
0835: 5D 56    MOV   A,REG[0x56]        (0327)     MOV     A, REG[USBUART_1_EP0MODE]    ; unlock registers
                                        (0328) ;    MOV     REG[USBUART_1_EP0MODE], A ; clear setup bit 
                                        (0329) ;    MOV     A, REG[USBUART_1_EP0MODE]    ; (re)read register
                                        (0330) ;    AND     A, 80h                              ; Check if SETUP bit is set
                                        (0331) ;    JNZ     USBUART_1_EP0_ISR_EXIT       ; if SETUP bit set -> exit without modifying the mode    
0837: 51 0B    MOV   A,[0xB]            (0332)     MOV  A, [USBUART_1_TransferType]
                                        (0333) USBUART_1_ControlInDispatch:
0839: E0 01    JACC  0x083B             (0334)     JACC    USBUART_1_ControlInDispatchTable
                                        (0335) USBUART_1_ControlInDispatchTable:
083B: 82 42    JMP   0x0A7E             (0336)     JMP     USBUART_1_Not_Supported_Local_Drv  ; USB_TRANS_STATE_IDLE
083D: 80 39    JMP   0x0877             (0337)     JMP     USBUART_1_ControlReadDataStage     ; USB_TRANS_STATE_CONTROL_READ
083F: 80 B9    JMP   0x08F9             (0338)     JMP     USBUART_1_ControlWriteStatusStage  ; USB_TRANS_STATE_CONTROL_WRITE
0841: 80 C4    JMP   0x0906             (0339)     JMP     USBUART_1_NoDataControlStatusStage ; USB_TRANS_STATE_NO_DATA_CONTROL
                                        (0340) 
                                        (0341) 
                                        (0342) ;-----------------------------------------------------------------------------
                                        (0343) ;  FUNCTION NAME: USBUART_1_EP0_OUT
                                        (0344) ;
                                        (0345) ;  DESCRIPTION: HANDles an OUT request.  Depending on the state of the
                                        (0346) ;               enumeration sequence it decides what to do next
                                        (0347) ;
                                        (0348) ;-----------------------------------------------------------------------------
                                        (0349)  USBUART_1_EP0_OUT:
                                        (0350) _USBUART_1_EP0_OUT:
0843: 5D 56    MOV   A,REG[0x56]        (0351)     MOV     A, REG[USBUART_1_EP0MODE]    ; unlock registers
                                        (0352) ;    MOV     REG[USBUART_1_EP0MODE], A ; clear setup bit 
                                        (0353) ;    MOV     A, REG[USBUART_1_EP0MODE]    ; (re)read register
                                        (0354) ;    AND     A, 80h                              ; Check if SETUP bit is set
                                        (0355) ;    JNZ     USBUART_1_EP0_ISR_EXIT       ; if SETUP bit set -> exit without modifying the mode    
0845: 51 0B    MOV   A,[0xB]            (0356)     MOV     A, [USBUART_1_TransferType]
0847: E0 01    JACC  0x0849             (0357)     JACC    USBUART_1_ControlOutDispatchTable
                                        (0358) USBUART_1_ControlOutDispatchTable:
0849: 82 34    JMP   0x0A7E             (0359)     JMP     USBUART_1_Not_Supported_Local_Drv  ; USB_TRANS_STATE_IDLE
084B: 80 2D    JMP   0x0879             (0360)     JMP     USBUART_1_ControlReadStatusStage   ; USB_TRANS_STATE_CONTROL_READ
084D: 80 5E    JMP   0x08AC             (0361)     JMP     USBUART_1_ControlWriteDataStage    ; USB_TRANS_STATE_CONTROL_WRITE
084F: 80 D0    JMP   0x0920             (0362)     JMP     USBUART_1_NoDataControlError       ; USB_TRANS_STATE_NO_DATA_CONTROL
                                        (0363) 
                                        (0364) ;-----------------------------------------------------------------------------
                                        (0365) ;  FUNCTION NAME: USBUART_1_InitControlRead
                                        (0366) ;
                                        (0367) ;  DESCRIPTION:   This routine initializes a control read.  It must be JUMPed to,
                                        (0368) ;                 not called.  It assumes a transfer descriptor has been loaded
                                        (0369) ;                 into the driver USBUART_1_CurrentTD data structure.
                                        (0370) ;
                                        (0371) ;-----------------------------------------------------------------------------
                                        (0372)  USBUART_1_InitControlRead:
                                        (0373) _USBUART_1_InitControlRead:
0851: 53 0A    MOV   [0xA],A            (0374)     MOV     [USBUART_1_LastSize], A    ; Save the packet size?
0853: 91 CE    CALL  0x0A23             (0375)     CALL    USBUART_1_InitializeStatusBlock
0855: 55 0B 02 MOV   [0xB],0x2          (0376)     MOV     [USBUART_1_TransferType], USB_TRANS_STATE_CONTROL_READ
                                        (0377) 
                                        (0378)     ; Check the transfer size against the request size
0858: 5D 5F    MOV   A,REG[0x5F]        (0379)     MOV    A, REG[USBUART_1_EP0DATA+wLengthHi] ; MSB of wLength
085A: 3A 15    CMP   A,[0x15]           (0380)     CMP    A, [USBUART_1_TransferSize]
085C: B0 07    JNZ   0x0864             (0381)     JNZ    .L1
                                        (0382) 
085E: 5D 5E    MOV   A,REG[0x5E]        (0383)     MOV    A, REG[USBUART_1_EP0DATA+wLengthLo] ; LSB of wLength
0860: 3A 16    CMP   A,[0x16]           (0384)     CMP    A, [USBUART_1_TransferSize+1]
0862: A0 09    JZ    0x086C             (0385)     JZ     .L9
                                        (0386) .L1:
0864: D0 07    JNC   0x086C             (0387)     JNC    .L9
                                        (0388) ;
0866: 53 16    MOV   [0x16],A           (0389)     MOV    [USBUART_1_TransferSize+1], A ;
0868: 5D 5F    MOV   A,REG[0x5F]        (0390)     MOV    A, REG[USBUART_1_EP0DATA+wLengthHi] ;
086A: 53 15    MOV   [0x15],A           (0391)     MOV    [USBUART_1_TransferSize], A ;
                                        (0392) .L9:
086C: 55 1B 00 MOV   [0x1B],0x0         (0393)     MOV    [USBUART_1_TransferByteCount], 0 ;
086F: 55 1C 00 MOV   [0x1C],0x0         (0394)     MOV    [USBUART_1_TransferByteCount+1], 0 ;
                                        (0395) 
0872: 2E 1D 01 OR    [0x1D],0x1         (0396)     OR     [USBUART_1_EP0DataToggle], 1 ; setup EP0 data toggle
0875: 80 B4    JMP   0x092A             (0397)     JMP    USBUART_1_LoadEndpoint      ;
                                        (0398) ;-----------------------------------------------------------------------------
                                        (0399) ;  FUNCTION NAME: USBUART_1_ControlReadDataStage
                                        (0400) ;
                                        (0401) ;  DESCRIPTION:   This routine processes the data stage of a control read.  It
                                        (0402) ;                 must be JUMPed to, not called.  It assumes a transfer descriptor
                                        (0403) ;                 has been loaded into the driver USBUART_1_CurrentTD
                                        (0404) ;                 data structure.
                                        (0405) ;
                                        (0406) ;-----------------------------------------------------------------------------
                                        (0407)  USBUART_1_ControlReadDataStage:
0877: 80 B2    JMP   0x092A             (0408)     JMP     USBUART_1_LoadEndpoint
                                        (0409) 
                                        (0410) ;-----------------------------------------------------------------------------
                                        (0411) ;  FUNCTION NAME: USBUART_1_ControlReadStatusStage
                                        (0412) ;
                                        (0413) ;  DESCRIPTION:   This routine processes the status stage of a control read.  It
                                        (0414) ;                 must be JUMPed to, not called.  It handles short or 0 packet
                                        (0415) ;                 It assumes a transfer descriptor has been loaded into the
                                        (0416) ;                 driver USBUART_1_CurrentTD data structure.
                                        (0417) ;
                                        (0418) ;-----------------------------------------------------------------------------
                                        (0419)  USBUART_1_ControlReadStatusStage:
0879: 51 0A    MOV   A,[0xA]            (0420)     MOV    A, [USBUART_1_LastSize]     ; Get the number of bytes from the last transfer
087B: 04 1C    ADD   [0x1C],A           (0421)     ADD    [USBUART_1_TransferByteCount + 1], A ; Update the transfer byte count
087D: 0E 1B 00 ADC   [0x1B],0x0         (0422)     ADC    [USBUART_1_TransferByteCount], 0 ;
0880: 50 01    MOV   A,0x1              (0423)     MOV    A, USB_XFER_STATUS_ACK      ; Return a Status ACK Completion
0882: 91 89    CALL  0x0A0D             (0424)     CALL   USBUART_1_UpdateStatusBlock
0884: 55 0B 00 MOV   [0xB],0x0          (0425)     MOV    [USBUART_1_TransferType], USB_TRANS_STATE_IDLE
0887: 50 00    MOV   A,0x0              (0426)     MOV    A, 0                        ; Count Register
0889: 57 03    MOV   X,0x3              (0427)     MOV    X, USB_MODE_STALL_IN_OUT
088B: 8F 4E    JMP   USBUART_1_EP0_UPD_MODE_EXIT(0428)     JMP    USBUART_1_EP0_UPD_MODE_EXIT
                                        (0429) ;-----------------------------------------------------------------------------
                                        (0430) ;  FUNCTION NAME: USBUART_1_NoDataStageControlTransfer
                                        (0431) ;                 USBUART_1_InitNoDataStageControlTransfer
                                        (0432) ;
                                        (0433) ;  DESCRIPTION:   This routine processes the status stage of a no data control
                                        (0434) ;                 write.  It must be JUMPed to, not called.
                                        (0435) ;
                                        (0436) ;-----------------------------------------------------------------------------
                                        (0437)  USBUART_1_NoDataStageControlTransfer:
                                        (0438) _USBUART_1_InitNoDataStageControlTransfer:
                                        (0439)  USBUART_1_InitNoDataStageControlTransfer:
088D: 91 94    CALL  0x0A23             (0440)     CALL    USBUART_1_InitializeStatusBlock
                                        (0441) 
088F: 55 0B 06 MOV   [0xB],0x6          (0442)     MOV    [USBUART_1_TransferType], USB_TRANS_STATE_NO_DATA_CONTROL
                                        (0443) 
0892: 50 00    MOV   A,0x0              (0444)     MOV    A, 0                        ; Count Register
0894: 57 06    MOV   X,0x6              (0445)     MOV    X, USB_MODE_STATUS_IN_ONLY
0896: 8F 43    JMP   USBUART_1_EP0_UPD_MODE_EXIT(0446)     JMP    USBUART_1_EP0_UPD_MODE_EXIT
                                        (0447) 
                                        (0448) 
                                        (0449) ;-----------------------------------------------------------------------------
                                        (0450) ;  FUNCTION NAME: USBUART_1_InitControlWrite
                                        (0451) ;
                                        (0452) ;  DESCRIPTION:   This routine initializes control write.  It must be JUMPed
                                        (0453) ;                 to, not called.  It assumes a transfer descriptor has been loaded
                                        (0454) ;                 into the driver USBUART_1_CurrentTD data structure.
                                        (0455) ;
                                        (0456) ;-----------------------------------------------------------------------------
                                        (0457)  USBUART_1_InitControlWrite:
                                        (0458) _USBUART_1_InitControlWrite:
0898: 51 14    MOV   A,[0x14]           (0459)     MOV     A, [USBUART_1_DataSource]  ; Need to make sure the destination is not ROM
089A: 39 00    CMP   A,0x0              (0460)     CMP     A, USB_DS_ROM
089C: A1 E1    JZ    0x0A7E             (0461)     JZ      USBUART_1_Not_Supported_Local_Drv
                                        (0462) 
089E: 91 83    CALL  0x0A23             (0463)     CALL    USBUART_1_InitializeStatusBlock
                                        (0464) 
08A0: 55 0B 04 MOV   [0xB],0x4          (0465)     MOV    [USBUART_1_TransferType], USB_TRANS_STATE_CONTROL_WRITE
                                        (0466) 
08A3: 2E 1D 01 OR    [0x1D],0x1         (0467)     OR     [USBUART_1_EP0DataToggle], 1 ; setup EP0 data toggle
                                        (0468) 
08A6: 50 00    MOV   A,0x0              (0469)     MOV    A, 0                        ; Count Register
08A8: 57 0B    MOV   X,0xB              (0470)     MOV    X, USB_MODE_ACK_OUT_STATUS_IN
08AA: 8F 2F    JMP   USBUART_1_EP0_UPD_MODE_EXIT(0471)     JMP    USBUART_1_EP0_UPD_MODE_EXIT
                                        (0472) 
                                        (0473) 
                                        (0474) ;-----------------------------------------------------------------------------
                                        (0475) ;  FUNCTION NAME: USBUART_1_ControlWriteDataStage
                                        (0476) ;
                                        (0477) ;  DESCRIPTION:   This routine processes the data stage of a control
                                        (0478) ;                 write.  It must be JUMPed to, not called.  It assumes a
                                        (0479) ;                 transfer descriptor has been loaded into the driver
                                        (0480) ;                 USBUART_1_CurrentTD data structure.
                                        (0481) ;
                                        (0482) ;-----------------------------------------------------------------------------
                                        (0483)  USBUART_1_ControlWriteDataStage:
08AC: 36 1D 01 XOR   [0x1D],0x1         (0484)     XOR    [USBUART_1_EP0DataToggle], 1  ; Update data toggle
                                        (0485) 
08AF: 5D 57    MOV   A,REG[0x57]        (0486)     MOV    A,REG[USBUART_1_EP0CNT]     ; Get the count
                                        (0487) 
08B1: 21 0F    AND   A,0xF              (0488)     AND     A, 0x0F
08B3: 11 02    SUB   A,0x2              (0489)     SUB     A, 2                       ; Count include the two byte checksum
                                        (0490) 
08B5: 53 1F    MOV   [0x1F],A           (0491)     MOV     [USBUART_1_t2], A          ; Assume we have room to receive the whole packet
                                        (0492) 
08B7: 50 00    MOV   A,0x0              (0493)     MOV     A, 0
08B9: 3A 15    CMP   A,[0x15]           (0494)     CMP     A, [USBUART_1_TransferSize]  ; If the MSB has anything just use the count
08BB: B0 07    JNZ   0x08C3             (0495)     JNZ     .L1
                                        (0496) 
08BD: 51 1F    MOV   A,[0x1F]           (0497)     MOV     A, [USBUART_1_t2]
08BF: 3A 16    CMP   A,[0x16]           (0498)     CMP     A, [USBUART_1_TransferSize+1]  ;
08C1: A0 06    JZ    0x08C8             (0499)     JZ      .L6
                                        (0500) .L1:
08C3: C0 04    JC    0x08C8             (0501)     JC      .L6
08C5: 5F 1F 16 MOV   [0x1F],[0x16]      (0502)     MOV     [USBUART_1_t2], [USBUART_1_TransferSize+1]
                                        (0503) 
                                        (0504) .L6:
08C8: 51 1F    MOV   A,[0x1F]           (0505)     MOV     A, [USBUART_1_t2]
08CA: 14 16    SUB   [0x16],A           (0506)     SUB     [USBUART_1_TransferSize+1],A   ; Update the bytes remaining
08CC: 1E 15 00 SBB   [0x15],0x0         (0507)     SBB     [USBUART_1_TransferSize], 0  ;
                                        (0508) 
08CF: 04 1C    ADD   [0x1C],A           (0509)     ADD     [USBUART_1_TransferByteCount + 1], A ; Update the transfer byte count
08D1: 0E 1B 00 ADC   [0x1B],0x0         (0510)     ADC     [USBUART_1_TransferByteCount], 0 ;
                                        (0511) 
08D4: 57 00    MOV   X,0x0              (0512)     MOV     X,0                        ; Start the index at 0
08D6: 5D D5    MOV   A,REG[0xD5]        
08D8: 08       PUSH  A                  
                                        (0513) 
                                        (0514) IF SYSTEM_LARGE_MEMORY_MODEL
                                        (0515)     REG_PRESERVE MVW_PP
08D9: 51 17    MOV   A,[0x17]           (0516)     mov     A, [USBUART_1_DataPtr]  ; set proper page for mvi command
08DB: 60 D5    MOV   REG[0xD5],A        (0517)     mov     reg[MVW_PP], A
                                        (0518) ENDIF
                                        (0519) .RAM_COPY:
08DD: 5E 58    MOV   A,REG[X+0x58]      (0520)     MOV     A, REG[X+USBUART_1_EP0DATA]  ; Get the data
08DF: 3F 18    MVI   [0x18],A           (0521)     MVI     [USBUART_1_DataPtr+1], A   ; Store the data, bump the destination
                                        (0522) 
08E1: 75       INC   X                  (0523)     INC     X                          ; Bump the destination offset
08E2: 5B       MOV   A,X                (0524)     MOV     A,X                        ; Are we done?
08E3: 3A 1F    CMP   A,[0x1F]           (0525)     CMP     A, [USBUART_1_t2]
08E5: CF F7    JC    0x08DD             (0526)     JC      .RAM_COPY                  ; Not done
08E7: 18       POP   A                  
08E8: 60 D5    MOV   REG[0xD5],A        
                                        (0527) 
                                        (0528) IF SYSTEM_LARGE_MEMORY_MODEL
                                        (0529)     REG_RESTORE MVW_PP
                                        (0530) ENDIF
08EA: 50 00    MOV   A,0x0              (0531)     MOV    A, 0                        ; Count Register
08EC: 57 0B    MOV   X,0xB              (0532)     MOV    X, USB_MODE_ACK_OUT_STATUS_IN
08EE: 8E EB    JMP   USBUART_1_EP0_UPD_MODE_EXIT(0533)     JMP    USBUART_1_EP0_UPD_MODE_EXIT
                                        (0534) 
                                        (0535) ; Jump here on data toggle error
                                        (0536) .error:
08F0: 55 0B 00 MOV   [0xB],0x0          (0537)     MOV    [USBUART_1_TransferType], USB_TRANS_STATE_IDLE  ; This simply aborts the transfer
08F3: 50 00    MOV   A,0x0              (0538)     MOV    A, 0                        ; Count Register
08F5: 57 03    MOV   X,0x3              (0539)     MOV    X, USB_MODE_STALL_IN_OUT
08F7: 8E E2    JMP   USBUART_1_EP0_UPD_MODE_EXIT(0540)     JMP    USBUART_1_EP0_UPD_MODE_EXIT
                                        (0541) 
                                        (0542) 
                                        (0543) ;-----------------------------------------------------------------------------
                                        (0544) ;  FUNCTION NAME: USBUART_1_ControlWriteStatusStage
                                        (0545) ;
                                        (0546) ;  DESCRIPTION:   This routine processes the status stage of a control
                                        (0547) ;                 write.  It must be JUMPed to, not called.  It assumes a
                                        (0548) ;                 transfer descriptor has been loaded into the driver
                                        (0549) ;                 USBUART_1_CurrentTD data structure.
                                        (0550) ;
                                        (0551) ;-----------------------------------------------------------------------------
                                        (0552)  USBUART_1_ControlWriteStatusStage:
08F9: 50 01    MOV   A,0x1              (0553)     MOV    A, USB_XFER_STATUS_ACK      ; Return a Status ACK Completion
08FB: 91 10    CALL  0x0A0D             (0554)     CALL   USBUART_1_UpdateStatusBlock
08FD: 55 0B 00 MOV   [0xB],0x0          (0555)     MOV    [USBUART_1_TransferType], USB_TRANS_STATE_IDLE  ; The packet is done
0900: 50 00    MOV   A,0x0              (0556)     MOV    A, 0                        ; Count Register
0902: 57 03    MOV   X,0x3              (0557)     MOV    X, USB_MODE_STALL_IN_OUT
0904: 8E D5    JMP   USBUART_1_EP0_UPD_MODE_EXIT(0558)     JMP    USBUART_1_EP0_UPD_MODE_EXIT
                                        (0559) 
                                        (0560) 
                                        (0561) ;-----------------------------------------------------------------------------
                                        (0562) ;  FUNCTION NAME: USBUART_1_NoDataControlStatusStage
                                        (0563) ;
                                        (0564) ;  DESCRIPTION:   This routine processes the status stage of a control
                                        (0565) ;                 write.  It must be JUMPed to, not called.  It assumes a
                                        (0566) ;                 transfer descriptor has been loaded into the driver
                                        (0567) ;                 USBUART_1_CurrentTD data structure.
                                        (0568) ;
                                        (0569) ;                 USB Device Addressing happens here because we can't change
                                        (0570) ;                 the SIE Address before the Status IN is received.
                                        (0571) ;
                                        (0572) ;-----------------------------------------------------------------------------
                                        (0573)  USBUART_1_NoDataControlStatusStage:
0906: 50 01    MOV   A,0x1              (0574)     MOV     A, USB_XFER_STATUS_ACK     ; Return a Status ACK Completion
0908: 91 03    CALL  0x0A0D             (0575)     CALL    USBUART_1_UpdateStatusBlock
                                        (0576)     ; Dispatch to the proper handler
090A: 3C 1E 01 CMP   [0x1E],0x1         (0577)     CMP     [USBUART_1_fDataPending], USB_ADDRESS_CHANGE_PENDING
090D: B0 09    JNZ   0x0917             (0578)     JNZ     .L1
                                        (0579) 
                                        (0580)     ; USB ADDRESS CHANGE
090F: 51 0C    MOV   A,[0xC]            (0581)     MOV     A, [USBUART_1_TransferBuffer]  ; Get the pending data
                                        (0582) 
0911: 29 80    OR    A,0x80             (0583)     OR      A, USB_ADDR_ENABLE         ; Set the enable bit
0913: 60 4A    MOV   REG[0x4A],A        (0584)     MOV     REG[USBUART_1_ADDR], A     ; Update the SIE address
0915: 80 01    JMP   0x0917             (0585)     JMP     .EXIT
                                        (0586) .L1:
                                        (0587) 
                                        (0588) .EXIT:
0917: 55 1E 00 MOV   [0x1E],0x0         (0589)     MOV     [USBUART_1_fDataPending], 0  ; Clear data pending
                                        (0590) 
091A: 50 00    MOV   A,0x0              (0591)     MOV    A, 0                        ; Count Register
091C: 57 06    MOV   X,0x6              (0592)     MOV    X, USB_MODE_STATUS_IN_ONLY  ; Wait for the next SETUP
091E: 8E BB    JMP   USBUART_1_EP0_UPD_MODE_EXIT(0593)     JMP    USBUART_1_EP0_UPD_MODE_EXIT
                                        (0594) 
                                        (0595) 
                                        (0596) ;-----------------------------------------------------------------------------
                                        (0597) ;  FUNCTION NAME: USBUART_1_NoDataControlError
                                        (0598) ;
                                        (0599) ;  DESCRIPTION:   This routine handles the condition when we expected a
                                        (0600) ;                 status IN, but receive an OUT
                                        (0601) ;
                                        (0602) ;-----------------------------------------------------------------------------
                                        (0603)  USBUART_1_NoDataControlError:
0920: 50 03    MOV   A,0x3              (0604)     MOV    A, USB_XFER_ERROR           ; Return Transaction Error
0922: 90 E9    CALL  0x0A0D             (0605)     CALL   USBUART_1_UpdateStatusBlock
0924: 50 00    MOV   A,0x0              (0606)     MOV    A, 0                        ; Count Register
0926: 57 03    MOV   X,0x3              (0607)     MOV    X, USB_MODE_STALL_IN_OUT    ; Set the mode register
0928: 8E B1    JMP   USBUART_1_EP0_UPD_MODE_EXIT(0608)     JMP    USBUART_1_EP0_UPD_MODE_EXIT
                                        (0609) 
                                        (0610) 
                                        (0611) ;-----------------------------------------------------------------------------
                                        (0612) ;  FUNCTION NAME: USBUART_1_LoadEndpoint
                                        (0613) ;
                                        (0614) ;  DESCRIPTION: Moves data from either RAM OR ROM - depending on the request
                                        (0615) ;               type AND then places the appropriate number of bytes -
                                        (0616) ;               depending on the request size into the endpoint FIFO.
                                        (0617) ;               It finally sets up the endpoint to send data.
                                        (0618) ;
                                        (0619) USBUART_1_LoadEndpoint:
092A: 51 0A    MOV   A,[0xA]            (0620)     MOV     A, [USBUART_1_LastSize]    ; Get the number of bytes from the last transfer
092C: 04 1C    ADD   [0x1C],A           (0621)     ADD     [USBUART_1_TransferByteCount + 1], A ; Update the transfer byte count
092E: 0E 1B 00 ADC   [0x1B],0x0         (0622)     ADC     [USBUART_1_TransferByteCount], 0 ;
0931: 51 15    MOV   A,[0x15]           (0623)     MOV     A,  [USBUART_1_TransferSize] ; Check to see if we have any
0933: 2A 16    OR    A,[0x16]           (0624)     OR      A,  [USBUART_1_TransferSize+1] ;  more data to send
0935: B0 0E    JNZ   0x0944             (0625)     JNZ     .cont                      ; Jump if we have to send more data
                                        (0626) 
                                        (0627) ; Flow here if there is no more data to send (kvn restored following two lines to fix mod 8 descriptor issue
                                        (0628) ;                                             (no zero length EPt0 termination packets are sent with these lines gone)
0937: 3C 0A 08 CMP   [0xA],0x8          (0629)     cmp     [USBUART_1_LastSize], 8    ; Was it a full packet?
093A: A0 52    JZ    0x098D             (0630)     JZ      .START_TRANSFER            ; Jump if it was full (need to send a zero length)
                                        (0631) 
                                        (0632) ; Flow here if we are entering the status stage
093C: 50 00    MOV   A,0x0              (0633)     MOV    A, 0                        ; Count Register
093E: 53 0A    MOV   [0xA],A            (0634)     MOV    [USBUART_1_LastSize], A     ; Clear the byte count
0940: 57 02    MOV   X,0x2              (0635)     MOV    X, USB_MODE_STATUS_OUT_ONLY ; Only ACK the Status Out
0942: 8E 97    JMP   USBUART_1_EP0_UPD_MODE_EXIT(0636)     JMP    USBUART_1_EP0_UPD_MODE_EXIT
                                        (0637) 
                                        (0638) ; Jump here to determine how many bytes should we transfer
                                        (0639) .cont:
0944: 3C 15 00 CMP   [0x15],0x0         (0640)     CMP     [USBUART_1_TransferSize], 0  ; Check the MSB
0947: B0 0A    JNZ   0x0952             (0641)     JNZ     .L1
                                        (0642) 
0949: 3C 16 08 CMP   [0x16],0x8         (0643)     CMP     [USBUART_1_TransferSize+1], 8  ; Check the LSB
094C: D0 05    JNC   0x0952             (0644)     JNC     .L1
                                        (0645) 
094E: 51 16    MOV   A,[0x16]           (0646)     MOV     A,[USBUART_1_TransferSize+1]   ; Transfer all the remaining data
0950: 80 03    JMP   0x0954             (0647)     JMP     .L3
                                        (0648) 
                                        (0649) .L1:
0952: 50 08    MOV   A,0x8              (0650)     MOV     A, 8                       ; Just transfer the next 8 bytes
                                        (0651) 
                                        (0652) .L3:
                                        (0653) 
0954: 14 16    SUB   [0x16],A           (0654)     SUB     [USBUART_1_TransferSize+1],A   ; Update the bytes remaining
0956: 1E 15 00 SBB   [0x15],0x0         (0655)     SBB     [USBUART_1_TransferSize],0
                                        (0656) 
0959: 53 1F    MOV   [0x1F],A           (0657)     MOV     [USBUART_1_t2],A           ; Save the count
095B: 57 00    MOV   X,0x0              (0658)     MOV     X,0
                                        (0659) 
095D: 3C 14 00 CMP   [0x14],0x0         (0660)     CMP     [USBUART_1_DataSource],USB_DS_ROM  ; RAM or ROM copy?
0960: B0 17    JNZ   0x0978             (0661)     JNZ     .RAM_COPY
                                        (0662) 
                                        (0663) ; Copy data from a ROM source
                                        (0664) .ROM_COPY:
0962: 10       PUSH  X                  (0665)     PUSH    X                          ; Save the destination offset
0963: 51 17    MOV   A,[0x17]           (0666)     MOV     A,[USBUART_1_DataPtr]      ; Get the transfer source MSB
0965: 58 18    MOV   X,[0x18]           (0667)     MOV     X,[USBUART_1_DataPtr+1]    ; Set the transfer source LSB
0967: 76 18    INC   [0x18]             (0668)     INC     [USBUART_1_DataPtr+1]      ; Increment the data pointer
0969: 0E 17 00 ADC   [0x17],0x0         (0669)     ADC     [USBUART_1_DataPtr], 0     ;   MSB if necessary
                                        (0670) 
096C: 28       ROMX                     (0671)     ROMX                               ; Get the data byte
                                        (0672) 
096D: 20       POP   X                  (0673)     POP     X                          ; Get the destination offset
096E: 61 58    MOV   REG[X+0x58],A      (0674)     MOV     REG[X + USBUART_1_EP0DATA], A ; Load the data
0970: 75       INC   X                  (0675)     INC     X                          ; Bump the destination offset
0971: 5B       MOV   A,X                (0676)     MOV     A,X                        ; Are we done?
0972: 3A 1F    CMP   A,[0x1F]           (0677)     CMP     A, [USBUART_1_t2]
0974: CF ED    JC    0x0962             (0678)     JC      .ROM_COPY                  ; Not done
0976: 80 16    JMP   0x098D             (0679)     JMP     .START_TRANSFER            ; Otherwise go start the transfer
0978: 5D D4    MOV   A,REG[0xD4]        
097A: 08       PUSH  A                  
                                        (0680) 
                                        (0681) ; Copy data from a RAM source
                                        (0682) .RAM_COPY:
                                        (0683) IF SYSTEM_LARGE_MEMORY_MODEL
                                        (0684)     REG_PRESERVE MVR_PP
097B: 51 17    MOV   A,[0x17]           (0685)     mov     A, [USBUART_1_DataPtr]  ; set proper page for mvi command
097D: 60 D4    MOV   REG[0xD4],A        (0686)     mov     reg[MVR_PP], A
                                        (0687) ENDIF
                                        (0688) .CP1:
097F: 3E 18    MVI   A,[0x18]           (0689)     MVI     A, [USBUART_1_DataPtr+1]   ; Get the data, bump the source
                                        (0690) 
0981: 61 58    MOV   REG[X+0x58],A      (0691)     MOV     REG[X +USBUART_1_EP0DATA], A ; Load the data
0983: 75       INC   X                  (0692)     INC     X                          ; Bump the destination offset
0984: 5B       MOV   A,X                (0693)     MOV     A,X                        ; Are we done?
0985: 3A 1F    CMP   A,[0x1F]           (0694)     CMP     A, [USBUART_1_t2]
0987: CF F7    JC    0x097F             (0695)     jc      .CP1                       ; Not done
0989: 18       POP   A                  
098A: 60 D4    MOV   REG[0xD4],A        
                                        (0696) 
                                        (0697) IF SYSTEM_LARGE_MEMORY_MODEL
                                        (0698)     REG_RESTORE MVR_PP
098C: 5B       MOV   A,X                (0699)     mov     A, X                       ; Restore A
                                        (0700) ENDIF
                                        (0701) 
                                        (0702) ;; Set up the IN transfer count/mode/etc
                                        (0703) ;    A contains the byte count
                                        (0704) .START_TRANSFER:
098D: 53 0A    MOV   [0xA],A            (0705)     MOV     [USBUART_1_LastSize], A    ; Save the packet size
                                        (0706) 
098F: 50 01    MOV   A,0x1              (0707)     MOV     A, 1
0991: 22 1D    AND   A,[0x1D]           (0708)     AND     A, [USBUART_1_EP0DataToggle]
0993: A0 03    JZ    0x0997             (0709)     JZ      .BYPASS_T1
0995: 50 80    MOV   A,0x80             (0710)     MOV     A, USB_CNT_TOGGLE          ; Or T1 in the data toggle
                                        (0711) 
                                        (0712) .BYPASS_T1:
0997: 2A 0A    OR    A,[0xA]            (0713)     OR      A, [USBUART_1_LastSize]
0999: 36 1D 01 XOR   [0x1D],0x1         (0714)     XOR     [USBUART_1_EP0DataToggle], 1    ; Update the data toggle for next time
                                        (0715) 
099C: 57 0F    MOV   X,0xF              (0716)     MOV    X, USB_MODE_ACK_IN_STATUS_OUT  ; Set the mode register
099E: 8E 3B    JMP   USBUART_1_EP0_UPD_MODE_EXIT(0717)     JMP    USBUART_1_EP0_UPD_MODE_EXIT
                                        (0718) 
                                        (0719) 
                                        (0720) ;-----------------------------------------------------------------------------
                                        (0721) ;  FUNCTION NAME: USBUART_1_GetTableEntry
                                        (0722) ;
                                        (0723) ;  DESCRIPTION: This function figures out based on the various bytes in the
                                        (0724) ;               setup packet where to get the data from or put the data to.
                                        (0725) ;               Transfer Data structures are defined each of the supported
                                        (0726) ;               control transfers, this function finds the right one and
                                        (0727) ;               saves it in the CurrentTD structure in RAM.  It then
                                        (0728) ;               calls InitControlRead or InitControlWrite to being the
                                        (0729) ;               transaction.
                                        (0730) ;
                                        (0731) ;-----------------------------------------------------------------------------
                                        (0732) EXPORT USBUART_1_GetTableEntry
                                        (0733) USBUART_1_GetTableEntry:
                                        (0734) 
09A0: 75       INC   X                  (0735)     INC     X                          ; Point to the first table entry
09A1: 09 00    ADC   A,0x0              (0736)     ADC     A, 0                       ;
09A3: 08       PUSH  A                  
09A4: 65 1F    ASL   [0x1F]             
09A6: 65 1F    ASL   [0x1F]             
09A8: 65 1F    ASL   [0x1F]             
09AA: 18       POP   A                  
                                        (0737) 
                                        (0738)     TD_INDEX_TO_OFFSET USBUART_1_t2 ; Convert the index
                                        (0739) 
09AB: 4B       SWAP  A,X                (0740)     SWAP    A, X
09AC: 02 1F    ADD   A,[0x1F]           (0741)     ADD     A, [USBUART_1_t2]
09AE: 4B       SWAP  A,X                (0742)     SWAP    A, X
09AF: 09 00    ADC   A,0x0              (0743)     ADC     A, 0                       ; A:X now points to the descriptor table entry we want
                                        (0744) 
                                        (0745) ; Flow here to load the Transfer Descriptor (TD_ENTRY)
09B1: 55 1F 14 MOV   [0x1F],0x14        (0746)     MOV     [USBUART_1_t2], USBUART_1_CurrentTD  ; Use Temp as MVI pointer
09B4: 90 26    CALL  USBUART_1_GETBYTE  (0747)     CALL     USBUART_1_GETBYTE         ; Get the descriptor data source
09B6: 90 1C    CALL  USBUART_1_GETWORD  (0748)     CALL     USBUART_1_GETWORD         ; Get the descriptor size
09B8: 90 1A    CALL  USBUART_1_GETWORD  (0749)     CALL     USBUART_1_GETWORD         ; Get the descriptor address
09BA: 90 18    CALL  USBUART_1_GETWORD  (0750)     CALL     USBUART_1_GETWORD         ; Get the Status Pointer
                                        (0751) ; Dispatch to InitControlRead or InitControlWrite based on d2h/h2d in the request
09BC: 5D 58    MOV   A,REG[0x58]        (0752)     MOV    A, REG[USBUART_1_EP0DATA+bmRequestType] ; Get bmRequestType
09BE: 21 80    AND   A,0x80             (0753)     AND     A,0x80                          ; Control Read or Write
09C0: A0 03    JZ    0x09C4             (0754)     JZ      .control_write
                                        (0755) 
09C2: 8E 8E    JMP   _USBUART_1_InitControlRead(0756)     JMP     USBUART_1_InitControlRead
                                        (0757) 
                                        (0758) .control_write:
09C4: 8E D3    JMP   _USBUART_1_InitControlWrite(0759)     JMP     USBUART_1_InitControlWrite
                                        (0760) 
                                        (0761) 
                                        (0762) ;-----------------------------------------------------------------------------
                                        (0763) ;  FUNCTION NAME: USBUART_1_LOOKUP
                                        (0764) ;
                                        (0765) ;  DESCRIPTION:    Returns the address of an entry in a lookup table (LT_ENTRY)
                                        (0766) ;
                                        (0767) ;-----------------------------------------------------------------------------
                                        (0768) ;
                                        (0769) ;  ARGUMENTS:    A:X Point to the lookup table
                                        (0770) ;                USBUART_1_t2 contain the table index
                                        (0771) ;
                                        (0772) ;  RETURNS:      Address of the LT_ENTRY in A:X
                                        (0773) ;
                                        (0774) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0775) ;
                                        (0776) ;  THEORY of OPERATION or PROCEDURE:
                                        (0777) ;
                                        (0778) ;-----------------------------------------------------------------------------
                                        (0779) EXPORT USBUART_1_LOOKUP
                                        (0780) USBUART_1_LOOKUP:
09C6: 75       INC   X                  (0781)     INC     X                          ; Point to the first table entry
09C7: 09 00    ADC   A,0x0              (0782)     ADC     A, 0                       ;
09C9: 65 1F    ASL   [0x1F]             
09CB: 65 1F    ASL   [0x1F]             
                                        (0783) 
                                        (0784)     LT_INDEX_TO_OFFSET USBUART_1_t2    ; Convert the index
09CD: 4B       SWAP  A,X                (0785)     SWAP    A, X
09CE: 02 1F    ADD   A,[0x1F]           (0786)     ADD     A, [USBUART_1_t2]          ;
09D0: 4B       SWAP  A,X                (0787)     SWAP    A, X
09D1: 09 00    ADC   A,0x0              (0788)     ADC     A, 0
09D3: 7F       RET                      (0789)     RET
                                        (0790) 
                                        (0791) 
                                        (0792) ;-----------------------------------------------------------------------------
                                        (0793) ;  FUNCTION NAME: USBUART_1_GETWORD/USBUART_1_GETBYTE
                                        (0794) ;
                                        (0795) ;  DESCRIPTION:    Get a word value from ROM
                                        (0796) ;
                                        (0797) ;-----------------------------------------------------------------------------
                                        (0798) ;
                                        (0799) ;  ARGUMENTS:    A:X is the ROM Address
                                        (0800) ;                USBUART_1_t2 is the destination address
                                        (0801) ;
                                        (0802) ;  RETURNS:      USBUART_1_t1
                                        (0803) ;
                                        (0804) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0805) ;                USES USBUART_1_t2
                                        (0806) ;                A:X points to the subsequent ROM location
                                        (0807) ;  THEORY of OPERATION or PROCEDURE:
                                        (0808) ;
                                        (0809) ;-----------------------------------------------------------------------------
                                        (0810) EXPORT USBUART_1_GETWORD
                                        (0811) USBUART_1_GETWORD:
                                        (0812) 
09D4: 08       PUSH  A                  (0813)     PUSH    A                          ; Don't loose the pointer MSB
09D5: 28       ROMX                     (0814)     ROMX                               ; Data source flag
09D6: 3F 1F    MVI   [0x1F],A           (0815)     MVI     [USBUART_1_t2], A          ; Save the data source
09D8: 18       POP   A                  (0816)     POP     A                          ; Get the MSB back
09D9: 75       INC   X                  (0817)     INC     X                          ; Point to the next  entry
09DA: 09 00    ADC   A,0x0              (0818)     ADC     A, 0                       ;
                                        (0819) 
                                        (0820) EXPORT USBUART_1_GETBYTE
                                        (0821) USBUART_1_GETBYTE:
                                        (0822) 
09DC: 08       PUSH  A                  (0823)     PUSH    A                          ; Don't loose the pointer MSB
09DD: 28       ROMX                     (0824)     ROMX                               ; Data source flag
09DE: 3F 1F    MVI   [0x1F],A           (0825)     MVI     [USBUART_1_t2], A          ; Save the data source
09E0: 18       POP   A                  (0826)     POP     A                          ; Get the MSB back
09E1: 75       INC   X                  (0827)     INC     X                          ; Point to the next  entry
09E2: 09 00    ADC   A,0x0              (0828)     ADC     A, 0                       ;
09E4: 7F       RET                      (0829)     RET
                                        (0830) 
                                        (0831) 
                                        (0832) ;-----------------------------------------------------------------------------
                                        (0833) ;  FUNCTION NAME: USBUART_1_GET_DEVICE_TABLE_ENTRY
                                        (0834) ;
                                        (0835) ;  DESCRIPTION:    Get the address of the current DEVICE_TABLE entry
                                        (0836) ;                  Not intended for use by C functions
                                        (0837) ;
                                        (0838) ;-----------------------------------------------------------------------------
                                        (0839) ;
                                        (0840) ;  ARGUMENTS:
                                        (0841) ;
                                        (0842) ;  RETURNS:        A:X points the current DEVICE_TABLE entry
                                        (0843) ;                  Carry flag is set if the current device index is out of range
                                        (0844) ;
                                        (0845) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0846) ;
                                        (0847) ;  THEORY of OPERATION or PROCEDURE:
                                        (0848) ;
                                        (0849) ;-----------------------------------------------------------------------------
                                        (0850) EXPORT USBUART_1_GET_DEVICE_TABLE_ENTRY
                                        (0851) USBUART_1_GET_DEVICE_TABLE_ENTRY:
09E5: 5F 1F 00 MOV   [0x1F],[0x0]       (0852)     MOV     [USBUART_1_t2], [USBUART_1_bCurrentDevice]  ; Use the UM temp var--Selector
                                        (0853) 
09E8: 50 01    MOV   A,0x1              (0854)     MOV     A,>USBUART_1_DEVICE_LOOKUP ; Get the ROM Address MSB
09EA: 57 CE    MOV   X,0xCE             (0855)     MOV     X,<USBUART_1_DEVICE_LOOKUP ; Get the ROM Address LSB
09EC: 28       ROMX                     (0856)     ROMX                               ; First entry is the table size (only a byte)
09ED: 3A 1F    CMP   A,[0x1F]           (0857)     CMP     A, [USBUART_1_t2]          ; Range check
09EF: 50 01    MOV   A,0x1              (0858)     MOV     A,>USBUART_1_DEVICE_LOOKUP ; Get the ROM Address MSB
09F1: C0 03    JC    0x09F5             (0859)     JC      .exit
                                        (0860) ; Flow here if the index is valid
09F3: 9F D1    CALL  USBUART_1_LOOKUP   (0861)     CALL    USBUART_1_LOOKUP           ; Look up the configuration
                                        (0862) ; Jump or flow here on exit
                                        (0863) .exit:
09F5: 7F       RET                      (0864)     RET
                                        (0865) 
                                        (0866) 
                                        (0867) ;-----------------------------------------------------------------------------
                                        (0868) ;  FUNCTION NAME: USBUART_1_GET_CONFIG_TABLE_ENTRY
                                        (0869) ;
                                        (0870) ;  DESCRIPTION:    Get the address of the current DEVICE_TABLE entry
                                        (0871) ;                  Not intended for use by C functions
                                        (0872) ;                  Does not do range checking on
                                        (0873) ;
                                        (0874) ;-----------------------------------------------------------------------------
                                        (0875) ;
                                        (0876) ;  ARGUMENTS:
                                        (0877) ;
                                        (0878) ;  RETURNS:        A:X points the current CONFIG_TABLE entry
                                        (0879) ;                  Carry flag is set if the current device index is out of range
                                        (0880) ;
                                        (0881) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0882) ;
                                        (0883) ;  THEORY of OPERATION or PROCEDURE:
                                        (0884) ;
                                        (0885) ;-----------------------------------------------------------------------------
                                        (0886) EXPORT USBUART_1_GET_CONFIG_TABLE_ENTRY
                                        (0887) USBUART_1_GET_CONFIG_TABLE_ENTRY:
09F6: 9F ED    CALL  USBUART_1_GET_DEVICE_TABLE_ENTRY(0888)     CALL    USBUART_1_GET_DEVICE_TABLE_ENTRY  ; Get the selected device
09F8: 55 1F 20 MOV   [0x1F],0x20        (0889)     MOV     [USBUART_1_t2],USBUART_1_t1  ; Set the GETWORD destination
09FB: 9F D7    CALL  USBUART_1_GETWORD  (0890)     CALL    USBUART_1_GETWORD          ; Get the pointer to the CONFIG_LOOKUP table
                                        (0891)                                        ; ITempW has the address
09FD: 5D 5A    MOV   A,REG[0x5A]        (0892)     MOV     A, REG[USBUART_1_EP0DATA+wValueLo]  ; Get the configuration number
09FF: 53 1F    MOV   [0x1F],A           (0893)     MOV     [USBUART_1_t2],A           ; Save it
0A01: 51 20    MOV   A,[0x20]           (0894)     MOV     A, [USBUART_1_t1]          ; Get the CONFIG_LOOKUP ROM Address MSB
0A03: 58 21    MOV   X,[0x21]           (0895)     MOV     X, [USBUART_1_t1+1]        ; Get the CONFIG_LOOKUP ROM Address LSB
                                        (0896) 
                                        (0897) ; A:X Points to the CONFIG_LOOKUP, so get the current entry
0A05: 5F 1F 01 MOV   [0x1F],[0x1]       (0898)     MOV     [USBUART_1_t2], [USBUART_1_Configuration] ; Get the configuration number
0A08: 7A 1F    DEC   [0x1F]             (0899)     DEC     [USBUART_1_t2]             ; We don't populate the 0th entry
0A0A: 9F BA    CALL  USBUART_1_LOOKUP   (0900)     CALL    USBUART_1_LOOKUP           ; Look up the configuration
0A0C: 7F       RET                      (0901)     RET
                                        (0902) 
                                        (0903) 
                                        (0904) ;-----------------------------------------------------------------------------
                                        (0905) ;  FUNCTION NAME: USBUART_1_UpdateStatusBlock
                                        (0906) ;
                                        (0907) ;  DESCRIPTION:    Update the Completion Status Block for a Request.  The
                                        (0908) ;                  block is updated with the completion code from the
                                        (0909) ;                  argument (A) and the _TransferByteCount.
                                        (0910) ;
                                        (0911) ;                  The StatusBlock Pointer (_StatusBlockPtr) is set to NULL (0)
                                        (0912) ;                  to make sure no other updates are made to the StatusBlock by
                                        (0913) ;                  the USB User Module.
                                        (0914) ;
                                        (0915) ;-----------------------------------------------------------------------------
                                        (0916) ;
                                        (0917) ;  ARGUMENTS:      A contains the Completion Status Code
                                        (0918) ;
                                        (0919) ;  RETURNS:        None
                                        (0920) ;
                                        (0921) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0922) ;
                                        (0923) ;  THEORY of OPERATION or PROCEDURE:
                                        (0924) ;
                                        (0925) ;-----------------------------------------------------------------------------
                                        (0926) USBUART_1_UpdateStatusBlock:
0A0D: 58 1A    MOV   X,[0x1A]           (0927)     MOV     X, [USBUART_1_StatusBlockPtr + 1] ;
0A0F: 4B       SWAP  A,X                (0928)     SWAP    A, X                       ; Don't loose the completion code
0A10: 39 00    CMP   A,0x0              (0929)     CMP     A, 0                       ; NULL?
0A12: A0 0F    JZ    0x0A22             (0930)     JZ      .done                      ; No update on NULL
                                        (0931) ; Flow here to update the VSR Completion Status Block
0A14: 4B       SWAP  A,X                (0932)     SWAP    A, X                       ; Completion code A, Pointer in X
0A15: 54 00    MOV   [X+0],A            (0933)     MOV     [X + 0], A                 ; Update the completion Code
0A17: 51 1B    MOV   A,[0x1B]           (0934)     MOV     A, [USBUART_1_TransferByteCount] ; Actual Byte Count MSB
0A19: 54 01    MOV   [X+1],A            (0935)     MOV     [X + 1], A
0A1B: 51 1C    MOV   A,[0x1C]           (0936)     MOV     A, [USBUART_1_TransferByteCount + 1] ; Actual Byte Count LSB
0A1D: 54 02    MOV   [X+2],A            (0937)     MOV     [X + 2], A
0A1F: 55 1A 00 MOV   [0x1A],0x0         (0938)     MOV     [USBUART_1_StatusBlockPtr + 1], 0 ; Clear the Block Pointer
                                        (0939) .done:
0A22: 7F       RET                      (0940)     RET                                ; All done
                                        (0941) 
                                        (0942) 
                                        (0943) ;-----------------------------------------------------------------------------
                                        (0944) ;  FUNCTION NAME: USBUART_1_InitializeStatusBlock
                                        (0945) ;
                                        (0946) ;  DESCRIPTION:    Initialize the Completion Status Block for a Request.
                                        (0947) ;                  The completion code is set to USB_XFER_IDLE.
                                        (0948) ;
                                        (0949) ;-----------------------------------------------------------------------------
                                        (0950) ;
                                        (0951) ;  ARGUMENTS:      None
                                        (0952) ;
                                        (0953) ;  RETURNS:        None
                                        (0954) ;
                                        (0955) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0956) ;
                                        (0957) ;  THEORY of OPERATION or PROCEDURE:
                                        (0958) ;
                                        (0959) ;-----------------------------------------------------------------------------
                                        (0960) USBUART_1_InitializeStatusBlock:
0A23: 51 1A    MOV   A,[0x1A]           (0961)     MOV     A, [USBUART_1_StatusBlockPtr + 1] ;
0A25: 39 00    CMP   A,0x0              (0962)     CMP     A, 0                       ; NULL?
0A27: A0 0B    JZ    0x0A33             (0963)     JZ      .done                      ; No update on NULL
                                        (0964) ; Flow here to initialize the Completion Status Block
0A29: 4B       SWAP  A,X                (0965)     SWAP    A, X                       ; Pointer in X
0A2A: 56 00 00 MOV   [X+0],0x0          (0966)     MOV     [X + 0], USB_XFER_IDLE     ; Initialize the completion code (0)
0A2D: 55 1B 00 MOV   [0x1B],0x0         (0967)     MOV     [USBUART_1_TransferByteCount], 0 ; Clear the byte count
0A30: 55 1C 00 MOV   [0x1C],0x0         (0968)     MOV     [USBUART_1_TransferByteCount + 1], 0 ;
                                        (0969) .done:
0A33: 7F       RET                      (0970)     RET                                ; All done
0A34: 8B 0A    JMP   USBUART_1_DT_h2d_std_dev_Dispatch
0A36: 8B 3F    JMP   USBUART_1_DT_h2d_std_ifc_Dispatch
0A38: 8B 77    JMP   USBUART_1_DT_h2d_std_ep_Dispatch
0A3A: 80 43    JMP   0x0A7E             
0A3C: 80 41    JMP   0x0A7E             
0A3E: 80 9A    JMP   USBUART_1_DT_h2d_cls_ifc_Dispatch
0A40: 80 3D    JMP   0x0A7E             
0A42: 80 3B    JMP   0x0A7E             
0A44: 80 39    JMP   0x0A7E             
0A46: 80 37    JMP   0x0A7E             
0A48: 80 35    JMP   0x0A7E             
0A4A: 80 33    JMP   0x0A7E             
0A4C: 80 31    JMP   0x0A7E             
0A4E: 80 2F    JMP   0x0A7E             
0A50: 80 2D    JMP   0x0A7E             
0A52: 80 2B    JMP   0x0A7E             
0A54: 8A CA    JMP   USBUART_1_DT_d2h_std_dev_Dispatch
0A56: 8B 0A    JMP   USBUART_1_DT_d2h_std_ifc_Dispatch
0A58: 8B 32    JMP   USBUART_1_DT_d2h_std_ep_Dispatch
0A5A: 80 23    JMP   0x0A7E             
0A5C: 80 21    JMP   0x0A7E             
0A5E: 80 CA    JMP   USBUART_1_DT_d2h_cls_ifc_Dispatch
0A60: 80 1D    JMP   0x0A7E             
0A62: 80 1B    JMP   0x0A7E             
0A64: 80 19    JMP   0x0A7E             
0A66: 80 17    JMP   0x0A7E             
0A68: 80 15    JMP   0x0A7E             
0A6A: 80 13    JMP   0x0A7E             
0A6C: 80 11    JMP   0x0A7E             
0A6E: 80 0F    JMP   0x0A7E             
0A70: 80 0D    JMP   0x0A7E             
0A72: 80 0B    JMP   0x0A7E             
0A74: 39 20    CMP   A,0x20             
0A76: D0 04    JNC   0x0A7B             
0A78: 64       ASL   A                  
0A79: EF BA    JACC  USBUART_1_DT_bmRequestType
0A7B: 7D 0A 7E LJMP  0x0A7E             
                                        (0971) 
                                        (0972) 
                                        (0973) ;-----------------------------------------------------------------------------
                                        (0974) ;  FUNCTION NAME: ;  USB 1st Tier Dispatch Jump Table (based on bmRequestType)
                                        (0975) ;
                                        (0976) ;  DESCRIPTION:
                                        (0977) ;
                                        (0978) ;-----------------------------------------------------------------------------
                                        (0979) ;
                                        (0980) ;  ARGUMENTS:
                                        (0981) ;
                                        (0982) ;  RETURNS:
                                        (0983) ;
                                        (0984) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0985) ;
                                        (0986) ;  THEORY of OPERATION or PROCEDURE:
                                        (0987) ;
                                        (0988) ;-----------------------------------------------------------------------------
                                        (0989) MACRO BMREQUEST_DISPATCH
                                        (0990) IF (USB_CB_@0_@1_@2 & 1)
                                        (0991)     JMP     USBUART_1_DT_@0_@1_@2_Dispatch
                                        (0992) ELSE
                                        (0993)     JMP     USBUART_1_Not_Supported_Local_Drv
                                        (0994) ENDIF
                                        (0995) ENDM
                                        (0996) 
                                        (0997) USBUART_1_DT_bmRequestType::
                                        (0998)     BMREQUEST_DISPATCH    h2d,std,dev
                                        (0999)     BMREQUEST_DISPATCH    h2d,std,ifc
                                        (1000)     BMREQUEST_DISPATCH    h2d,std,ep
                                        (1001)     BMREQUEST_DISPATCH    h2d,std,oth
                                        (1002)     BMREQUEST_DISPATCH    h2d,cls,dev
                                        (1003)     BMREQUEST_DISPATCH    h2d,cls,ifc
                                        (1004)     BMREQUEST_DISPATCH    h2d,cls,ep
                                        (1005)     BMREQUEST_DISPATCH    h2d,cls,oth
                                        (1006)     BMREQUEST_DISPATCH    h2d,vnd,dev
                                        (1007)     BMREQUEST_DISPATCH    h2d,vnd,ifc
                                        (1008)     BMREQUEST_DISPATCH    h2d,vnd,ep
                                        (1009)     BMREQUEST_DISPATCH    h2d,vnd,oth
                                        (1010)     BMREQUEST_DISPATCH    h2d,rsv,dev
                                        (1011)     BMREQUEST_DISPATCH    h2d,rsv,ifc
                                        (1012)     BMREQUEST_DISPATCH    h2d,rsv,ep
                                        (1013)     BMREQUEST_DISPATCH    h2d,rsv,oth
                                        (1014)     BMREQUEST_DISPATCH    d2h,std,dev
                                        (1015)     BMREQUEST_DISPATCH    d2h,std,ifc
                                        (1016)     BMREQUEST_DISPATCH    d2h,std,ep
                                        (1017)     BMREQUEST_DISPATCH    d2h,std,oth
                                        (1018)     BMREQUEST_DISPATCH    d2h,cls,dev
                                        (1019)     BMREQUEST_DISPATCH    d2h,cls,ifc
                                        (1020)     BMREQUEST_DISPATCH    d2h,cls,ep
                                        (1021)     BMREQUEST_DISPATCH    d2h,cls,oth
                                        (1022)     BMREQUEST_DISPATCH    d2h,vnd,dev
                                        (1023)     BMREQUEST_DISPATCH    d2h,vnd,ifc
                                        (1024)     BMREQUEST_DISPATCH    d2h,vnd,ep
                                        (1025)     BMREQUEST_DISPATCH    d2h,vnd,oth
                                        (1026)     BMREQUEST_DISPATCH    d2h,rsv,dev
                                        (1027)     BMREQUEST_DISPATCH    d2h,rsv,ifc
                                        (1028)     BMREQUEST_DISPATCH    d2h,rsv,ep
                                        (1029)     BMREQUEST_DISPATCH    d2h,rsv,oth
                                        (1030) USBUART_1_DT_End:
                                        (1031) USBUART_1_DT_Size: equ (USBUART_1_DT_End-USBUART_1_DT_bmRequestType) / 2
                                        (1032) USBUART_1_bmRequestType_Dispatch::
                                        (1033)     DISPATCHER USBUART_1_DT_bmRequestType, USBUART_1_DT_Size, USBUART_1_Not_Supported_Local_Drv
                                        (1034) 
                                        (1035) USBUART_1_Not_Supported_Local_Drv:
0A7E: 7D 04 EE LJMP  _USBUART_1_Not_Supported|USBUART_1_CB_h2d_std_dev_08|USBUART_1_CB_h2d_std_dev_07|USBUART_1_CB_d2h_std_dev_07|USBUART_1_CB_h2d_std_dev_06|USBUART_1_CB_d2h_std_dev_05|USBUART_1_CB_h2d_std_dev_04|USBUART_1_CB_d2h_std_dev_04|USBUART_1_Not_Supported|...(1036)         LJMP     USBUART_1_Not_Supported
                                        (1037) 
                                        (1038) 
                                        (1039) ;-----------------------------------------------
                                        (1040) ; Add custom application code for routines
                                        (1041) ;-----------------------------------------------
                                        (1042) 
                                        (1043)    ;@PSoC_UserCode_BODY_1@ (Do not change this line.)
                                        (1044)    ;---------------------------------------------------
                                        (1045)    ; Insert your custom code below this banner
                                        (1046)    ;---------------------------------------------------
                                        (1047) 
                                        (1048)    ;---------------------------------------------------
                                        (1049)    ; Insert your custom code above this banner
                                        (1050)    ;---------------------------------------------------
                                        (1051)    ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (1052) 
                                        (1053) ; End of File USBUART_1_drv.asm
FILE: lib\usbuart_1_cls_cdc.asm         (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME: USBUART_1_cls_cdc.asm
                                        (0004) ;;  Version: 1.40, Updated on 2011/3/29 at 14:31:18
                                        (0005) ;; Generated by PSoC Designer 5.1.2110.0
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: Communication Device Class (CDC) request implementation
                                        (0008) ;;
                                        (0009) ;;  Copyright (c) Cypress Semiconductor 2011. All Rights Reserved.
                                        (0010) ;;*****************************************************************************
                                        (0011) ;;*****************************************************************************
                                        (0012) 
                                        (0013) include "m8c.inc"
                                        (0014) include "USBUART_1_macros.inc"
                                        (0015) include "USBUART_1.inc"
                                        (0016) include "memory.inc"
                                        (0017) 
                                        (0018) IF (USBUART_1_bSerialNumberType & 1)   ;if serial number automatic
                                        (0019) AREA SSCParmBlk(RAM,ABS)
                                        (0020) SSCParameterBlk:              blk      8     ; reserve 8 bytes: F8 - FF for supervisory operation
                                        (0021) ENDIF
                                        (0022) 
                                        (0023) AREA InterruptRAM (RAM,REL,CON)
                                        (0024) 
                                        (0025) DummyBuffer:
                                        (0026) 	BLK 8	; dummy buffer for SEND_ENCAPSULATED_COMMAND and GET_ENCAPSULATED_RESPONSE requests
                                        (0027) 
                                        (0028) IF (USBUART_1_bSerialNumberType & 1)   ;if serial number automatic
                                        (0029) EXPORT USBUART_1_SerialString
                                        (0030) USBUART_1_SerialString:
                                        (0031)     BLK 1   ; bLength
                                        (0032)     BLK 1   ; bDescriptorType = 3 (STRING)
                                        (0033)     BLK 24  ; 12 symbols in unicode
                                        (0034) ENDIF
                                        (0035) 
                                        (0036) EXPORT USBUART_1_LineCoding
                                        (0037) EXPORT _USBUART_1_LineCoding
                                        (0038) USBUART_1_LineCoding:
                                        (0039) _USBUART_1_LineCoding:
                                        (0040) 	BLK	4	;dwDTERate		Data terminal rate, in bits per second
                                        (0041) 	BLK 1	;bCharFormat		Stop bits (0 = 1 stop bit, 1 = 1.5 stop bit, 2 = 2 stop bit)
                                        (0042) 	BLK	1	;bParityType		Parity (0 = none, 1 = odd, 2 = even, 3 = mark, 4 = space)
                                        (0043) 	BLK 1	;bDataBits			Data bits (5,6,7,8 or 16)
                                        (0044) 
                                        (0045) EXPORT USBUART_1_LineControlBitmap
                                        (0046) EXPORT _USBUART_1_LineControlBitmap
                                        (0047) USBUART_1_LineControlBitmap::
                                        (0048) _USBUART_1_LineControlBitmap:
                                        (0049)     BLK 2   ; Line control bitmap
                                        (0050)     		;	D15..D2 - reserved
                                        (0051)     		;   D1 - RTS (0 = deactivate carrier, 1 = activate carrier)
                                        (0052)     		;	D0 - DTR (0 = not present, 1 = present)
                                        (0053) 
                                        (0054) AREA UserModules (ROM, REL)
                                        (0055) 
                                        (0056) .LITERAL
                                        (0057) GetSetEncapsulatedCommand:
                                        (0058) 	TD_START_TABLE	1
                                        (0059) 	TD_ENTRY		USB_DS_RAM, 8, DummyBuffer, NULL_PTR
                                        (0060) 
                                        (0061) GetSetLineCodingTable:
                                        (0062)     TD_START_TABLE  1
                                        (0063)     TD_ENTRY        USB_DS_RAM, 7, USBUART_1_LineCoding, NULL_PTR
                                        (0064) .ENDLITERAL
                                        (0065) 
                                        (0066) ;-----------------------------------------------------------------------------
                                        (0067) ;  USB 2nd Tier Dispatch Jump Tables for CDC Requests (based on bRequest)
                                        (0068) ;-----------------------------------------------------------------------------
                                        (0069) ;  FUNCTION NAME: ;  USB 2nd Tier Dispatch Jump Table
                                        (0070) ;
                                        (0071) ;  DESCRIPTION:   The following tables dispatch to the Class request handler
                                        (0072) ;                 functions.  (Assumes bmRequestType(5:6) is 1, Class)
                                        (0073) ;-----------------------------------------------------------------------------
                                        (0074) USBUART_1_DT_h2d_cls_ifc:
0A93: 80 A1    JMP   0x0B35             (0075)     jmp     USBUART_1_CB_h2d_cls_ifc_00			;00
0A95: 80 E8    JMP   0x0B7E             (0076)     jmp     USBUART_1_Not_Supported_Local1		;01
0A97: 80 E6    JMP   0x0B7E             (0077)     jmp     USBUART_1_Not_Supported_Local1		;02
0A99: 80 E4    JMP   0x0B7E             (0078)     jmp     USBUART_1_Not_Supported_Local1		;03
0A9B: 80 E2    JMP   0x0B7E             (0079)     jmp     USBUART_1_Not_Supported_Local1		;04
0A9D: 80 E0    JMP   0x0B7E             (0080)     jmp     USBUART_1_Not_Supported_Local1		;05
0A9F: 80 DE    JMP   0x0B7E             (0081)     jmp     USBUART_1_Not_Supported_Local1		;06
0AA1: 80 DC    JMP   0x0B7E             (0082)     jmp     USBUART_1_Not_Supported_Local1		;07
0AA3: 80 DA    JMP   0x0B7E             (0083)     jmp     USBUART_1_Not_Supported_Local1		;08
0AA5: 80 D8    JMP   0x0B7E             (0084)     jmp     USBUART_1_Not_Supported_Local1		;09
0AA7: 80 D6    JMP   0x0B7E             (0085)     jmp     USBUART_1_Not_Supported_Local1		;0A
0AA9: 80 D4    JMP   0x0B7E             (0086)     jmp     USBUART_1_Not_Supported_Local1		;0B
0AAB: 80 D2    JMP   0x0B7E             (0087)     jmp     USBUART_1_Not_Supported_Local1		;0C
0AAD: 80 D0    JMP   0x0B7E             (0088)     jmp     USBUART_1_Not_Supported_Local1		;0D
0AAF: 80 CE    JMP   0x0B7E             (0089)     jmp     USBUART_1_Not_Supported_Local1		;0E
0AB1: 80 CC    JMP   0x0B7E             (0090)     jmp     USBUART_1_Not_Supported_Local1		;0F
0AB3: 80 CA    JMP   0x0B7E             (0091)     jmp     USBUART_1_Not_Supported_Local1		;10
0AB5: 80 C8    JMP   0x0B7E             (0092)     jmp     USBUART_1_Not_Supported_Local1		;11
0AB7: 80 C6    JMP   0x0B7E             (0093)     jmp     USBUART_1_Not_Supported_Local1		;12
0AB9: 80 C4    JMP   0x0B7E             (0094)     jmp     USBUART_1_Not_Supported_Local1		;13
0ABB: 80 C2    JMP   0x0B7E             (0095)     jmp     USBUART_1_Not_Supported_Local1		;14
0ABD: 80 C0    JMP   0x0B7E             (0096)     jmp     USBUART_1_Not_Supported_Local1		;15
0ABF: 80 BE    JMP   0x0B7E             (0097)     jmp     USBUART_1_Not_Supported_Local1		;16
0AC1: 80 BC    JMP   0x0B7E             (0098)     jmp     USBUART_1_Not_Supported_Local1		;17
0AC3: 80 BA    JMP   0x0B7E             (0099)     jmp     USBUART_1_Not_Supported_Local1		;18
0AC5: 80 B8    JMP   0x0B7E             (0100)     jmp     USBUART_1_Not_Supported_Local1		;19
0AC7: 80 B6    JMP   0x0B7E             (0101)     jmp     USBUART_1_Not_Supported_Local1		;1A
0AC9: 80 B4    JMP   0x0B7E             (0102)     jmp     USBUART_1_Not_Supported_Local1		;1B
0ACB: 80 B2    JMP   0x0B7E             (0103)     jmp     USBUART_1_Not_Supported_Local1		;1C
0ACD: 80 B0    JMP   0x0B7E             (0104)     jmp     USBUART_1_Not_Supported_Local1		;1D
0ACF: 80 AE    JMP   0x0B7E             (0105)     jmp     USBUART_1_Not_Supported_Local1		;1E
0AD1: 80 AC    JMP   0x0B7E             (0106)     jmp     USBUART_1_Not_Supported_Local1		;1F
0AD3: 80 70    JMP   0x0B44             (0107)     jmp     USBUART_1_CB_h2d_cls_ifc_20			;20
0AD5: 80 A8    JMP   0x0B7E             (0108)     jmp     USBUART_1_Not_Supported_Local1		;21
0AD7: 80 7B    JMP   0x0B53             (0109)     jmp     USBUART_1_CB_h2d_cls_ifc_22			;22
                                        (0110) USBUART_1_DT_h2d_cls_ifc_End:
                                        (0111) USBUART_1_DT_h2d_cls_ifc_Size: equ (USBUART_1_DT_h2d_cls_ifc_End-USBUART_1_DT_h2d_cls_ifc) / 2
                                        (0112) 
                                        (0113) USBUART_1_DT_h2d_cls_ifc_Dispatch::
0AD9: 5D 59    MOV   A,REG[0x59]        (0114)     mov   A, REG[USBUART_1_EP0DATA + bRequest]       ; Get the request number
0ADB: 39 23    CMP   A,0x23             
0ADD: D0 04    JNC   0x0AE2             
0ADF: 64       ASL   A                  
0AE0: EF B2    JACC  0x0A93             
0AE2: 7D 0B 7E LJMP  0x0B7E             
                                        (0115)     DISPATCHER USBUART_1_DT_h2d_cls_ifc, USBUART_1_DT_h2d_cls_ifc_Size, USBUART_1_Not_Supported_Local1
                                        (0116) 
                                        (0117) ;-----------------------------------------------------------------------------
                                        (0118) USBUART_1_DT_d2h_cls_ifc:
0AE5: 80 98    JMP   0x0B7E             (0119)     jmp     USBUART_1_Not_Supported_Local1		;00
0AE7: 80 78    JMP   0x0B60             (0120)     jmp     USBUART_1_CB_d2h_cls_ifc_01			;01
0AE9: 80 94    JMP   0x0B7E             (0121)     jmp     USBUART_1_Not_Supported_Local1		;02
0AEB: 80 92    JMP   0x0B7E             (0122)     jmp     USBUART_1_Not_Supported_Local1		;03
0AED: 80 90    JMP   0x0B7E             (0123)     jmp     USBUART_1_Not_Supported_Local1		;04
0AEF: 80 8E    JMP   0x0B7E             (0124)     jmp     USBUART_1_Not_Supported_Local1		;05
0AF1: 80 8C    JMP   0x0B7E             (0125)     jmp     USBUART_1_Not_Supported_Local1		;06
0AF3: 80 8A    JMP   0x0B7E             (0126)     jmp     USBUART_1_Not_Supported_Local1		;07
0AF5: 80 88    JMP   0x0B7E             (0127)     jmp     USBUART_1_Not_Supported_Local1		;08
0AF7: 80 86    JMP   0x0B7E             (0128)     jmp     USBUART_1_Not_Supported_Local1		;09
0AF9: 80 84    JMP   0x0B7E             (0129)     jmp     USBUART_1_Not_Supported_Local1		;0A
0AFB: 80 82    JMP   0x0B7E             (0130)     jmp     USBUART_1_Not_Supported_Local1		;0B
0AFD: 80 80    JMP   0x0B7E             (0131)     jmp     USBUART_1_Not_Supported_Local1		;0C
0AFF: 80 7E    JMP   0x0B7E             (0132)     jmp     USBUART_1_Not_Supported_Local1		;0D
0B01: 80 7C    JMP   0x0B7E             (0133)     jmp     USBUART_1_Not_Supported_Local1		;0E
0B03: 80 7A    JMP   0x0B7E             (0134)     jmp     USBUART_1_Not_Supported_Local1		;0F
0B05: 80 78    JMP   0x0B7E             (0135)     jmp     USBUART_1_Not_Supported_Local1		;10
0B07: 80 76    JMP   0x0B7E             (0136)     jmp     USBUART_1_Not_Supported_Local1		;11
0B09: 80 74    JMP   0x0B7E             (0137)     jmp     USBUART_1_Not_Supported_Local1		;12
0B0B: 80 72    JMP   0x0B7E             (0138)     jmp     USBUART_1_Not_Supported_Local1		;13
0B0D: 80 70    JMP   0x0B7E             (0139)     jmp     USBUART_1_Not_Supported_Local1		;14
0B0F: 80 6E    JMP   0x0B7E             (0140)     jmp     USBUART_1_Not_Supported_Local1		;15
0B11: 80 6C    JMP   0x0B7E             (0141)     jmp     USBUART_1_Not_Supported_Local1		;16
0B13: 80 6A    JMP   0x0B7E             (0142)     jmp     USBUART_1_Not_Supported_Local1		;17
0B15: 80 68    JMP   0x0B7E             (0143)     jmp     USBUART_1_Not_Supported_Local1		;18
0B17: 80 66    JMP   0x0B7E             (0144)     jmp     USBUART_1_Not_Supported_Local1		;19
0B19: 80 64    JMP   0x0B7E             (0145)     jmp     USBUART_1_Not_Supported_Local1		;1A
0B1B: 80 62    JMP   0x0B7E             (0146)     jmp     USBUART_1_Not_Supported_Local1		;1B
0B1D: 80 60    JMP   0x0B7E             (0147)     jmp     USBUART_1_Not_Supported_Local1		;1C
0B1F: 80 5E    JMP   0x0B7E             (0148)     jmp     USBUART_1_Not_Supported_Local1		;1D
0B21: 80 5C    JMP   0x0B7E             (0149)     jmp     USBUART_1_Not_Supported_Local1		;1E
0B23: 80 5A    JMP   0x0B7E             (0150)     jmp     USBUART_1_Not_Supported_Local1		;1F
0B25: 80 58    JMP   0x0B7E             (0151)     jmp     USBUART_1_Not_Supported_Local1		;20
0B27: 80 47    JMP   0x0B6F             (0152)     jmp     USBUART_1_CB_d2h_cls_ifc_21			;21
                                        (0153) USBUART_1_DT_d2h_cls_ifc_End:
                                        (0154) USBUART_1_DT_d2h_cls_ifc_Size: equ (USBUART_1_DT_d2h_cls_ifc_End-USBUART_1_DT_d2h_cls_ifc) / 2
                                        (0155) 
                                        (0156) USBUART_1_DT_d2h_cls_ifc_Dispatch::
0B29: 5D 59    MOV   A,REG[0x59]        (0157)     mov   A, REG[USBUART_1_EP0DATA + bRequest]       ; Get the request number
0B2B: 39 22    CMP   A,0x22             
0B2D: D0 04    JNC   0x0B32             
0B2F: 64       ASL   A                  
0B30: EF B4    JACC  0x0AE5             
0B32: 7D 0B 7E LJMP  0x0B7E             
                                        (0158)     DISPATCHER USBUART_1_DT_d2h_cls_ifc, USBUART_1_DT_d2h_cls_ifc_Size, USBUART_1_Not_Supported_Local1
                                        (0159) 
                                        (0160) ;-----------------------------------------------------------------------------
                                        (0161) ; FUNCTION NAME: USBUART_1_CB_h2d_cls_ifc_00
                                        (0162) ;-----------------------------------------------------------------------------
                                        (0163) ; CDC INTERFACE REQUEST: Send_Encapsulated_Command
                                        (0164) ;-----------------------------------------------------------------------------
                                        (0165) ; bmRequestType  : (H2D | CLASS | INTERFACE)      		= 21h
                                        (0166) ; bRequest       : SET_ENCAPSULATED_COMMAND		     	= 00h
                                        (0167) ; wValue         : Zero		                    		= 0000h
                                        (0168) ; wIndex         : INTERFACE                      		= --xxh
                                        (0169) ; wLength        : Amount of data, in bytes associated with recipient
                                        (0170) ; Data			 : Control protocol-based command (Dummy buffer)
                                        (0171) ;-----------------------------------------------------------------------------
                                        (0172) USBUART_1_CB_h2d_cls_ifc_00:
0B35: 5D 5C    MOV   A,REG[0x5C]        (0173)     mov   A, REG[USBUART_1_EP0DATA+wIndexLo] ; Get the interface number
0B37: 39 02    CMP   A,0x2              (0174)     cmp   A, 2                           ; Only for CDC interfaces (1 and 2)
0B39: D0 44    JNC   0x0B7E             (0175)     jnc   USBUART_1_Not_Supported_Local1
0B3B: 53 1F    MOV   [0x1F],A           (0176)     mov   [USBUART_1_t2], A                  ; Selector
0B3D: 50 0A    MOV   A,0xA              (0177)     mov   A,>GetSetEncapsulatedCommand   ; Get the ROM Address MSB
0B3F: 57 81    MOV   X,0x81             (0178)     mov   X,<GetSetEncapsulatedCommand   ; Get the ROM Address LSB
0B41: 7D 09 A0 LJMP  USBUART_1_GetTableEntry(0179)     ljmp   USBUART_1_GetTableEntry
                                        (0180) 
                                        (0181) ;-----------------------------------------------------------------------------
                                        (0182) ; FUNCTION NAME: USBUART_1_CB_h2d_cls_ifc_20
                                        (0183) ;-----------------------------------------------------------------------------
                                        (0184) ; CDC INTERFACE REQUEST: Set_Line_Coding
                                        (0185) ;-----------------------------------------------------------------------------
                                        (0186) ; bmRequestType  : (H2D | CLASS | INTERFACE)      		= 21h
                                        (0187) ; bRequest       : SET_LINE_CODING				     	= 20h
                                        (0188) ; wValue         : Zero		                    		= 0000h
                                        (0189) ; wIndex         : INTERFACE                      		= --xxh
                                        (0190) ; wLength        : Report Size                    		= 0007h
                                        (0191) ; Data			 : Line Coding Structure
                                        (0192) ;-----------------------------------------------------------------------------
                                        (0193) USBUART_1_CB_h2d_cls_ifc_20:
0B44: 5D 5C    MOV   A,REG[0x5C]        (0194)     mov   A, REG[USBUART_1_EP0DATA+wIndexLo] ; Get the interface number
0B46: 39 02    CMP   A,0x2              (0195)     cmp   A, 2                           ; Only for CDC interfaces (1 and 2)
0B48: D0 35    JNC   0x0B7E             (0196)     jnc   USBUART_1_Not_Supported_Local1
0B4A: 53 1F    MOV   [0x1F],A           (0197)     mov   [USBUART_1_t2], A                  ; Selector
0B4C: 50 0A    MOV   A,0xA              (0198)     mov   A,>GetSetLineCodingTable       ; Get the ROM Address MSB
0B4E: 57 8A    MOV   X,0x8A             (0199)     mov   X,<GetSetLineCodingTable       ; Get the ROM Address LSB
0B50: 7D 09 A0 LJMP  USBUART_1_GetTableEntry(0200)     ljmp   USBUART_1_GetTableEntry
                                        (0201) 
                                        (0202) ;-----------------------------------------------------------------------------
                                        (0203) ; FUNCTION NAME: USBUART_1_CB_h2d_cls_ifc_22
                                        (0204) ;-----------------------------------------------------------------------------
                                        (0205) ; CDC INTERFACE REQUEST: Set_Control_Line_State
                                        (0206) ;-----------------------------------------------------------------------------
                                        (0207) ; bmRequestType  : (H2D | CLASS | INTERFACE)      		= 21h
                                        (0208) ; bRequest       : SET_CONTROL_LINE_STATE		     	= 22h
                                        (0209) ; wValue         : Control Signal Bitmap           		= xxxxh
                                        (0210) ; wIndex         : INTERFACE                      		= --xxh
                                        (0211) ; wLength        : Report Size                    		= 0000h
                                        (0212) ; Data			 : Line Coding Structure
                                        (0213) ;-----------------------------------------------------------------------------
                                        (0214) USBUART_1_CB_h2d_cls_ifc_22:
0B53: 5D 5C    MOV   A,REG[0x5C]        (0215)     mov   A, REG[USBUART_1_EP0DATA+wIndexLo] ; Get the interface number
0B55: 39 02    CMP   A,0x2              (0216)     cmp   A, 2                           ; Only for CDC interfaces (1 and 2)
0B57: D0 26    JNC   0x0B7E             (0217)     jnc   USBUART_1_Not_Supported_Local1
0B59: 5D 5A    MOV   A,REG[0x5A]        (0218)     mov   A, REG[USBUART_1_EP0DATA+wValueLo] ; Get the bitmap
0B5B: 53 37    MOV   [0x37],A           (0219)     mov   [USBUART_1_LineControlBitmap+1], A
0B5D: 7D 08 8D LJMP  _USBUART_1_InitNoDataStageControlTransfer|USBUART_1_NoDataStageControlTransfer|USBUART_1_InitNoDataStageControlTransfer(0220)     ljmp   USBUART_1_NoDataStageControlTransfer
                                        (0221) 
                                        (0222) ;-----------------------------------------------------------------------------
                                        (0223) ;  FUNCTION NAME: USBUART_1_CB_d2h_cls_ifc_01
                                        (0224) ;-----------------------------------------------------------------------------
                                        (0225) ; CDC INTERFACE REQUEST: Get_Encapsulated_Response
                                        (0226) ;-----------------------------------------------------------------------------
                                        (0227) ; bmRequestType  : (D2H | CLASS | INTERFACE)      		= A1h
                                        (0228) ; bRequest       : GET_ENCAPSULATED_RESPONSE	     	= 01h
                                        (0229) ; wValue         : Zero		               				= 0000h
                                        (0230) ; wIndex         : INTERFACE                      		= --xxh
                                        (0231) ; wLength        : Amount of data, in bytes associated with recipient
                                        (0232) ; Data			 : Control protocol-based data (Dummy buffer)
                                        (0233) ;-----------------------------------------------------------------------------
                                        (0234) USBUART_1_CB_d2h_cls_ifc_01:
0B60: 5D 5C    MOV   A,REG[0x5C]        (0235)     mov   A, REG[USBUART_1_EP0DATA+wIndexLo] ; Get the interface number
0B62: 39 02    CMP   A,0x2              (0236)     cmp   A, 2                           ; Only for CDC interfaces (1 and 2)
0B64: D0 19    JNC   0x0B7E             (0237)     jnc   USBUART_1_Not_Supported_Local1
0B66: 53 1F    MOV   [0x1F],A           (0238)     mov   [USBUART_1_t2], A                  ; Selector
0B68: 50 0A    MOV   A,0xA              (0239)     mov   A,>GetSetEncapsulatedCommand   ; Get the ROM Address MSB
0B6A: 57 81    MOV   X,0x81             (0240)     mov   X,<GetSetEncapsulatedCommand   ; Get the ROM Address LSB
0B6C: 7D 09 A0 LJMP  USBUART_1_GetTableEntry(0241)     ljmp   USBUART_1_GetTableEntry
                                        (0242) 
                                        (0243) ;-----------------------------------------------------------------------------
                                        (0244) ;  FUNCTION NAME: USBUART_1_CB_d2h_cls_ifc_21
                                        (0245) ;-----------------------------------------------------------------------------
                                        (0246) ; CDC INTERFACE REQUEST: Get_Line_Coding
                                        (0247) ;-----------------------------------------------------------------------------
                                        (0248) ; bmRequestType  : (D2H | CLASS | INTERFACE)      		= A1h
                                        (0249) ; bRequest       : GET_LINE_CODING				     	= 21h
                                        (0250) ; wValue         : Zero		               				= 0000h
                                        (0251) ; wIndex         : INTERFACE                      		= --xxh
                                        (0252) ; wLength        : Report Size                    		= 0007h
                                        (0253) ; Data			 : Line Coding Structure
                                        (0254) ;
                                        (0255) ;-----------------------------------------------------------------------------
                                        (0256) USBUART_1_CB_d2h_cls_ifc_21:
                                        (0257) 
0B6F: 5D 5C    MOV   A,REG[0x5C]        (0258)     mov   A, REG[USBUART_1_EP0DATA+wIndexLo] ; Get the interface number
0B71: 39 02    CMP   A,0x2              (0259)     cmp   A, 2                           ; Only for CDC interfaces (1 and 2)
0B73: D0 0A    JNC   0x0B7E             (0260)     jnc   USBUART_1_Not_Supported_Local1
0B75: 53 1F    MOV   [0x1F],A           (0261)     mov   [USBUART_1_t2], A                  ; Selector
0B77: 50 0A    MOV   A,0xA              (0262)     mov   A,>GetSetLineCodingTable       ; Get the ROM Address MSB
0B79: 57 8A    MOV   X,0x8A             (0263)     mov   X,<GetSetLineCodingTable       ; Get the ROM Address LSB
0B7B: 7D 09 A0 LJMP  USBUART_1_GetTableEntry(0264)     ljmp   USBUART_1_GetTableEntry
                                        (0265) 
                                        (0266) ;-----------------------------------------------------------------------------
                                        (0267) ;  FUNCTION NAME: USBUART_1_Not_Supported_Local1
                                        (0268) ;-----------------------------------------------------------------------------
                                        (0269) ;  Handle requests that are not supported
                                        (0270) ;-----------------------------------------------------------------------------
                                        (0271) USBUART_1_Not_Supported_Local1:
0B7E: 7D 04 EE LJMP  _USBUART_1_Not_Supported|USBUART_1_CB_h2d_std_dev_08|USBUART_1_CB_h2d_std_dev_07|USBUART_1_CB_d2h_std_dev_07|USBUART_1_CB_h2d_std_dev_06|USBUART_1_CB_d2h_std_dev_05|USBUART_1_CB_h2d_std_dev_04|USBUART_1_CB_d2h_std_dev_04|USBUART_1_Not_Supported|...(0272) 	ljmp USBUART_1_Not_Supported
FILE: lib\usbuart_1.asm                 (0001) ;;*****************************************************************************
                                        (0002) ;;  FILENAME: USBUART_1.asm
0B96: 70 BF    AND   F,0xBF             (0003) ;;  Version: 1.40, Updated on 2011/3/29 at 14:31:18
0B98: 62 D3 00 MOV   REG[0xD3],0x0      
0B9B: 62 D0 00 MOV   REG[0xD0],0x0      
                                        (0004) ;;  Generated by PSoC Designer 5.1.2110.0
                                        (0005) ;;
                                        (0006) ;;  DESCRIPTION: USBUART User Module Descriptors
                                        (0007) ;;
                                        (0008) ;;  NOTE: User Module APIs conform to the fastcall convention for marshalling
                                        (0009) ;;        arguments and observe the associated "Registers are volatile" policy.
                                        (0010) ;;        This means it is the caller's responsibility to preserve any values
                                        (0011) ;;        in the X and A registers that are still needed after the API
                                        (0012) ;;        function returns. Even though these registers may be preserved now,
                                        (0013) ;;        there is no guarantee they will be preserved in future releases.
                                        (0014) ;;-----------------------------------------------------------------------------
                                        (0015) ;;  Copyright (c) Cypress Semiconductor 2011. All Rights Reserved.
                                        (0016) ;;*****************************************************************************
                                        (0017) ;;*****************************************************************************
                                        (0018) include "m8c.inc"
                                        (0019) include "m8ssc.inc"
                                        (0020) include "memory.inc"
                                        (0021) include "USBUART_1_macros.inc"
                                        (0022) include "USBUART_1.inc"
                                        (0023) 
                                        (0024) ;-----------------------------------------------
                                        (0025) ;  Global Symbols
                                        (0026) ;-----------------------------------------------
                                        (0027) EXPORT USBUART_1_Start
                                        (0028) EXPORT _USBUART_1_Start
                                        (0029) EXPORT USBUART_1_Stop
                                        (0030) EXPORT _USBUART_1_Stop
                                        (0031) EXPORT USBUART_1_Init
                                        (0032) EXPORT _USBUART_1_Init
                                        (0033) 
                                        (0034) EXPORT USBUART_1_Write
                                        (0035) EXPORT _USBUART_1_Write
                                        (0036) EXPORT _USBUART_1_CWrite
                                        (0037) EXPORT USBUART_1_CWrite
                                        (0038) EXPORT USBUART_1_PutString
                                        (0039) EXPORT _USBUART_1_PutString
                                        (0040) EXPORT USBUART_1_CPutString
                                        (0041) EXPORT _USBUART_1_CPutString
                                        (0042) EXPORT USBUART_1_PutChar
                                        (0043) EXPORT _USBUART_1_PutChar
                                        (0044) EXPORT USBUART_1_PutCRLF
                                        (0045) EXPORT _USBUART_1_PutCRLF
                                        (0046) EXPORT USBUART_1_PutSHexByte
                                        (0047) EXPORT _USBUART_1_PutSHexByte
                                        (0048) EXPORT USBUART_1_PutSHexInt
                                        (0049) EXPORT _USBUART_1_PutSHexInt
                                        (0050) 
                                        (0051) EXPORT USBUART_1_bGetRxCount
                                        (0052) EXPORT _USBUART_1_bGetRxCount
                                        (0053) EXPORT USBUART_1_bTxIsReady
                                        (0054) EXPORT _USBUART_1_bTxIsReady
                                        (0055) 
                                        (0056) EXPORT USBUART_1_Read
                                        (0057) EXPORT _USBUART_1_Read
                                        (0058) EXPORT USBUART_1_ReadAll
                                        (0059) EXPORT _USBUART_1_ReadAll
                                        (0060) EXPORT USBUART_1_ReadChar
                                        (0061) EXPORT _USBUART_1_ReadChar
                                        (0062) 
                                        (0063) EXPORT USBUART_1_dwGetDTERate
                                        (0064) EXPORT _USBUART_1_dwGetDTERate
                                        (0065) EXPORT USBUART_1_bGetCharFormat
                                        (0066) EXPORT _USBUART_1_bGetCharFormat
                                        (0067) EXPORT USBUART_1_bGetParityType
                                        (0068) EXPORT _USBUART_1_bGetParityType
                                        (0069) EXPORT USBUART_1_bGetDataBits
                                        (0070) EXPORT _USBUART_1_bGetDataBits
                                        (0071) EXPORT USBUART_1_bGetDataBits
                                        (0072) EXPORT _USBUART_1_bGetDataBits
                                        (0073) EXPORT USBUART_1_bGetLineControlBitmap
                                        (0074) EXPORT _USBUART_1_bGetLineControlBitmap
                                        (0075) EXPORT USBUART_1_SendStateNotify
                                        (0076) EXPORT _USBUART_1_SendStateNotify
                                        (0077) 
                                        (0078) EXPORT USBUART_1_bCheckUSBActivity
                                        (0079) EXPORT _USBUART_1_bCheckUSBActivity
                                        (0080) EXPORT USBUART_1_SetPowerStatus
                                        (0081) EXPORT _USBUART_1_SetPowerStatus
                                        (0082) 
                                        (0083) 
                                        (0084) AREA InterruptRAM (RAM,REL,CON)
                                        (0085) ;-----------------------------------------------
                                        (0086) ;  Variable Allocation
                                        (0087) ;-----------------------------------------------
                                        (0088) EXPORT USBUART_1_APITemp
                                        (0089)  USBUART_1_APITemp:                     BLK   2 ; Two bytes of temporary  storage shared by the API  functions
                                        (0090) 
                                        (0091) 
                                        (0092) AREA UserModules (ROM, REL)
                                        (0093) export USBUART_1_USB_EP_BIT_LOOKUP
                                        (0094) 
                                        (0095) .LITERAL
                                        (0096) USBUART_1_HEX_STR:
                                        (0097)      DS    "0123456789ABCDEF"
                                        (0098) USBUART_1_USB_EP_BIT_LOOKUP:  ;
                                        (0099)     DB     01H                       ; EP0
                                        (0100)     DB     02H                       ; EP1
                                        (0101)     DB     04H                       ; EP2
                                        (0102)     DB     08H                       ; EP3
                                        (0103)     DB     010H                      ; EP4
                                        (0104) .ENDLITERAL
                                        (0105) 
                                        (0106) .SECTION
                                        (0107) ;-----------------------------------------------------------------------------
                                        (0108) ;  FUNCTION NAME: USBUART_1_Start
                                        (0109) ;
                                        (0110) ;  DESCRIPTION:    Starts the USB User Module
                                        (0111) ;                    Sets the device selection
                                        (0112) ;                    Set the configuration to unconfigured
                                        (0113) ;                    Enables the SIE for Address 0
                                        (0114) ;                    Enables the USB pullup ( D+ for full speed)
                                        (0115) ;
                                        (0116) ;-----------------------------------------------------------------------------
                                        (0117) ;
                                        (0118) ;  ARGUMENTS:    A  is the operation voltage
                                        (0119) ;
                                        (0120) ;  RETURNS:		 Nothing
                                        (0121) ;
                                        (0122) ;  SIDE EFFECTS:
                                        (0123) ;    The A and X registers may be modified by this or future implementations
                                        (0124) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0125) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0126) ;    responsibility to preserve their values across calls to fastcall16
                                        (0127) ;    functions.
                                        (0128) ;
                                        (0129)  USBUART_1_Start:
                                        (0130) _USBUART_1_Start:
                                        (0131)     RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0132)     RAM_PROLOGUE RAM_USE_CLASS_3
                                        (0133) 
                                        (0134) IF (USBUART_1_bSerialNumberType & USBUART_1_SERIAL_AUTO)   ;if serial number automatic
                                        (0135)     push    A   ;save incoming parameter
                                        (0136) ;Generate the serial number
                                        (0137)     RAM_SETPAGE_CUR 0
                                        (0138)     RAM_SETPAGE_MVW 0
                                        (0139)     RAM_SETPAGE_MVR 0
                                        (0140)     mov     [bSSC_TABLE_TableId],0x00
                                        (0141)     SSC_Action(0x06)
                                        (0142)     ; the USBUART_1_SerialString is located in the InterruptROM area so it located on page 0.
                                        (0143)     mov     [bSSC_KEY1], <USBUART_1_SerialString ; prepare for mvi
                                        (0144)     mov     A, 26
                                        (0145)     mvi     [bSSC_KEY1], A ; string descriptor length 26 bytes
                                        (0146)     mov     A, 3
                                        (0147)     mvi     [bSSC_KEY1], A ; descriptor type 3 = string
                                        (0148)     mov     [bSSC_KEY1+1], bSSC_TABLE_TableId
                                        (0149)     mov     X, 6 ;loop for all 6 byes with S/N
                                        (0150) .SNCopyLoop:
                                        (0151)     mvi     A, [bSSC_KEY1+1] ;get S/N byte
                                        (0152)     push    A
                                        (0153)     asr     A ; select lower nibble
                                        (0154)     asr     A
                                        (0155)     asr     A
                                        (0156)     asr     A
                                        (0157)     and     A, 0x0F ; clear high bits
                                        (0158)     index   USBUART_1_HEX_STR ; get ASCII
                                        (0159)     mvi     [bSSC_KEY1], A ; save character
                                        (0160)     mov     A, 0
                                        (0161)     mvi     [bSSC_KEY1], A ; save 0x00 for Unicode high byte
                                        (0162)     pop     A
                                        (0163)     and     A, 0x0F ;clear high bits
                                        (0164)     index   USBUART_1_HEX_STR ; get ASCII
                                        (0165)     mvi     [bSSC_KEY1], A ; save character
                                        (0166)     mov     A, 0
                                        (0167)     mvi     [bSSC_KEY1], A ; save 0x00 for Unicode high byte
                                        (0168)     dec     X
                                        (0169)     jnz     .SNCopyLoop
                                        (0170)     pop     A   ;restore incoming parameter
                                        (0171) ENDIF
                                        (0172)     RAM_SETPAGE_IDX >USBUART_1_bCurrentDevice ; Set the IDX_PP to the right page
                                        (0173) 	RAM_SETPAGE_CUR >USBUART_1_bCurrentDevice ; Set the CUR_PP to the right page
                                        (0174) 
                                        (0175) ;Start User Module
0B9E: 55 00 00 MOV   [0x0],0x0          (0176)     mov     [USBUART_1_bCurrentDevice], 0 ; The app selects the desired device
                                        (0177) 
0BA1: 55 0B 00 MOV   [0xB],0x0          (0178)     mov     [USBUART_1_TransferType], USB_TRANS_STATE_IDLE ; Transaction Idle State
0BA4: 55 01 00 MOV   [0x1],0x0          (0179)     mov     [USBUART_1_Configuration], 0 ; Unconfigured
0BA7: 55 02 00 MOV   [0x2],0x0          (0180)     mov     [USBUART_1_DeviceStatus], 0; Clears device status
                                        (0181) 
0BAA: 55 1D 00 MOV   [0x1D],0x0         (0182)     mov     [USBUART_1_EPDataToggle], 0    ; Clear all EP data toggles
0BAD: 62 6C 00 MOV   REG[0x6C],0x0      (0183)     mov     reg[TMP_DR0], 0	           ; EP1 start address in PMA space
0BB0: 62 6D 40 MOV   REG[0x6D],0x40     (0184) 	mov     reg[TMP_DR1], 64              ; EP2 start address in PMA space
0BB3: 62 6E 80 MOV   REG[0x6E],0x80     (0185) 	mov     reg[TMP_DR2], 128             ; EP3 start address in PMA space
0BB6: 62 6F C0 MOV   REG[0x6F],0xC0     (0186) 	mov     reg[TMP_DR3], 192             ; EP4 start address in PMA space
                                        (0187) 
                                        (0188) ; Flow here to enable the SIE
0BB9: 62 4A 80 MOV   REG[0x4A],0x80     (0189)     mov     reg[USBUART_1_ADDR], USB_ADDR_ENABLE ; Enable Address 0
0BBC: 62 4B 00 MOV   REG[0x4B],0x0      (0190) 	mov     reg[USBUART_1_USBIO_CR0], USB_AUTO_DPDM
0BBF: 71 10    OR    F,0x10             
                                        (0191) 
                                        (0192)     M8C_SetBank1
0BC1: 60 C1    MOV   REG[0xC1],A        (0193) 	mov     reg[USBUART_1_USB_CR1], A
0BC3: 70 EF    AND   F,0xEF             
                                        (0194) 	M8C_SetBank0
0BC5: 62 56 03 MOV   REG[0x56],0x3      (0195)     mov     reg[USBUART_1_EP0MODE], USB_MODE_STALL_IN_OUT ; ACK Setup/Stall IN/OUT
0BC8: 43 DF 05 OR    REG[0xDF],0x5      
                                        (0196)     M8C_EnableIntMask USBUART_1_INT_REG, (USBUART_1_INT_RESET_MASK | USBUART_1_INT_EP0_MASK)
                                        (0197) 
                                        (0198) ;   Enable the pullup so we can start to rock and roll
0BCB: 62 4C 04 MOV   REG[0x4C],0x4      (0199)     mov     reg[USBUART_1_USBIO_CR1], USB_PULLUP_ENABLE ; Pullup D+
0BCE: 70 3F    AND   F,0x3F             
0BD0: 71 C0    OR    F,0xC0             
                                        (0200) 
                                        (0201)     RAM_EPILOGUE RAM_USE_CLASS_3
                                        (0202) 	RAM_EPILOGUE RAM_USE_CLASS_4
0BD2: 7F       RET                      (0203)     RET
0BD3: 62 D0 00 MOV   REG[0xD0],0x0      
                                        (0204) .ENDSECTION
                                        (0205) 
                                        (0206) .SECTION
                                        (0207) ;-----------------------------------------------------------------------------
                                        (0208) ;  FUNCTION NAME: USBUART_1_Stop
                                        (0209) ;
                                        (0210) ;  DESCRIPTION: Performs all necessary shutdown tasks required for the USBUART
                                        (0211) ;               User Module.
                                        (0212) ;
                                        (0213) ;-----------------------------------------------------------------------------
                                        (0214) ;
                                        (0215) ;  ARGUMENTS: None
                                        (0216) ;
                                        (0217) ;  RETURNS:   Nothing
                                        (0218) ;
                                        (0219) ;  SIDE EFFECTS:
                                        (0220) ;    The A and X registers may be modified by this or future implementations
                                        (0221) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0222) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0223) ;    responsibility to preserve their values across calls to fastcall16
                                        (0224) ;    functions.
                                        (0225) ;
                                        (0226)  USBUART_1_Stop:
                                        (0227) _USBUART_1_Stop:
                                        (0228)     RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0229) 	RAM_SETPAGE_CUR >USBUART_1_bCurrentDevice ; Set the CUR_PP to the right page
                                        (0230) 
0BD6: 55 00 00 MOV   [0x0],0x0          (0231)     mov     [USBUART_1_bCurrentDevice], 0 ; The app selects the desired device
                                        (0232) 
0BD9: 55 0B 00 MOV   [0xB],0x0          (0233)     mov     [USBUART_1_TransferType], USB_TRANS_STATE_IDLE ; Transaction Idle State
0BDC: 55 01 00 MOV   [0x1],0x0          (0234)     mov     [USBUART_1_Configuration], 0 ; Unconfigured
0BDF: 55 02 00 MOV   [0x2],0x0          (0235)     mov     [USBUART_1_DeviceStatus], 0; Clears device status
0BE2: 62 4A 00 MOV   REG[0x4A],0x0      (0236)     mov     reg[USBUART_1_ADDR], 0     ; Clear the address and Address 0
0BE5: 41 4C FB AND   REG[0x4C],0xFB     (0237) 	and     reg[USBUART_1_USBIO_CR1], ~USB_PULLUP_ENABLE ; Release D+
0BE8: 62 DF 00 MOV   REG[0xDF],0x0      (0238)     mov     reg[USBUART_1_INT_REG], 0x00 ; Enable the interrupt
                                        (0239) 
                                        (0240) 	RAM_EPILOGUE RAM_USE_CLASS_4
0BEB: 7F       RET                      (0241)     RET
0BEC: 71 10    OR    F,0x10             
                                        (0242) .ENDSECTION
                                        (0243) 
                                        (0244) .SECTION
                                        (0245) ;-----------------------------------------------------------------------------
                                        (0246) ;  FUNCTION NAME: USBUART_1_bCheckUSBActivity
                                        (0247) ;
                                        (0248) ;  DESCRIPTION: Checks for USB Bus Activity.
                                        (0249) ;
                                        (0250) ;-----------------------------------------------------------------------------
                                        (0251) ;
                                        (0252) ;  ARGUMENTS: Nothing
                                        (0253) ;
                                        (0254) ;  RETURNS:   A is a flag that indicates bus activity
                                        (0255) ;
                                        (0256) ;  SIDE EFFECTS: ;    The A and X registers may be modified by this or future implementations
                                        (0257) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0258) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0259) ;    responsibility to preserve their values across calls to fastcall16
                                        (0260) ;    functions.
                                        (0261) ;
                                        (0262)  USBUART_1_bCheckUSBActivity:
                                        (0263) _USBUART_1_bCheckUSBActivity:
                                        (0264)     RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0265)     M8C_SetBank1
0BEE: 5D C1    MOV   A,REG[0xC1]        (0266)     mov    A, reg[USBUART_1_USB_CR1]   ; USB Activity bit indicates activity
0BF0: 21 04    AND   A,0x4              (0267)     and    A, USB_BUS_ACTIVITY         ; Activity?
0BF2: A0 05    JZ    0x0BF8             (0268)     jz     .no_activity                ; Jump on no activity?
                                        (0269) ; Flow here on bus activity
0BF4: 50 01    MOV   A,0x1              (0270)     mov    A, 1                        ; Return true
0BF6: 80 03    JMP   0x0BFA             (0271)     jmp    .done
                                        (0272) ; Jump here on no activity
                                        (0273) .no_activity:
0BF8: 50 00    MOV   A,0x0              (0274)     mov    A, 0                        ; Return false
                                        (0275) ; Jump or flow here to clear the activity bit, then return
                                        (0276) .done:
0BFA: 41 C1 FB AND   REG[0xC1],0xFB     (0277)     and    reg[USBUART_1_USB_CR1], ~USB_BUS_ACTIVITY  ; Clear the activity flag
0BFD: 70 EF    AND   F,0xEF             
                                        (0278)     M8C_SetBank0
                                        (0279) 	RAM_EPILOGUE RAM_USE_CLASS_1
0BFF: 7F       RET                      (0280)     ret
0C00: 62 D0 00 MOV   REG[0xD0],0x0      
                                        (0281) .ENDSECTION
                                        (0282) 
                                        (0283) .SECTION
                                        (0284) ;-----------------------------------------------------------------------------
                                        (0285) ;  FUNCTION NAME: USBUART_1_bGetRxCount
                                        (0286) ;
                                        (0287) ;  DESCRIPTION: This function returns the number of bytes that were received
                                        (0288) ;               from the PC and are waiting in the RX buffer.
                                        (0289) ;
                                        (0290) ;-----------------------------------------------------------------------------
                                        (0291) ;
                                        (0292) ;  ARGUMENTS:
                                        (0293) ;	none
                                        (0294) ;
                                        (0295) ;  RETURNS:
                                        (0296) ;	If RX associated endpoint has EVENT_PENDING status return ()in A register) the values stored in the
                                        (0297) ;  	Count registers of the Endpoint; otherwise return zero.
                                        (0298) ;
                                        (0299) ;  SIDE EFFECTS:
                                        (0300) ;    The A and X registers may be modified by this or future implementations
                                        (0301) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0302) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0303) ;    responsibility to preserve their values across calls to fastcall16
                                        (0304) ;    functions.
                                        (0305) ;
                                        (0306)  USBUART_1_bGetRxCount:
                                        (0307) _USBUART_1_bGetRxCount:
                                        (0308)     RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0309) 	RAM_SETPAGE_CUR >USBUART_1_EndpointAPIStatus ; Set the IDX_PP to the right page
0C03: 51 25    MOV   A,[0x25]           (0310) 	mov     A, [USBUART_1_EndpointAPIStatus+3]	; Get the state
0C05: 39 01    CMP   A,0x1              (0311) 	cmp 	A, EVENT_PENDING
0C07: A0 05    JZ    0x0C0D             (0312) 	jz		.ev_pending
0C09: 50 00    MOV   A,0x0              (0313) 	mov		A, 0
0C0B: 80 21    JMP   0x0C2D             (0314) 	jmp		.exit
                                        (0315) .ev_pending:
0C0D: 5D 53    MOV   A,REG[0x53]        (0316)     mov     A, reg[USBUART_1_EP3CNT0]  ; Here is the count
0C0F: 11 02    SUB   A,0x2              (0317) 	sub		A, 2
0C11: 39 00    CMP   A,0x0              (0318)     cmp     A, 0 ; check if event pending but no data to receive. This happens sometimes on XP SP3.
0C13: B0 19    JNZ   0x0C2D             (0319)     jnz     .exit	
                                        (0320)     ; Clear and re-enable endpoint after receive zero length data
0C15: 55 25 00 MOV   [0x25],0x0         (0321) 	mov     [USBUART_1_EndpointAPIStatus+3], NO_EVENT_PENDING ; For the API
0C18: 62 53 40 MOV   REG[0x53],0x40     (0322) 	mov     reg[USBUART_1_EP3CNT0], 64
0C1B: 71 10    OR    F,0x10             
                                        (0323) 	M8C_SetBank1
0C1D: 62 6E 80 MOV   REG[0x6E],0x80     (0324) 	mov		reg[TMP_DR2], 128
0C20: 5D 6E    MOV   A,REG[0x6E]        (0325)     mov     A, reg[TMP_DR2]
0C22: 60 43    MOV   REG[0x43],A        (0326) 	mov     reg[PMA3_WA], A
0C24: 5D C6    MOV   A,REG[0xC6]        (0327)     mov     A, reg[USBUART_1_EP3MODE]  ; Unlock the mode register
0C26: 62 C6 09 MOV   REG[0xC6],0x9      (0328)     mov     reg[USBUART_1_EP3MODE], USB_MODE_ACK_OUT ; Enable the endpoint
0C29: 50 00    MOV   A,0x0              (0329) 	mov 	A, 0;	; No error and no bytes left in EP
0C2B: 70 EF    AND   F,0xEF             
                                        (0330)     M8C_SetBank0
                                        (0331) ; Jump or flow here for a common exit
                                        (0332) .exit:
                                        (0333)     RAM_EPILOGUE RAM_USE_CLASS_4
0C2D: 7F       RET                      (0334)     ret
                                        (0335) .ENDSECTION
                                        (0336) 
                                        (0337) .SECTION
                                        (0338) ;-----------------------------------------------------------------------------
                                        (0339) ;  FUNCTION NAME: USBUART_1_Write,  USBUART_1_CWrite
                                        (0340) ;
                                        (0341) ;  DESCRIPTION:    Send specified numbers of data
                                        (0342) ;
                                        (0343) ;-----------------------------------------------------------------------------
                                        (0344) ;
                                        (0345) ;  ARGUMENTS:
                                        (0346) ;     [SP-6] Count to send
                                        (0347) ;     [SP-5] MSB of data array address
                                        (0348) ;     [SP-4] LSB of data array address
                                        (0349) ;
                                        (0350) ;  RETURNS:
                                        (0351) ;     none
                                        (0352) ;
                                        (0353) ;  SIDE EFFECTS:
                                        (0354) ;    The A and X registers may be modified by this or future implementations
                                        (0355) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0356) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0357) ;    responsibility to preserve their values across calls to fastcall16
                                        (0358) ;    functions.
                                        (0359) ;
                                        (0360) ;    Currently only the page pointer registers listed below are modified:
                                        (0361) ;          CUR_PP
                                        (0362) ;          IDX_PP
                                        (0363) ;
                                        (0364) MEM_TYPE:	equ -1
                                        (0365) ; -2 and -3 is the return address to caller
                                        (0366) DATA_LSB:   equ -4           ; LSB pointer of data
                                        (0367) DATA_MSB:   equ -5           ; MSB pointer of data
                                        (0368) CNTLEN: equ -6			 ; Length of data to send
                                        (0369) 
                                        (0370)  USBUART_1_CWrite:
                                        (0371) _USBUART_1_CWrite:
0C2E: 50 01    MOV   A,0x1              (0372) 	mov		A, 1 ;Set MEM_TYPE
0C30: 08       PUSH  A                  (0373) 	push	A
0C31: 80 04    JMP   0x0C36             (0374) 	jmp		USBUART_1_Write_Start
                                        (0375)  USBUART_1_Write:
                                        (0376) _USBUART_1_Write:
0C33: 50 00    MOV   A,0x0              (0377) 	mov		A, 0 ;Set MEM_TYPE
0C35: 08       PUSH  A                  (0378) 	push	A
0C36: 70 BF    AND   F,0xBF             
0C38: 62 D0 00 MOV   REG[0xD0],0x0      
0C3B: 62 D3 03 MOV   REG[0xD3],0x3      
                                        (0379) USBUART_1_Write_Start:
                                        (0380)     RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0381)     RAM_PROLOGUE RAM_USE_CLASS_3
                                        (0382) 	RAM_SETPAGE_CUR >USBUART_1_bCurrentDevice ; Set the CUR_PP to the right page
                                        (0383)     RAM_SETPAGE_IDX2STK
                                        (0384)     ;Should we toggle the data bit??
                                        (0385)     ;SET THE COUNT AND TOGGLE
0C3E: 4F       MOV   X,SP               (0386) 	mov     X, SP
0C3F: 52 FA    MOV   A,[X-6]            (0387) 	mov     A, [X+CNTLEN]                 ; Get the Count
0C41: 53 38    MOV   [0x38],A           (0388) 	mov     [USBUART_1_APITemp], A        ; Save the count
                                        (0389) 
0C43: 50 04    MOV   A,0x4              (0390)     mov     A, 04h                     ; EP2
0C45: 34 1D    XOR   [0x1D],A           (0391) 	xor     [USBUART_1_EPDataToggle], A
0C47: 22 1D    AND   A,[0x1D]           (0392)     and     A, [USBUART_1_EPDataToggle]
0C49: A0 06    JZ    0x0C50             (0393)     jz      .toggle0
                                        (0394) 
0C4B: 55 39 80 MOV   [0x39],0x80        (0395)     mov      [USBUART_1_APITemp+1], USB_CNT_TOGGLE ; Set the data toggle
0C4E: 80 04    JMP   0x0C53             (0396)     jmp     .toggle_done
                                        (0397) 
                                        (0398) .toggle0:
0C50: 55 39 00 MOV   [0x39],0x0         (0399)     mov     [USBUART_1_APITemp+1], 0
                                        (0400) 
                                        (0401) .toggle_done:
0C53: 52 FA    MOV   A,[X-6]            (0402) 	mov     A, [X+CNTLEN]                  ;Get count
0C55: 60 51    MOV   REG[0x51],A        (0403)     mov     reg[USBUART_1_EP2CNT0], A   ; Write it into the register
0C57: 51 39    MOV   A,[0x39]           (0404)     mov     A, [USBUART_1_APITemp+1]    ; Retrieve the saved toggle
0C59: 60 50    MOV   REG[0x50],A        (0405) 	mov     reg[USBUART_1_EP2CNT1], A      ; Write it into the register
0C5B: 71 10    OR    F,0x10             
                                        (0406) 
                                        (0407) ; It's Time to move the data
                                        (0408) ; First we need to determine where, within the PMA, the EP Start Address is
                                        (0409)    M8C_SetBank1
0C5D: 5D 6D    MOV   A,REG[0x6D]        (0410)    mov   A, reg[TMP_DR1]                ; Get the address of ep from tmp register
0C5F: 49 F7 01 TST   REG[0xF7],0x1      (0411)    tst   reg[CPU_F], 0x01
0C62: A0 09    JZ    0x0C6C             (0412)    jz    .DontTouchGIE1
0C64: 70 FE    AND   F,0xFE             
                                        (0413)    M8C_DisableGInt
0C66: 60 40    MOV   REG[0x40],A        (0414)    mov   reg[PMA0_WA], A                ; Set the Write pointer of our pma to ep space
0C68: 71 01    OR    F,0x1              
                                        (0415)    M8C_EnableGInt
0C6A: 80 03    JMP   0x0C6E             (0416)    jmp   .Continue1
                                        (0417) .DontTouchGIE1:
0C6C: 60 40    MOV   REG[0x40],A        (0418)    mov   reg[PMA0_WA], A                ; Set the Write pointer of our pma to ep space
0C6E: 70 EF    AND   F,0xEF             
                                        (0419) .Continue1:
                                        (0420) 	M8C_SetBank0
                                        (0421) 
                                        (0422) ; Now we are y to start moving data
0C70: 52 FA    MOV   A,[X-6]            (0423) 	mov     A, [X+CNTLEN]                  ; Check the count
0C72: A0 2C    JZ    0x0C9F             (0424) 	jz      .done                          ; If it is 0 then we have a 0 length packet
                                        (0425) 
0C74: 2F FF 00 OR    [X-1],0x0          (0426) 	or	 	[X+MEM_TYPE], 0
0C77: B0 14    JNZ   0x0C8C             (0427) 	jnz		.start_send_rom
                                        (0428) 
0C79: 52 FC    MOV   A,[X-4]            (0429) 	mov     A, [X+DATA_LSB]
0C7B: 08       PUSH  A                  (0430) 	push    A
                                        (0431) IF SYSTEM_LARGE_MEMORY_MODEL
0C7C: 52 FB    MOV   A,[X-5]            (0432) 	mov     A, [X+DATA_MSB]
0C7E: 60 D3    MOV   REG[0xD3],A        (0433) 	mov     reg[IDX_PP], A
                                        (0434) ENDIF
0C80: 20       POP   X                  (0435) 	pop     X
                                        (0436) 
                                        (0437) .loop_ram:
0C81: 52 00    MOV   A,[X+0]            (0438) 	mov		A, [X]
0C83: 60 40    MOV   REG[0x40],A        (0439) 	mov     reg[PMA0_DR], A
0C85: 75       INC   X                  (0440) 	inc     X
0C86: 7A 38    DEC   [0x38]             (0441) 	dec     [USBUART_1_APITemp]
0C88: BF F8    JNZ   0x0C81             (0442) 	jnz     .loop_ram
0C8A: 80 14    JMP   0x0C9F             (0443) 	jmp 	.done
                                        (0444) 
                                        (0445) .start_send_rom:
0C8C: 52 FB    MOV   A,[X-5]            (0446) 	mov     A, [X+DATA_MSB]
0C8E: 53 39    MOV   [0x39],A           (0447) 	mov		[USBUART_1_APITemp+1], A
0C90: 59 FC    MOV   X,[X-4]            (0448) 	mov     X, [X+DATA_LSB]
                                        (0449) 
                                        (0450) .loop_rom:
0C92: 28       ROMX                     (0451) 	romx
0C93: 60 40    MOV   REG[0x40],A        (0452) 	mov     reg[PMA0_DR], A
                                        (0453) 
0C95: 75       INC   X                  (0454) 	inc     X	;go next address
0C96: 0E 39 00 ADC   [0x39],0x0         (0455) 	adc		[USBUART_1_APITemp+1], 0 ; don't forget carry
0C99: 51 39    MOV   A,[0x39]           (0456) 	mov 	A, [USBUART_1_APITemp+1] ; prepare MSB of address
                                        (0457) 
0C9B: 7A 38    DEC   [0x38]             (0458) 	dec     [USBUART_1_APITemp]
0C9D: BF F4    JNZ   0x0C92             (0459) 	jnz     .loop_rom
                                        (0460) 
                                        (0461) .done:
0C9F: 55 24 00 MOV   [0x24],0x0         (0462)     mov     [USBUART_1_EndpointAPIStatus+2], NO_EVENT_PENDING ; Set the state
0CA2: 71 10    OR    F,0x10             
                                        (0463) 
                                        (0464)    M8C_SetBank1
0CA4: 5D 6D    MOV   A,REG[0x6D]        (0465)    mov   A, reg[TMP_DR1]               ; Get the value of the PMA start Address
0CA6: 49 F7 01 TST   REG[0xF7],0x1      (0466)    tst   reg[CPU_F], 0x01
0CA9: A0 09    JZ    0x0CB3             (0467)    jz    .DontTouchGIE2
0CAB: 70 FE    AND   F,0xFE             
                                        (0468)    M8C_DisableGInt
0CAD: 60 52    MOV   REG[0x52],A        (0469)    mov   reg[PMA0_RA+2], A             ; Load it into EP PMA so pre-fetch occurs
0CAF: 71 01    OR    F,0x1              
                                        (0470)    M8C_EnableGInt
0CB1: 80 03    JMP   0x0CB5             (0471)    jmp   .Continue2
                                        (0472) .DontTouchGIE2:
0CB3: 60 52    MOV   REG[0x52],A        (0473)    mov   reg[PMA0_RA+2], A             ; Load it into EP PMA so pre-fetch occurs
                                        (0474) .Continue2:
0CB5: 62 C5 0D MOV   REG[0xC5],0xD      (0475)    mov   reg[USBUART_1_EP2MODE], USB_MODE_ACK_IN ; Enable the endpoint
0CB8: 70 EF    AND   F,0xEF             
                                        (0476) 	M8C_SetBank0
                                        (0477) 
0CBA: 18       POP   A                  (0478) 	pop 	A ; Clean up MEM_TYPE
0CBB: 70 3F    AND   F,0x3F             
0CBD: 71 C0    OR    F,0xC0             
                                        (0479)     RAM_EPILOGUE RAM_USE_CLASS_3
                                        (0480) 	RAM_EPILOGUE RAM_USE_CLASS_4
0CBF: 7F       RET                      (0481)     ret
0CC0: 70 BF    AND   F,0xBF             
0CC2: 62 D0 00 MOV   REG[0xD0],0x0      
                                        (0482) .ENDSECTION
                                        (0483) 
                                        (0484) .SECTION
                                        (0485) ;-----------------------------------------------------------------------------
                                        (0486) ;  FUNCTION NAME: USBUART_1_PutString
                                        (0487) ;
                                        (0488) ;  DESCRIPTION:    Send NULL terminated string
                                        (0489) ;
                                        (0490) ;-----------------------------------------------------------------------------
                                        (0491) ;
                                        (0492) ;  ARGUMENTS:
                                        (0493) ;     A contains MSB of the string pointer
                                        (0494) ;     X contains LSB of the string pointer
                                        (0495) ;
                                        (0496) ;  RETURNS:
                                        (0497) ;     none
                                        (0498) ;
                                        (0499) ;  SIDE EFFECTS:
                                        (0500) ;    The A and X registers may be modified by this or future implementations
                                        (0501) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0502) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0503) ;    responsibility to preserve their values across calls to fastcall16
                                        (0504) ;    functions.
                                        (0505) ;
                                        (0506) ;    Currently only the page pointer registers listed below are modified:
                                        (0507) ;          CUR_PP
                                        (0508) ;          IDX_PP
                                        (0509) ;
                                        (0510) 
                                        (0511)  USBUART_1_PutString:
                                        (0512) _USBUART_1_PutString:
                                        (0513)     RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0514)     RAM_PROLOGUE RAM_USE_CLASS_3
                                        (0515) 	RAM_SETPAGE_CUR >USBUART_1_APITemp    ; Set the CUR_PP to the right page
0CC5: 08       PUSH  A                  (0516) 	push	A
0CC6: 08       PUSH  A                  (0517) 	push	A	;put MSB of dataPtr  - prepare to Write call
0CC7: 10       PUSH  X                  (0518) 	push	X	;put LSB of dataPtr - prepare to Write call
                                        (0519) IF SYSTEM_LARGE_MEMORY_MODEL
0CC8: 60 D3    MOV   REG[0xD3],A        (0520) 	mov     reg[IDX_PP], A
                                        (0521) ENDIF
0CCA: 55 38 00 MOV   [0x38],0x0         (0522) 	mov		[USBUART_1_APITemp], 0; init the length counter
                                        (0523) .loop:
0CCD: 52 00    MOV   A,[X+0]            (0524) 	mov		A, [X]
0CCF: A0 06    JZ    0x0CD6             (0525) 	jz		.done
0CD1: 75       INC   X                  (0526) 	inc		X
0CD2: 76 38    INC   [0x38]             (0527) 	inc		[USBUART_1_APITemp]
0CD4: 8F F8    JMP   0x0CCD             (0528) 	jmp		.loop
0CD6: 62 D3 03 MOV   REG[0xD3],0x3      
                                        (0529) .done:
                                        (0530)     RAM_SETPAGE_IDX2STK
0CD9: 51 38    MOV   A,[0x38]           (0531) 	mov		A, [USBUART_1_APITemp]
0CDB: 4F       MOV   X,SP               (0532) 	mov		X, SP
0CDC: 54 FD    MOV   [X-3],A            (0533) 	mov 	[X-3], A
0CDE: 7C 0C 33 LCALL _USBUART_1_Write   (0534) 	lcall 	USBUART_1_Write
0CE1: 38 FD    ADD   SP,0xFD            (0535) 	add		SP, 253
0CE3: 70 3F    AND   F,0x3F             
0CE5: 71 C0    OR    F,0xC0             
                                        (0536)     RAM_EPILOGUE RAM_USE_CLASS_3
                                        (0537) 	RAM_EPILOGUE RAM_USE_CLASS_4
0CE7: 7F       RET                      (0538)     ret
0CE8: 70 BF    AND   F,0xBF             
0CEA: 62 D0 00 MOV   REG[0xD0],0x0      
0CED: 62 D3 03 MOV   REG[0xD3],0x3      
                                        (0539) .ENDSECTION
                                        (0540) 
                                        (0541) .SECTION
                                        (0542) ;-----------------------------------------------------------------------------
                                        (0543) ;  FUNCTION NAME: USBUART_1_CPutString
                                        (0544) ;
                                        (0545) ;  DESCRIPTION:    Send NULL terminated string ROM located string
                                        (0546) ;
                                        (0547) ;-----------------------------------------------------------------------------
                                        (0548) ;
                                        (0549) ;  ARGUMENTS:
                                        (0550) ;     A contains MSB of the string pointer
                                        (0551) ;     X contains LSB of the string pointer
                                        (0552) ;
                                        (0553) ;  RETURNS:
                                        (0554) ;     none
                                        (0555) ;
                                        (0556) ;  SIDE EFFECTS:
                                        (0557) ;    The A and X registers may be modified by this or future implementations
                                        (0558) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0559) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0560) ;    responsibility to preserve their values across calls to fastcall16
                                        (0561) ;    functions.
                                        (0562) ;
                                        (0563) ;    Currently only the page pointer registers listed below are modified:
                                        (0564) ;          CUR_PP
                                        (0565) ;          IDX_PP
                                        (0566) ;
                                        (0567) 
                                        (0568)  USBUART_1_CPutString:
                                        (0569) _USBUART_1_CPutString:
                                        (0570)     RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0571)     RAM_PROLOGUE RAM_USE_CLASS_3
                                        (0572) 	RAM_SETPAGE_CUR >USBUART_1_APITemp    ; Set the CUR_PP to the right page
                                        (0573) 	RAM_SETPAGE_IDX2STK
0CF0: 08       PUSH  A                  (0574) 	push	A	;reserve placeholder for count - prepare to Write call
0CF1: 08       PUSH  A                  (0575) 	push	A	;put MSB of dataPtr  - prepare to Write call
0CF2: 10       PUSH  X                  (0576) 	push	X	;put LSB of dataPtr - prepare to Write call
0CF3: 55 38 00 MOV   [0x38],0x0         (0577) 	mov		[USBUART_1_APITemp], 0	; init the length counter
0CF6: 53 39    MOV   [0x39],A           (0578) 	mov		[USBUART_1_APITemp+1], A	; store the pointer MSB
                                        (0579) .loop:
0CF8: 28       ROMX                     (0580) 	romx
0CF9: A0 0B    JZ    0x0D05             (0581) 	jz		.done
0CFB: 75       INC   X                  (0582) 	inc		X	;increment pointer LSB
0CFC: 0E 39 00 ADC   [0x39],0x0         (0583) 	adc 	[USBUART_1_APITemp+1],0 ;don't forget carry
0CFF: 76 38    INC   [0x38]             (0584) 	inc		[USBUART_1_APITemp]	;increment counter
0D01: 51 39    MOV   A,[0x39]           (0585) 	mov 	A, [USBUART_1_APITemp+1]	;load MSB into A - prepare address for romx
0D03: 8F F4    JMP   0x0CF8             (0586) 	jmp		.loop
                                        (0587) .done:
0D05: 51 38    MOV   A,[0x38]           (0588) 	mov		A, [USBUART_1_APITemp]
0D07: 4F       MOV   X,SP               (0589) 	mov		X, SP
0D08: 54 FD    MOV   [X-3],A            (0590) 	mov 	[X-3], A
0D0A: 7C 0C 2E LCALL _USBUART_1_CWrite  (0591) 	lcall 	USBUART_1_CWrite
0D0D: 38 FD    ADD   SP,0xFD            (0592) 	add		SP, 253
0D0F: 70 3F    AND   F,0x3F             
0D11: 71 C0    OR    F,0xC0             
                                        (0593)     RAM_EPILOGUE RAM_USE_CLASS_3
                                        (0594) 	RAM_EPILOGUE RAM_USE_CLASS_4
0D13: 7F       RET                      (0595)     ret
                                        (0596) .ENDSECTION
                                        (0597) 
                                        (0598) .SECTION
                                        (0599) ;-----------------------------------------------------------------------------
                                        (0600) ;  FUNCTION NAME: USBUART_1_PutChar
                                        (0601) ;
                                        (0602) ;  DESCRIPTION:    Send one character
                                        (0603) ;
                                        (0604) ;-----------------------------------------------------------------------------
                                        (0605) ;
                                        (0606) ;  ARGUMENTS:
                                        (0607) ;     A contains character to send
                                        (0608) ;
                                        (0609) ;  RETURNS:
                                        (0610) ;     none
                                        (0611) ;
                                        (0612) ;  SIDE EFFECTS:
                                        (0613) ;    The A and X registers may be modified by this or future implementations
                                        (0614) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0615) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0616) ;    responsibility to preserve their values across calls to fastcall16
                                        (0617) ;    functions.
                                        (0618) ;
                                        (0619) 
                                        (0620)  USBUART_1_PutChar:
                                        (0621) _USBUART_1_PutChar:
                                        (0622)     RAM_PROLOGUE RAM_USE_CLASS_1
0D14: 08       PUSH  A                  (0623) 	push 	A	;save character in stack
0D15: 50 01    MOV   A,0x1              (0624) 	mov 	A, 1;	set 1 byte to transfer
0D17: 08       PUSH  A                  (0625) 	push	A
                                        (0626) IF ( SYSTEM_LARGE_MEMORY_MODEL )
0D18: 5D D1    MOV   A,REG[0xD1]        (0627)     mov   	A, reg[STK_PP]
                                        (0628) ELSE
                                        (0629) 	mov 	A, 0
                                        (0630) ENDIF
0D1A: 08       PUSH  A                  (0631) 	push	A	;put MSB of dataPtr  - prepare to Write call
0D1B: 4F       MOV   X,SP               (0632) 	mov 	X, SP
0D1C: 5B       MOV   A,X                (0633) 	mov		A, X
0D1D: 11 03    SUB   A,0x3              (0634) 	sub 	A, 3
0D1F: 08       PUSH  A                  (0635) 	push	A	;put LSB of dataPtr - prepare to Write call
0D20: 7C 0C 33 LCALL _USBUART_1_Write   (0636) 	lcall 	USBUART_1_Write
0D23: 38 FC    ADD   SP,0xFC            (0637) 	add		SP, 252
                                        (0638) 	RAM_EPILOGUE RAM_USE_CLASS_1
0D25: 7F       RET                      (0639)     ret
                                        (0640) .ENDSECTION
                                        (0641) 
                                        (0642) .SECTION
                                        (0643) ;-----------------------------------------------------------------------------
                                        (0644) ;  FUNCTION NAME: USBUART_1_PutCRLF
                                        (0645) ;
                                        (0646) ;  DESCRIPTION:    Send one character
                                        (0647) ;
                                        (0648) ;-----------------------------------------------------------------------------
                                        (0649) ;
                                        (0650) ;  ARGUMENTS:
                                        (0651) ;     none
                                        (0652) ;
                                        (0653) ;  RETURNS:
                                        (0654) ;     none
                                        (0655) ;
                                        (0656) ;  SIDE EFFECTS:
                                        (0657) ;    The A and X registers may be modified by this or future implementations
                                        (0658) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0659) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0660) ;    responsibility to preserve their values across calls to fastcall16
                                        (0661) ;    functions.
                                        (0662) ;
                                        (0663) 
                                        (0664)  USBUART_1_PutCRLF:
                                        (0665) _USBUART_1_PutCRLF:
                                        (0666)     RAM_PROLOGUE RAM_USE_CLASS_1
0D26: 50 0D    MOV   A,0xD              (0667) 	mov 	A, 0Dh
0D28: 08       PUSH  A                  (0668) 	push 	A	;save character in stack
0D29: 50 0A    MOV   A,0xA              (0669) 	mov 	A, 0Ah
0D2B: 08       PUSH  A                  (0670) 	push 	A	;save character in stack
0D2C: 50 02    MOV   A,0x2              (0671) 	mov 	A, 2;	set 2 byte to transfer
0D2E: 08       PUSH  A                  (0672) 	push	A
                                        (0673) IF ( SYSTEM_LARGE_MEMORY_MODEL )
0D2F: 5D D1    MOV   A,REG[0xD1]        (0674)     mov   	A, reg[STK_PP]
                                        (0675) ELSE
                                        (0676) 	mov 	A, 0
                                        (0677) ENDIF
0D31: 08       PUSH  A                  (0678) 	push	A	;put MSB of dataPtr  - prepare to Write call
0D32: 4F       MOV   X,SP               (0679) 	mov 	X, SP
0D33: 5B       MOV   A,X                (0680) 	mov		A, X
0D34: 11 04    SUB   A,0x4              (0681) 	sub 	A, 4
0D36: 08       PUSH  A                  (0682) 	push	A	;put LSB of dataPtr - prepare to Write call
0D37: 7C 0C 33 LCALL _USBUART_1_Write   (0683) 	lcall 	USBUART_1_Write
0D3A: 38 FB    ADD   SP,0xFB            (0684) 	add		SP, 251
                                        (0685) 	RAM_EPILOGUE RAM_USE_CLASS_1
0D3C: 7F       RET                      (0686)     ret
                                        (0687) .ENDSECTION
                                        (0688) 
                                        (0689) .SECTION
                                        (0690) ;-----------------------------------------------------------------------------
                                        (0691) ;  FUNCTION NAME: USBUART_1_PutSHexByte
                                        (0692) ;
                                        (0693) ;  DESCRIPTION:    Print a byte in Hex (two byte) representation to the USBUART
                                        (0694) ;
                                        (0695) ;-----------------------------------------------------------------------------
                                        (0696) ;
                                        (0697) ;  ARGUMENTS:
                                        (0698) ;     A contains byte to send
                                        (0699) ;
                                        (0700) ;  RETURNS:
                                        (0701) ;     none
                                        (0702) ;
                                        (0703) ;  SIDE EFFECTS:
                                        (0704) ;    The A and X registers may be modified by this or future implementations
                                        (0705) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0706) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0707) ;    responsibility to preserve their values across calls to fastcall16
                                        (0708) ;    functions.
                                        (0709) ;
                                        (0710)  USBUART_1_PutSHexByte:
                                        (0711) _USBUART_1_PutSHexByte:
                                        (0712)     RAM_PROLOGUE RAM_USE_CLASS_1
0D3D: 5C       MOV   X,A                (0713) 	mov 	X, A	; Save lower nibble
0D3E: 67       ASR   A                  (0714) 	asr		A   ; Shift high nibble to right
0D3F: 67       ASR   A                  (0715) 	asr		A
0D40: 67       ASR   A                  (0716) 	asr		A
0D41: 67       ASR   A                  (0717) 	asr		A
0D42: 21 0F    AND   A,0xF              (0718) 	and		A,0Fh	; Mask off nibble
0D44: FE 3B    INDEX 0x0B81             (0719) 	index USBUART_1_HEX_STR;  Get Hex value
0D46: 08       PUSH  A                  (0720) 	push 	A
0D47: 5B       MOV   A,X                (0721) 	mov		A, X
0D48: 21 0F    AND   A,0xF              (0722) 	and   	A,0Fh	; Mask off lower nibble
0D4A: FE 35    INDEX 0x0B81             (0723) 	index USBUART_1_HEX_STR	; Get Hex value
0D4C: 08       PUSH  A                  (0724) 	push	A
0D4D: 50 02    MOV   A,0x2              (0725) 	mov		A, 2	; 2 bytes to transfer
0D4F: 08       PUSH  A                  (0726) 	push	A
                                        (0727) IF ( SYSTEM_LARGE_MEMORY_MODEL )
0D50: 5D D1    MOV   A,REG[0xD1]        (0728)     mov   	A, reg[STK_PP]
                                        (0729) ELSE
                                        (0730) 	mov 	A, 0
                                        (0731) ENDIF
0D52: 08       PUSH  A                  (0732) 	push	A	;put MSB of dataPtr  - prepare to Write call
0D53: 4F       MOV   X,SP               (0733) 	mov 	X, SP
0D54: 5B       MOV   A,X                (0734) 	mov		A, X
0D55: 11 04    SUB   A,0x4              (0735) 	sub 	A, 4
0D57: 08       PUSH  A                  (0736) 	push	A	;put LSB of dataPtr - prepare to Write call
0D58: 7C 0C 33 LCALL _USBUART_1_Write   (0737) 	lcall 	USBUART_1_Write
0D5B: 38 FB    ADD   SP,0xFB            (0738) 	add		SP, 251
                                        (0739) 	RAM_EPILOGUE RAM_USE_CLASS_1
0D5D: 7F       RET                      (0740)     ret
0D5E: 70 BF    AND   F,0xBF             
0D60: 62 D3 03 MOV   REG[0xD3],0x3      
                                        (0741) .ENDSECTION
                                        (0742) 
                                        (0743) .SECTION
                                        (0744) ;-----------------------------------------------------------------------------
                                        (0745) ;  FUNCTION NAME: USBUART_1_PutSHexInt
                                        (0746) ;
                                        (0747) ;  DESCRIPTION:    Print a byte in Hex (two byte) representation to the USBUART
                                        (0748) ;
                                        (0749) ;-----------------------------------------------------------------------------
                                        (0750) ;
                                        (0751) ;  ARGUMENTS:
                                        (0752) ;     A  => LSB of Int
                                        (0753) ;     X  => MSB of Int
                                        (0754) ;
                                        (0755) ;  RETURNS:
                                        (0756) ;     none
                                        (0757) ;
                                        (0758) ;  SIDE EFFECTS:
                                        (0759) ;    The A and X registers may be modified by this or future implementations
                                        (0760) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0761) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0762) ;    responsibility to preserve their values across calls to fastcall16
                                        (0763) ;    functions.
                                        (0764) ;
                                        (0765)  USBUART_1_PutSHexInt:
                                        (0766) _USBUART_1_PutSHexInt:
                                        (0767)     RAM_PROLOGUE RAM_USE_CLASS_3
                                        (0768) 	RAM_SETPAGE_IDX2STK
0D63: 08       PUSH  A                  (0769) 	push	A	;save LSB
0D64: 5B       MOV   A,X                (0770) 	mov 	A, X
0D65: 67       ASR   A                  (0771) 	asr		A   ; Shift high nibble to right
0D66: 67       ASR   A                  (0772) 	asr		A
0D67: 67       ASR   A                  (0773) 	asr		A
0D68: 67       ASR   A                  (0774) 	asr		A
0D69: 21 0F    AND   A,0xF              (0775) 	and		A,0Fh	; Mask off nibble
0D6B: FE 14    INDEX 0x0B81             (0776) 	index USBUART_1_HEX_STR;  Get Hex value
0D6D: 08       PUSH  A                  (0777) 	push	A
0D6E: 5B       MOV   A,X                (0778) 	mov		A, X	;retrieve lower nibble
0D6F: 21 0F    AND   A,0xF              (0779) 	and   	A,0Fh	; Mask off lower nibble
0D71: FE 0E    INDEX 0x0B81             (0780) 	index USBUART_1_HEX_STR	; Get Hex value
0D73: 08       PUSH  A                  (0781) 	push	A
0D74: 4F       MOV   X,SP               (0782) 	mov 	X, SP
0D75: 52 FD    MOV   A,[X-3]            (0783) 	mov		A, [X-3]	;retrieve LSB
0D77: 5C       MOV   X,A                (0784) 	mov 	X, A	; Save lower nibble
0D78: 67       ASR   A                  (0785) 	asr		A   ; Shift high nibble to right
0D79: 67       ASR   A                  (0786) 	asr		A
0D7A: 67       ASR   A                  (0787) 	asr		A
0D7B: 67       ASR   A                  (0788) 	asr		A
0D7C: 21 0F    AND   A,0xF              (0789) 	and		A,0Fh	; Mask off nibble
0D7E: FE 01    INDEX 0x0B81             (0790) 	index USBUART_1_HEX_STR;  Get Hex value
0D80: 08       PUSH  A                  (0791) 	push	A
0D81: 5B       MOV   A,X                (0792) 	mov		A, X
0D82: 21 0F    AND   A,0xF              (0793) 	and   	A,0Fh	; Mask off lower nibble
0D84: FD FB    INDEX 0x0B81             (0794) 	index USBUART_1_HEX_STR	; Get Hex value
0D86: 08       PUSH  A                  (0795) 	push	A
                                        (0796) 
0D87: 50 04    MOV   A,0x4              (0797) 	mov		A, 4	; 4 bytes to transfer
0D89: 08       PUSH  A                  (0798) 	push	A
                                        (0799) IF ( SYSTEM_LARGE_MEMORY_MODEL )
0D8A: 5D D1    MOV   A,REG[0xD1]        (0800)     mov   	A, reg[STK_PP]
                                        (0801) ELSE
                                        (0802) 	mov 	A, 0
                                        (0803) ENDIF
0D8C: 08       PUSH  A                  (0804) 	push	A	;put MSB of dataPtr  - prepare to Write call
0D8D: 4F       MOV   X,SP               (0805) 	mov 	X, SP
0D8E: 5B       MOV   A,X                (0806) 	mov		A, X
0D8F: 11 06    SUB   A,0x6              (0807) 	sub 	A, 6
0D91: 08       PUSH  A                  (0808) 	push	A	;put LSB of dataPtr - prepare to Write call
0D92: 7C 0C 33 LCALL _USBUART_1_Write   (0809) 	lcall 	USBUART_1_Write
0D95: 38 F8    ADD   SP,0xF8            (0810) 	add		SP, 248
0D97: 70 3F    AND   F,0x3F             
0D99: 71 C0    OR    F,0xC0             
                                        (0811) 	RAM_EPILOGUE RAM_USE_CLASS_3
0D9B: 7F       RET                      (0812)     ret
0D9C: 70 BF    AND   F,0xBF             
0D9E: 62 D0 00 MOV   REG[0xD0],0x0      
0DA1: 62 D3 03 MOV   REG[0xD3],0x3      
                                        (0813) .ENDSECTION
                                        (0814) 
                                        (0815) .SECTION
                                        (0816) ;-----------------------------------------------------------------------------
                                        (0817) ;  FUNCTION NAME: USBUART_1_Read
                                        (0818) ;
                                        (0819) ;  DESCRIPTION:    This function reads from the specified endpoint buffer
                                        (0820) ;                  with the count number of bytes.
                                        (0821) ;
                                        (0822) ;-----------------------------------------------------------------------------
                                        (0823) ;
                                        (0824) ;  ARGUMENTS:
                                        (0825) ;     [SP-5] Count to read
                                        (0826) ;     [SP-4] MSB of data array address to put data in
                                        (0827) ;     [SP-3] LSB of data array address to put data in
                                        (0828) ;
                                        (0829) ;  RETURNS:
                                        (0830) ;     none
                                        (0831) ;
                                        (0832) ;  SIDE EFFECTS:
                                        (0833) ;    The A and X registers may be modified by this or future implementations
                                        (0834) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0835) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0836) ;    responsibility to preserve their values across calls to fastcall16
                                        (0837) ;    functions.
                                        (0838) ;
                                        (0839) ;    Currently only the page pointer registers listed below are modified:
                                        (0840) ;          CUR_PP
                                        (0841) ;          IDX_PP
                                        (0842) ;
                                        (0843) DATA_LSBR:   equ -3           ; MSB pointer of data
                                        (0844) DATA_MSBR:   equ -4           ; LSB pointer of data
                                        (0845) RDCNTLEN:		 equ -5           ; Length of data to send
                                        (0846) 
                                        (0847)  USBUART_1_Read:
                                        (0848) _USBUART_1_Read:
                                        (0849)     RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0850)     RAM_PROLOGUE RAM_USE_CLASS_3
                                        (0851) 	RAM_SETPAGE_CUR >USBUART_1_bCurrentDevice ; Set the CUR_PP to the right page
                                        (0852)     RAM_SETPAGE_IDX2STK
                                        (0853) 
                                        (0854)     ;Get the count value passed
0DA4: 4F       MOV   X,SP               (0855) 	mov		X, SP
0DA5: 52 FB    MOV   A,[X-5]            (0856) 	mov     A, [X+RDCNTLEN]               ; Get the Count
0DA7: 53 38    MOV   [0x38],A           (0857) 	mov     [USBUART_1_APITemp], A        ; Save the count
                                        (0858) 
                                        (0859)     ;Determine which is smaller the requested data or the available data
0DA9: 5D 53    MOV   A,REG[0x53]        (0860) 	mov     A, reg[USBUART_1_EP3CNT0]      ; Get the Real count
0DAB: 53 39    MOV   [0x39],A           (0861) 	mov 	[USBUART_1_APITemp+1], A ; set the reminder
0DAD: 11 02    SUB   A,0x2              (0862) 	sub 	A, 2
0DAF: 3A 38    CMP   A,[0x38]           (0863) 	cmp     A, [USBUART_1_APITemp]         ; Are they equal
0DB1: A0 07    JZ    0x0DB9             (0864) 	jz      .CountCorrect                  ; If they are check if they are 1
0DB3: D0 05    JNC   0x0DB9             (0865) 	jnc      .CountCorrect                 ;If the requested count is smaller use it
0DB5: 50 80    MOV   A,0x80             (0866) 	mov 	A, 80h	; Set error condition and exit
0DB7: 80 70    JMP   0x0E28             (0867) 	jmp 	.exit
0DB9: 71 10    OR    F,0x10             
                                        (0868) 
                                        (0869) .CountCorrect:
                                        (0870) ; First we need to determine where, within the PMA, the EP Start Address is
                                        (0871)    M8C_SetBank1
0DBB: 5D 6E    MOV   A,REG[0x6E]        (0872)    mov   A, reg[TMP_DR2]                ; Get the address of ep from tmp register
0DBD: 49 F7 01 TST   REG[0xF7],0x1      (0873)    tst   reg[CPU_F], 0x01
0DC0: A0 09    JZ    0x0DCA             (0874)    jz    .DontTouchGIE3
0DC2: 70 FE    AND   F,0xFE             
                                        (0875)    M8C_DisableGInt
0DC4: 60 50    MOV   REG[0x50],A        (0876)    mov   reg[PMA0_RA], A                ; Set the Read pointer of our pma to ep space
0DC6: 71 01    OR    F,0x1              
                                        (0877)    M8C_EnableGInt
0DC8: 80 03    JMP   0x0DCC             (0878)    jmp   .Continue3
                                        (0879) .DontTouchGIE3:
0DCA: 60 50    MOV   REG[0x50],A        (0880)    mov   reg[PMA0_RA], A                ; Set the Read pointer of our pma to ep space
0DCC: 70 EF    AND   F,0xEF             
                                        (0881) .Continue3:
                                        (0882) 	M8C_SetBank0
                                        (0883) 
                                        (0884) ; Now we are ready to start moving data
0DCE: 51 38    MOV   A,[0x38]           (0885) 	mov     A, [USBUART_1_APITemp]         ; Check the Count register
0DD0: A0 28    JZ    0x0DF9             (0886) 	jz      .done                          ; If it is 0 then we have a 0 length packet
                                        (0887) 
                                        (0888) .start_send:
0DD2: 52 FD    MOV   A,[X-3]            (0889) 	mov     A, [X+DATA_LSBR]               ; Get the LSB of the pointer
0DD4: 08       PUSH  A                  (0890) 	push    A                              ; save on stack
                                        (0891) IF SYSTEM_LARGE_MEMORY_MODEL
0DD5: 52 FC    MOV   A,[X-4]            (0892) 	mov     A, [X+DATA_MSBR]               ; Get the MSB of the pointer
0DD7: 60 D3    MOV   REG[0xD3],A        (0893) 	mov     reg[IDX_PP], A                 ; Use as value for IDX_PP
                                        (0894) ENDIF
0DD9: 20       POP   X                  (0895) 	pop     X                              ; Get the LSB again
0DDA: 71 10    OR    F,0x10             
                                        (0896) 
                                        (0897)     ;; 24Mhz read PMA workaround 
                                        (0898)     M8C_SetBank1
0DDC: 5D E0    MOV   A,REG[0xE0]        (0899)     mov     A, reg[OSC_CR0]
0DDE: 08       PUSH  A                  (0900)     push    A
0DDF: 21 F8    AND   A,0xF8             (0901)     and     A, 0xf8 ;clear the clock bits 
0DE1: 29 02    OR    A,0x2              (0902)     or      A, 0x02 ;will set clk to 12Mhz
0DE3: 60 E0    MOV   REG[0xE0],A        (0903)     mov     reg[OSC_CR0], A ;clk is now set at 12Mhz
0DE5: 70 EF    AND   F,0xEF             
                                        (0904)     M8C_SetBank0
                                        (0905) 
                                        (0906) .loop:
0DE7: 5D 40    MOV   A,REG[0x40]        (0907) 	mov     A, reg[PMA0_DR]                ; Get the data from the PMA space
0DE9: 54 00    MOV   [X+0],A            (0908) 	mov		[X], A                            ; save it in data array
0DEB: 75       INC   X                  (0909) 	inc     X                              ; increment the pointer
0DEC: 7A 39    DEC   [0x39]             (0910) 	dec		[USBUART_1_APITemp+1]             ; decrement the reminder
0DEE: 7A 38    DEC   [0x38]             (0911) 	dec     [USBUART_1_APITemp]            ; decrement the counter
0DF0: BF F6    JNZ   0x0DE7             (0912) 	jnz     .loop                          ; wait for count to zero out
                                        (0913) 
                                        (0914)     ;; 24Mhz read PMA workaround (back to previous clock speed)
0DF2: 18       POP   A                  (0915)     pop     A ;recover previous reg[OSC_CR0] value
0DF3: 71 10    OR    F,0x10             
                                        (0916)     M8C_SetBank1
0DF5: 60 E0    MOV   REG[0xE0],A        (0917)     mov     reg[OSC_CR0], A ;clk is now set at previous value (probably 24Mhz)
0DF7: 70 EF    AND   F,0xEF             
0DF9: 62 D3 03 MOV   REG[0xD3],0x3      
                                        (0918)     M8C_SetBank0
                                        (0919)     ;; end 24Mhz read PMA workaround 
                                        (0920) 
                                        (0921) .done:
                                        (0922)     RAM_SETPAGE_IDX2STK
0DFC: 4F       MOV   X,SP               (0923) 	mov		X, SP
0DFD: 5D 6E    MOV   A,REG[0x6E]        (0924)     mov     A, reg[TMP_DR2]
0DFF: 03 FB    ADD   A,[X-5]            (0925)     add     A, [X+RDCNTLEN]
0E01: 60 6E    MOV   REG[0x6E],A        (0926)     mov     reg[TMP_DR2], A
0E03: 3C 39 02 CMP   [0x39],0x2         (0927) 	cmp 	[USBUART_1_APITemp+1], 2 	; If only 2 bytes of checksum left in EP
0E06: A0 09    JZ    0x0E10             (0928) 	jz		.BufferEmpty
0E08: 51 39    MOV   A,[0x39]           (0929) 	mov		A, [USBUART_1_APITemp+1]		; Prepare count reminder for return
0E0A: 60 53    MOV   REG[0x53],A        (0930) 	mov		reg[USBUART_1_EP3CNT0], A
0E0C: 11 02    SUB   A,0x2              (0931)     sub     A, 2
0E0E: 80 19    JMP   0x0E28             (0932) 	jmp .exit
                                        (0933) 
                                        (0934) .BufferEmpty:
0E10: 55 25 00 MOV   [0x25],0x0         (0935)     mov     [USBUART_1_EndpointAPIStatus+3], NO_EVENT_PENDING ; For the API
0E13: 62 53 40 MOV   REG[0x53],0x40     (0936) 	mov     reg[USBUART_1_EP3CNT0], 64
0E16: 71 10    OR    F,0x10             
                                        (0937) 	M8C_SetBank1
0E18: 62 6E 80 MOV   REG[0x6E],0x80     (0938) 	mov		reg[TMP_DR2], 128
0E1B: 5D 6E    MOV   A,REG[0x6E]        (0939)     mov     A, reg[TMP_DR2]
0E1D: 60 43    MOV   REG[0x43],A        (0940) 	mov     reg[PMA3_WA], A
0E1F: 5D C6    MOV   A,REG[0xC6]        (0941)     mov     A, reg[USBUART_1_EP3MODE]  ; Unlock the mode register
0E21: 62 C6 09 MOV   REG[0xC6],0x9      (0942)     mov     reg[USBUART_1_EP3MODE], USB_MODE_ACK_OUT ; Enable the endpoint
0E24: 50 00    MOV   A,0x0              (0943) 	mov 	A, 0;	; No error and no bytes left in EP
0E26: 70 EF    AND   F,0xEF             
0E28: 70 3F    AND   F,0x3F             
0E2A: 71 C0    OR    F,0xC0             
                                        (0944)     M8C_SetBank0
                                        (0945) 
                                        (0946) .exit:
                                        (0947)     RAM_EPILOGUE RAM_USE_CLASS_3
                                        (0948) 	RAM_EPILOGUE RAM_USE_CLASS_4
0E2C: 7F       RET                      (0949)     ret
                                        (0950) .ENDSECTION
                                        (0951) 
                                        (0952) .SECTION
                                        (0953) ;-----------------------------------------------------------------------------
                                        (0954) ;  FUNCTION NAME: USBUART_1_ReadAll
                                        (0955) ;
                                        (0956) ;  DESCRIPTION:    This function reads all from the Rx associated endpoint buffer
                                        (0957) ;
                                        (0958) ;-----------------------------------------------------------------------------
                                        (0959) ;
                                        (0960) ;  ARGUMENTS:
                                        (0961) ;     A - MSB of data array address to put data in
                                        (0962) ;     X - LSB of data array address to put data in
                                        (0963) ;
                                        (0964) ;  RETURNS:
                                        (0965) ;     none
                                        (0966) ;
                                        (0967) ;  SIDE EFFECTS:
                                        (0968) ;    The A and X registers may be modified by this or future implementations
                                        (0969) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0970) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0971) ;    responsibility to preserve their values across calls to fastcall16
                                        (0972) ;    functions.
                                        (0973) ;
                                        (0974) 
                                        (0975)  USBUART_1_ReadAll:
                                        (0976) _USBUART_1_ReadAll:
                                        (0977)     RAM_PROLOGUE RAM_USE_CLASS_2
0E2D: 38 01    ADD   SP,0x1             (0978) 	add		SP, 1	; Prepare space for number of bytes
0E2F: 08       PUSH  A                  (0979) 	push	A	;put MSB of dataPtr  - prepare to Write call
0E30: 10       PUSH  X                  (0980) 	push	X	;put LSB of dataPtr - prepare to Write call
0E31: 5D 53    MOV   A,REG[0x53]        (0981)    	mov     A, reg[USBUART_1_EP3CNT0]  ; Here is the count
0E33: 11 02    SUB   A,0x2              (0982) 	sub		A, 2
0E35: 4F       MOV   X,SP               (0983) 	mov		X, SP
0E36: 54 FD    MOV   [X-3],A            (0984) 	mov 	[X-3], A ; put the number of bytes
0E38: 70 3F    AND   F,0x3F             
0E3A: 71 C0    OR    F,0xC0             
                                        (0985) 	RAM_EPILOGUE RAM_USE_CLASS_2
0E3C: 7C 0D 9C LCALL _USBUART_1_Read    (0986) 	lcall 	USBUART_1_Read
                                        (0987) 	RAM_PROLOGUE RAM_USE_CLASS_2
0E3F: 38 FD    ADD   SP,0xFD            (0988) 	add		SP, 253
0E41: 70 3F    AND   F,0x3F             
0E43: 71 C0    OR    F,0xC0             
                                        (0989)    	RAM_EPILOGUE RAM_USE_CLASS_2
0E45: 7F       RET                      (0990)     ret
                                        (0991) .ENDSECTION
                                        (0992) 
                                        (0993) .SECTION
                                        (0994) ;-----------------------------------------------------------------------------
                                        (0995) ;  FUNCTION NAME: USBUART_1_ReadChar
                                        (0996) ;
                                        (0997) ;  DESCRIPTION:    This function reads all from the Rx associated endpoint buffer
                                        (0998) ;
                                        (0999) ;-----------------------------------------------------------------------------
                                        (1000) ;
                                        (1001) ;  ARGUMENTS:
                                        (1002) ;     none
                                        (1003) ;
                                        (1004) ;  RETURNS:
                                        (1005) ;     none
                                        (1006) ;
                                        (1007) ;  SIDE EFFECTS:
                                        (1008) ;    The A and X registers may be modified by this or future implementations
                                        (1009) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (1010) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (1011) ;    responsibility to preserve their values across calls to fastcall16
                                        (1012) ;    functions.
                                        (1013) ;
                                        (1014) 
                                        (1015)  USBUART_1_ReadChar:
                                        (1016) _USBUART_1_ReadChar:
                                        (1017)     RAM_PROLOGUE RAM_USE_CLASS_1
0E46: 38 01    ADD   SP,0x1             (1018) 	add		SP, 1	; Prepare placeholder in stack
0E48: 50 01    MOV   A,0x1              (1019) 	mov		A, 1
0E4A: 08       PUSH  A                  (1020) 	push	A		; Read one byte
                                        (1021) IF ( SYSTEM_LARGE_MEMORY_MODEL )
0E4B: 5D D1    MOV   A,REG[0xD1]        (1022)     mov   	A, reg[STK_PP]
                                        (1023) ELSE
                                        (1024) 	mov 	A, 0
                                        (1025) ENDIF
0E4D: 08       PUSH  A                  (1026) 	push	A	;put MSB of dataPtr  - prepare to Write call
0E4E: 4F       MOV   X,SP               (1027) 	mov 	X, SP
0E4F: 5B       MOV   A,X                (1028) 	mov		A, X
0E50: 11 03    SUB   A,0x3              (1029) 	sub 	A, 3
0E52: 08       PUSH  A                  (1030) 	push	A	;put LSB of dataPtr - prepare to Write call
0E53: 7C 0D 9C LCALL _USBUART_1_Read    (1031) 	lcall 	USBUART_1_Read
0E56: 38 FD    ADD   SP,0xFD            (1032) 	add		SP, 253
0E58: 5C       MOV   X,A                (1033) 	mov		X, A	;copy status to MSB
0E59: 18       POP   A                  (1034) 	pop		A	; Get the character from the stack;
                                        (1035)     RAM_EPILOGUE RAM_USE_CLASS_1
0E5A: 7F       RET                      (1036)     ret
0E5B: 71 10    OR    F,0x10             
                                        (1037) .ENDSECTION
                                        (1038) 
                                        (1039) .SECTION
                                        (1040) ;-----------------------------------------------------------------------------
                                        (1041) ;  FUNCTION NAME: USBUART_1_bTxIsReady
                                        (1042) ;
                                        (1043) ;  DESCRIPTION:   Returns whether the ACK bit of EP has been set for
                                        (1044) ;                 an endpoint
                                        (1045) ;
                                        (1046) ;-----------------------------------------------------------------------------
                                        (1047) ;
                                        (1048) ;  ARGUMENTS:
                                        (1049) ;	none
                                        (1050) ;
                                        (1051) ;  RETURNS:       A is 0 if Tx is not ready and non-zero if it is
                                        (1052) ;
                                        (1053) ;  SIDE EFFECTS:
                                        (1054) ;    The A and X registers may be modified by this or future implementations
                                        (1055) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (1056) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (1057) ;    responsibility to preserve their values across calls to fastcall16
                                        (1058) ;    functions.
                                        (1059) ;
                                        (1060)  USBUART_1_bTxIsReady:
                                        (1061) _USBUART_1_bTxIsReady:
                                        (1062)     RAM_PROLOGUE RAM_USE_CLASS_1
                                        (1063) 	M8C_SetBank1
0E5D: 5D C5    MOV   A,REG[0xC5]        (1064)     mov    A, reg[USBUART_1_EP2MODE]
0E5F: 70 EF    AND   F,0xEF             
                                        (1065) 	M8C_SetBank0
0E61: 21 10    AND   A,0x10             (1066)     and    A, 0x10
0E63: 7F       RET                      (1067)     ret                                ; Exit
0E64: 70 BF    AND   F,0xBF             
0E66: 62 D0 00 MOV   REG[0xD0],0x0      
                                        (1068)     RAM_EPILOGUE RAM_USE_CLASS_1
                                        (1069) .ENDSECTION
                                        (1070) 
                                        (1071) 
                                        (1072) .SECTION
                                        (1073) ;-----------------------------------------------------------------------------
                                        (1074) ;  FUNCTION NAME: USBUART_1_Init
                                        (1075) ;
                                        (1076) ;  DESCRIPTION:    Try to initialize USBUART device if it already enumerated
                                        (1077) ;
                                        (1078) ;-----------------------------------------------------------------------------
                                        (1079) ;
                                        (1080) ;  ARGUMENTS:  None
                                        (1081) ;
                                        (1082) ;  RETURNS:	1 if successfully initialized, otherwise 0
                                        (1083) ;
                                        (1084) ;  SIDE EFFECTS:
                                        (1085) ;    The A and X registers may be modified by this or future implementations
                                        (1086) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (1087) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (1088) ;    responsibility to preserve their values across calls to fastcall16
                                        (1089) ;    functions.
                                        (1090) ;
                                        (1091)  USBUART_1_Init:
                                        (1092) _USBUART_1_Init:
                                        (1093)     RAM_PROLOGUE RAM_USE_CLASS_4
                                        (1094)     RAM_PROLOGUE RAM_USE_CLASS_3
                                        (1095) ; check that USB is configured
                                        (1096) 	RAM_SETPAGE_CUR >USBUART_1_Configuration
0E69: 51 01    MOV   A,[0x1]            (1097)     mov     A,[USBUART_1_Configuration]
0E6B: A0 4C    JZ    0x0EB8             (1098) 	jz		.done
0E6D: 62 D0 00 MOV   REG[0xD0],0x0      
                                        (1099) ; load zero length dummy packet to EP2
                                        (1100) 	RAM_SETPAGE_CUR >USBUART_1_bCurrentDevice ; Set the CUR_PP to the right page
                                        (1101) 
                                        (1102)     ;SET THE COUNT AND TOGGLE
0E70: 50 04    MOV   A,0x4              (1103)     mov     A, 04h                     ; EP2
0E72: 22 1D    AND   A,[0x1D]           (1104)     and     A, [USBUART_1_EPDataToggle]
0E74: A0 03    JZ    0x0E78             (1105)     jz      .toggle_done
0E76: 50 80    MOV   A,0x80             (1106)     mov     A,  USB_CNT_TOGGLE ; Set the data toggle
                                        (1107) 
                                        (1108) .toggle_done:
0E78: 62 51 00 MOV   REG[0x51],0x0      (1109)     mov     reg[USBUART_1_EP2CNT0], 0   ; Write it into the register
0E7B: 60 50    MOV   REG[0x50],A        (1110) 	mov     reg[USBUART_1_EP2CNT1], A      ; Write it into the register
0E7D: 62 D3 03 MOV   REG[0xD3],0x3      
0E80: 71 10    OR    F,0x10             
                                        (1111) 
                                        (1112)     ; It's Time to move the data
                                        (1113)     ; First we need to determine where, within the PMA, the EP Start Address is
                                        (1114)    RAM_SETPAGE_IDX2STK
                                        (1115)    M8C_SetBank1
0E82: 5D 6D    MOV   A,REG[0x6D]        (1116)    mov   A, reg[TMP_DR1]                ; Get the address of ep from tmp register
0E84: 49 F7 01 TST   REG[0xF7],0x1      (1117)    tst   reg[CPU_F], 0x01
0E87: A0 09    JZ    0x0E91             (1118)    jz    .DontTouchGIE4
0E89: 70 FE    AND   F,0xFE             
                                        (1119)    M8C_DisableGInt
0E8B: 60 40    MOV   REG[0x40],A        (1120)    mov   reg[PMA0_WA], A                ; Set the Write pointer of our pma to ep space
0E8D: 71 01    OR    F,0x1              
                                        (1121)    M8C_EnableGInt
0E8F: 80 03    JMP   0x0E93             (1122)    jmp   .Continue4
                                        (1123) .DontTouchGIE4:
0E91: 60 40    MOV   REG[0x40],A        (1124)    mov   reg[PMA0_WA], A                ; Set the Write pointer of our pma to ep space
0E93: 70 EF    AND   F,0xEF             
                                        (1125) .Continue4:
                                        (1126)    M8C_SetBank0
                                        (1127) 
                                        (1128)     ; Now we are ready to start moving data
0E95: 55 24 00 MOV   [0x24],0x0         (1129)     mov     [USBUART_1_EndpointAPIStatus+2], NO_EVENT_PENDING ; Set the state
0E98: 71 10    OR    F,0x10             
                                        (1130) 	M8C_SetBank1
0E9A: 5D 6D    MOV   A,REG[0x6D]        (1131) 	mov     A, reg[TMP_DR1]               ; Get the value of the PMA start Address
0E9C: 60 52    MOV   REG[0x52],A        (1132) 	mov     reg[PMA2_RA], A               ; Load it into EP PMA so pre-fetch occurs
0E9E: 62 C5 0D MOV   REG[0xC5],0xD      (1133) 	mov     reg[USBUART_1_EP2MODE], USB_MODE_ACK_IN ; Enable the endpoint
0EA1: 70 EF    AND   F,0xEF             
                                        (1134) 	M8C_SetBank0
                                        (1135) 
                                        (1136) ; Enable EP 3
0EA3: 55 25 00 MOV   [0x25],0x0         (1137)     mov     [USBUART_1_EndpointAPIStatus+3], NO_EVENT_PENDING ; For the API
0EA6: 62 53 40 MOV   REG[0x53],0x40     (1138) 	mov     reg[USBUART_1_EP3CNT0], 64
0EA9: 71 10    OR    F,0x10             
                                        (1139) 	M8C_SetBank1
0EAB: 5D 6E    MOV   A,REG[0x6E]        (1140)     mov     A, reg[TMP_DR2]
0EAD: 60 43    MOV   REG[0x43],A        (1141) 	mov     reg[PMA3_WA], A
0EAF: 5D C6    MOV   A,REG[0xC6]        (1142)     mov     A, reg[USBUART_1_EP3MODE]  ; Unlock the mode register
0EB1: 62 C6 09 MOV   REG[0xC6],0x9      (1143)     mov     reg[USBUART_1_EP3MODE], USB_MODE_ACK_OUT ; Enable the endpoint
0EB4: 70 EF    AND   F,0xEF             
                                        (1144)     M8C_SetBank0
                                        (1145) 
                                        (1146) ; prepare return
0EB6: 50 01    MOV   A,0x1              (1147) 	mov		A, 1
0EB8: 70 3F    AND   F,0x3F             
0EBA: 71 C0    OR    F,0xC0             
                                        (1148) 
                                        (1149) .done:
                                        (1150)     RAM_EPILOGUE RAM_USE_CLASS_3
                                        (1151) 	RAM_EPILOGUE RAM_USE_CLASS_4
0EBC: 7F       RET                      (1152)     ret
0EBD: 70 BF    AND   F,0xBF             
0EBF: 41 DF FB AND   REG[0xDF],0xFB     
0EC2: 62 D0 00 MOV   REG[0xD0],0x0      
0EC5: 60 D3    MOV   REG[0xD3],A        
                                        (1153) .ENDSECTION
                                        (1154) 
                                        (1155) .SECTION
                                        (1156) ;-----------------------------------------------------------------------------
                                        (1157) ;  FUNCTION NAME: USBUART_1_dwGetDTERate
                                        (1158) ;
                                        (1159) ;  DESCRIPTION:    Return DTE Rate
                                        (1160) ;
                                        (1161) ;-----------------------------------------------------------------------------
                                        (1162) ;
                                        (1163) ;  ARGUMENTS:  None
                                        (1164) ;
                                        (1165) ;  RETURNS:	DWORD containing DTE rate in bits per second
                                        (1166) ;
                                        (1167) ;  SIDE EFFECTS:
                                        (1168) ;    The A and X registers may be modified by this or future implementations
                                        (1169) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (1170) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (1171) ;    responsibility to preserve their values across calls to fastcall16
                                        (1172) ;    functions.
                                        (1173) ;
                                        (1174) USBUART_1_dwGetDTERate:
                                        (1175) _USBUART_1_dwGetDTERate:
                                        (1176) 	RAM_PROLOGUE RAM_USE_CLASS_4
                                        (1177) 	RAM_PROLOGUE RAM_USE_CLASS_3
                                        (1178) 	; Disable interrupt here
                                        (1179) 	M8C_DisableIntMask USBUART_1_INT_REG, USBUART_1_INT_EP0_MASK
                                        (1180) 	RAM_SETPAGE_CUR >USBUART_1_LineCoding
                                        (1181) 	RAM_SETPAGE_IDX A
0EC7: 08       PUSH  A                  (1182) 	push  A
0EC8: 51 32    MOV   A,[0x32]           (1183) 	mov   A,[USBUART_1_LineCoding + 3]
0ECA: 54 00    MOV   [X+0],A            (1184) 	mov   [X + 0],A
0ECC: 51 31    MOV   A,[0x31]           (1185) 	mov   A,[USBUART_1_LineCoding + 2]
0ECE: 54 01    MOV   [X+1],A            (1186) 	mov   [X + 1],A
0ED0: 51 30    MOV   A,[0x30]           (1187) 	mov   A,[USBUART_1_LineCoding + 1]
0ED2: 54 02    MOV   [X+2],A            (1188) 	mov   [X + 2],A
0ED4: 51 2F    MOV   A,[0x2F]           (1189) 	mov   A,[USBUART_1_LineCoding]
0ED6: 54 03    MOV   [X+3],A            (1190) 	mov   [X + 3],A
0ED8: 18       POP   A                  (1191) 	pop   A
0ED9: 43 DF 04 OR    REG[0xDF],0x4      
0EDC: 70 3F    AND   F,0x3F             
0EDE: 71 C0    OR    F,0xC0             
                                        (1192) 
                                        (1193) 	M8C_EnableIntMask USBUART_1_INT_REG, USBUART_1_INT_EP0_MASK
                                        (1194) 	RAM_EPILOGUE RAM_USE_CLASS_4
                                        (1195) 	RAM_EPILOGUE RAM_USE_CLASS_3
0EE0: 7F       RET                      (1196) 	ret
0EE1: 62 D0 00 MOV   REG[0xD0],0x0      
                                        (1197) .ENDSECTION
                                        (1198) 
                                        (1199) .SECTION
                                        (1200) ;-----------------------------------------------------------------------------
                                        (1201) ;  FUNCTION NAME: USBUART_1_bGetCharFormat
                                        (1202) ;
                                        (1203) ;  DESCRIPTION:    Returns number of stop bits
                                        (1204) ;
                                        (1205) ;-----------------------------------------------------------------------------
                                        (1206) ;
                                        (1207) ;  ARGUMENTS:  None
                                        (1208) ;
                                        (1209) ;  RETURNS:	BYTE containing character format (data bits)
                                        (1210) ;				 (0 = 1 stop bit, 1 = 1.5 stop bit, 2 = 2 stop bit)
                                        (1211) ;
                                        (1212) ;  SIDE EFFECTS:
                                        (1213) ;    The A and X registers may be modified by this or future implementations
                                        (1214) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (1215) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (1216) ;    responsibility to preserve their values across calls to fastcall16
                                        (1217) ;    functions.
                                        (1218) ;
                                        (1219) USBUART_1_bGetCharFormat:
                                        (1220) _USBUART_1_bGetCharFormat:
                                        (1221) 	RAM_PROLOGUE RAM_USE_CLASS_4
                                        (1222) 	RAM_SETPAGE_CUR >USBUART_1_LineCoding
0EE4: 51 33    MOV   A,[0x33]           (1223) 	mov A, [USBUART_1_LineCoding+4];
                                        (1224) 	RAM_EPILOGUE RAM_USE_CLASS_4
0EE6: 7F       RET                      (1225) 	ret
0EE7: 62 D0 00 MOV   REG[0xD0],0x0      
                                        (1226) .ENDSECTION
                                        (1227) 
                                        (1228) .SECTION
                                        (1229) ;-----------------------------------------------------------------------------
                                        (1230) ;  FUNCTION NAME: USBUART_1_bGetParityType
                                        (1231) ;
                                        (1232) ;  DESCRIPTION:    Return Parity type
                                        (1233) ;
                                        (1234) ;-----------------------------------------------------------------------------
                                        (1235) ;
                                        (1236) ;  ARGUMENTS:  None
                                        (1237) ;
                                        (1238) ;  RETURNS:	Parity type
                                        (1239) ;				 (0 = none, 1 = odd, 2 = even, 3 = mark, 4 = space)
                                        (1240) ;
                                        (1241) ;  SIDE EFFECTS:
                                        (1242) ;    The A and X registers may be modified by this or future implementations
                                        (1243) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (1244) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (1245) ;    responsibility to preserve their values across calls to fastcall16
                                        (1246) ;    functions.
                                        (1247) ;
                                        (1248) USBUART_1_bGetParityType:
                                        (1249) _USBUART_1_bGetParityType:
                                        (1250) 	RAM_PROLOGUE RAM_USE_CLASS_4
                                        (1251) 	RAM_SETPAGE_CUR >USBUART_1_LineCoding
0EEA: 51 34    MOV   A,[0x34]           (1252) 	mov A, [USBUART_1_LineCoding+5];
                                        (1253) 	RAM_EPILOGUE RAM_USE_CLASS_4
0EEC: 7F       RET                      (1254) 	ret
0EED: 62 D0 00 MOV   REG[0xD0],0x0      
                                        (1255) .ENDSECTION
                                        (1256) 
                                        (1257) .SECTION
                                        (1258) ;-----------------------------------------------------------------------------
                                        (1259) ;  FUNCTION NAME: USBUART_1_bGetDataBits
                                        (1260) ;
                                        (1261) ;  DESCRIPTION:    Returns data bits (5,6,7,8 or 16)
                                        (1262) ;
                                        (1263) ;-----------------------------------------------------------------------------
                                        (1264) ;
                                        (1265) ;  ARGUMENTS:  None
                                        (1266) ;
                                        (1267) ;  RETURNS:	Data bits
                                        (1268) ;				 (5,6,7,8 or 16)
                                        (1269) ;
                                        (1270) ;  SIDE EFFECTS:
                                        (1271) ;    The A and X registers may be modified by this or future implementations
                                        (1272) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (1273) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (1274) ;    responsibility to preserve their values across calls to fastcall16
                                        (1275) ;    functions.
                                        (1276) ;
                                        (1277) USBUART_1_bGetDataBits:
                                        (1278) _USBUART_1_bGetDataBits:
                                        (1279) 	RAM_PROLOGUE RAM_USE_CLASS_4
                                        (1280) 	RAM_SETPAGE_CUR >USBUART_1_LineCoding
0EF0: 51 35    MOV   A,[0x35]           (1281) 	mov A, [USBUART_1_LineCoding+6];
                                        (1282) 	RAM_EPILOGUE RAM_USE_CLASS_4
0EF2: 7F       RET                      (1283) 	ret
0EF3: 62 D0 00 MOV   REG[0xD0],0x0      
                                        (1284) .ENDSECTION
                                        (1285) 
                                        (1286) .SECTION
                                        (1287) ;-----------------------------------------------------------------------------
                                        (1288) ;  FUNCTION NAME: USBUART_1_bGetLineControl
                                        (1289) ;
                                        (1290) ;  DESCRIPTION:    Return Line Control Bitmap
                                        (1291) ;
                                        (1292) ;-----------------------------------------------------------------------------
                                        (1293) ;
                                        (1294) ;  ARGUMENTS:  None
                                        (1295) ;
                                        (1296) ;  RETURNS:	Line control bitmap
                                        (1297) ;				D7..D2 - reserved
                                        (1298) ;				D1 - RTS (0 = deactivate carrier, 1 = activate carrier)
                                        (1299) ;				D0 - DTR (0 = not present, 1 = present);
                                        (1300) ;
                                        (1301) ;  SIDE EFFECTS:
                                        (1302) ;    The A and X registers may be modified by this or future implementations
                                        (1303) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (1304) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (1305) ;    responsibility to preserve their values across calls to fastcall16
                                        (1306) ;    functions.
                                        (1307) ;
                                        (1308) USBUART_1_bGetLineControlBitmap:
                                        (1309) _USBUART_1_bGetLineControlBitmap:
                                        (1310) 	RAM_PROLOGUE RAM_USE_CLASS_4
                                        (1311) 	RAM_SETPAGE_CUR >USBUART_1_LineControlBitmap
0EF6: 51 37    MOV   A,[0x37]           (1312) 	mov A, [USBUART_1_LineControlBitmap+1];
                                        (1313) 	RAM_EPILOGUE RAM_USE_CLASS_4
0EF8: 7F       RET                      (1314) 	ret
0EF9: 62 D0 00 MOV   REG[0xD0],0x0      
                                        (1315) .ENDSECTION
                                        (1316) 
                                        (1317) .SECTION
                                        (1318) ;-----------------------------------------------------------------------------
                                        (1319) ;  FUNCTION NAME: USBUART_1_SendStateNotify
                                        (1320) ;
                                        (1321) ;  DESCRIPTION:    Send notification about UART state
                                        (1322) ;
                                        (1323) ;-----------------------------------------------------------------------------
                                        (1324) ;
                                        (1325) ;  ARGUMENTS:
                                        (1326) ;     	A - State bitmap
                                        (1327) ;
                                        (1328) ;  RETURNS:
                                        (1329) ;     none
                                        (1330) ;
                                        (1331) ;  SIDE EFFECTS:
                                        (1332) ;    The A and X registers may be modified by this or future implementations
                                        (1333) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (1334) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (1335) ;    responsibility to preserve their values across calls to fastcall16
                                        (1336) ;    functions.
                                        (1337) ;
                                        (1338) ;    Currently only the page pointer registers listed below are modified:
                                        (1339) ;          CUR_PP
                                        (1340) ;          IDX_PP
                                        (1341) ;
                                        (1342) ; -2 and -3 is the return address to caller
                                        (1343)  USBUART_1_SendStateNotify:
                                        (1344) _USBUART_1_SendStateNotify:
                                        (1345)     RAM_PROLOGUE RAM_USE_CLASS_4
                                        (1346)     RAM_SETPAGE_CUR >USBUART_1_APITemp ; interrupt RAM 0 page
                                        (1347)     ;Should we toggle the data bit??
                                        (1348)     ;SET THE COUNT AND TOGGLE
0EFC: 08       PUSH  A                  (1349) 	push 	A
0EFD: 55 38 0A MOV   [0x38],0xA         (1350) 	mov     [USBUART_1_APITemp], 10       ; Save the count
                                        (1351) 
0F00: 50 02    MOV   A,0x2              (1352)     mov     A, 02h                     ; EP1
0F02: 34 1D    XOR   [0x1D],A           (1353)     xor     [USBUART_1_EPDataToggle], A
0F04: 22 1D    AND   A,[0x1D]           (1354)     and     A, [USBUART_1_EPDataToggle]
0F06: A0 03    JZ    0x0F0A             (1355)     jz      .toggle_done
0F08: 50 80    MOV   A,0x80             (1356)     mov     A, USB_CNT_TOGGLE ; Set the data toggle
                                        (1357) 
                                        (1358) .toggle_done:
0F0A: 62 4F 0A MOV   REG[0x4F],0xA      (1359)     mov     reg[USBUART_1_EP1CNT0], 10  ; Write it into the register
0F0D: 60 4E    MOV   REG[0x4E],A        (1360) 	mov     reg[USBUART_1_EP1CNT1], A      ; Write it into the register
0F0F: 71 10    OR    F,0x10             
                                        (1361) 
                                        (1362) ; It's Time to move the data
                                        (1363) ; First we need to determine where, within the PMA, the EP Start Address is
                                        (1364)    M8C_SetBank1
0F11: 5D 6C    MOV   A,REG[0x6C]        (1365)    mov   A, reg[TMP_DR0]                ; Get the address of ep from tmp register
0F13: 49 F7 01 TST   REG[0xF7],0x1      (1366)    tst   reg[CPU_F], 0x01
0F16: A0 09    JZ    0x0F20             (1367)    jz    .DontTouchGIE5
0F18: 70 FE    AND   F,0xFE             
                                        (1368)    M8C_DisableGInt
0F1A: 60 40    MOV   REG[0x40],A        (1369)    mov   reg[PMA0_WA], A                ; Set the Write pointer of our pma to ep space
0F1C: 71 01    OR    F,0x1              
                                        (1370)    M8C_EnableGInt
0F1E: 80 03    JMP   0x0F22             (1371)    jmp   .Continue5
                                        (1372) .DontTouchGIE5:
0F20: 60 40    MOV   REG[0x40],A        (1373)    mov   reg[PMA0_WA], A                ; Set the Write pointer of our pma to ep space
0F22: 70 EF    AND   F,0xEF             
                                        (1374) .Continue5:
                                        (1375)    M8C_SetBank0
                                        (1376) 
                                        (1377) ; Now we are y to start moving data
0F24: 62 40 A1 MOV   REG[0x40],0xA1     (1378) 	mov		reg[PMA0_DR], A1h	; bmRequestType
0F27: 62 40 20 MOV   REG[0x40],0x20     (1379) 	mov		reg[PMA0_DR], 20h	; Serial State
0F2A: 62 40 00 MOV   REG[0x40],0x0      (1380) 	mov		reg[PMA0_DR], 0		; wValue MSB
0F2D: 62 40 00 MOV   REG[0x40],0x0      (1381) 	mov		reg[PMA0_DR], 0		; wValue LSB
0F30: 62 40 00 MOV   REG[0x40],0x0      (1382) 	mov		reg[PMA0_DR], 0		; wIndex MSB
0F33: 62 40 00 MOV   REG[0x40],0x0      (1383) 	mov		reg[PMA0_DR], 0		; wIndex (Interface)
0F36: 62 40 00 MOV   REG[0x40],0x0      (1384) 	mov		reg[PMA0_DR], 0		;wLen
0F39: 62 40 02 MOV   REG[0x40],0x2      (1385) 	mov		reg[PMA0_DR], 2		;wLen
0F3C: 62 40 00 MOV   REG[0x40],0x0      (1386) 	mov		reg[PMA0_DR], 0		;wLen
0F3F: 18       POP   A                  (1387) 	pop		A
0F40: 60 40    MOV   REG[0x40],A        (1388) 	mov		reg[PMA0_DR], A		;State bitmap
                                        (1389) 
0F42: 55 23 00 MOV   [0x23],0x0         (1390)     mov     [USBUART_1_EndpointAPIStatus+1], NO_EVENT_PENDING ; Set the state
0F45: 71 10    OR    F,0x10             
                                        (1391) 
                                        (1392)    M8C_SetBank1
0F47: 5D 6C    MOV   A,REG[0x6C]        (1393)    mov   A, reg[TMP_DR0]               ; Get the value of the PMA start Address
0F49: 49 F7 01 TST   REG[0xF7],0x1      (1394)    tst   reg[CPU_F], 0x01
0F4C: A0 09    JZ    0x0F56             (1395)    jz    .DontTouchGIE6
0F4E: 70 FE    AND   F,0xFE             
                                        (1396)    M8C_DisableGInt
0F50: 60 51    MOV   REG[0x51],A        (1397)    mov   reg[PMA0_RA+1], A             ; Load it into EP PMA so pre-fetch occurs
0F52: 71 01    OR    F,0x1              
                                        (1398)    M8C_EnableGInt
0F54: 80 03    JMP   0x0F58             (1399)    jmp   .Continue6
                                        (1400) .DontTouchGIE6:
0F56: 60 51    MOV   REG[0x51],A        (1401)    mov   reg[PMA0_RA+1], A             ; Load it into EP PMA so pre-fetch occurs
                                        (1402) .Continue6:
0F58: 62 C4 0D MOV   REG[0xC4],0xD      (1403)    mov   reg[USBUART_1_EP1MODE], USB_MODE_ACK_IN ; Enable the endpoint
0F5B: 70 EF    AND   F,0xEF             
                                        (1404)    M8C_SetBank0
                                        (1405) 
                                        (1406)    RAM_EPILOGUE RAM_USE_CLASS_4
0F5D: 7F       RET                      (1407)    ret
0F5E: 62 D0 00 MOV   REG[0xD0],0x0      
                                        (1408) .ENDSECTION
                                        (1409) 
                                        (1410) .SECTION
                                        (1411) ;-----------------------------------------------------------------------------
                                        (1412) ;  FUNCTION NAME: USBUART_1_SetPowerStatus
                                        (1413) ;
                                        (1414) ;  DESCRIPTION:    Set The Current Power status.
                                        (1415) ;
                                        (1416) ;-----------------------------------------------------------------------------
                                        (1417) ;
                                        (1418) ;  ARGUMENTS:      A contains the power status
                                        (1419) ;
                                        (1420) ;  RETURNS:        None
                                        (1421) ;
                                        (1422) ;  SIDE EFFECTS:
                                        (1423) ;    The A and X registers may be modified by this or future implementations
                                        (1424) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (1425) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (1426) ;    responsibility to perserve their values across calls to fastcall16
                                        (1427) ;    functions.
                                        (1428) ;
                                        (1429)  USBUART_1_SetPowerStatus:
                                        (1430) _USBUART_1_SetPowerStatus:
                                        (1431)     RAM_PROLOGUE RAM_USE_CLASS_4
                                        (1432)     RAM_SETPAGE_CUR >USBUART_1_DeviceStatus
0F61: 39 00    CMP   A,0x0              (1433)     cmp     A, 0
0F63: A0 06    JZ    0x0F6A             (1434)     jz      .bus_powered
0F65: 2E 02 01 OR    [0x2],0x1          (1435)     or      [USBUART_1_DeviceStatus], USB_DEVICE_STATUS_SELF_POWERED
0F68: 80 04    JMP   0x0F6D             (1436)     jmp     .done
                                        (1437) .bus_powered:
0F6A: 26 02 FE AND   [0x2],0xFE         (1438)     and     [USBUART_1_DeviceStatus], ~USB_DEVICE_STATUS_SELF_POWERED
                                        (1439) .done:
                                        (1440)     RAM_EPILOGUE RAM_USE_CLASS_4
0F6D: 7F       RET                      (1441)     ret                                ; All done
FILE: lib\dac8_1.asm                    (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME: DAC8_1.asm
                                        (0004) ;;   Version: 2.2, Updated on 2011/3/29 at 14:30:9
                                        (0005) ;;  Generated by PSoC Designer 5.1.2110.0
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: DAC8 User Module software implementation file.
                                        (0008) ;;
                                        (0009) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                        (0010) ;;        arguments and observe the associated "Registers are volatile" policy.
                                        (0011) ;;        This means it is the caller's responsibility to preserve any values
                                        (0012) ;;        in the X and A registers that are still needed after the API functions
                                        (0013) ;;        returns. For Large Memory Model devices it is also the caller's 
                                        (0014) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                        (0015) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                        (0016) ;;        now, there is no guarantee that will remain the case in future releases.
                                        (0017) ;;-----------------------------------------------------------------------------
                                        (0018) ;;  Copyright (c) Cypress Semiconductor 2011. All Rights Reserved.
                                        (0019) ;;*****************************************************************************
                                        (0020) ;;*****************************************************************************
                                        (0021) 
                                        (0022) include "DAC8_1.inc"
                                        (0023) include "m8c.inc"
                                        (0024) include "memory.inc"
                                        (0025) 
                                        (0026) ;-----------------------------------------------
                                        (0027) ;  Global Symbols
                                        (0028) ;-----------------------------------------------
                                        (0029) export  DAC8_1_Start
                                        (0030) export _DAC8_1_Start
                                        (0031) export  DAC8_1_SetPower
                                        (0032) export _DAC8_1_SetPower
                                        (0033) 
                                        (0034) export  DAC8_1_WriteBlind
                                        (0035) export _DAC8_1_WriteBlind
                                        (0036) export  DAC8_1_WriteBlind2B
                                        (0037) export _DAC8_1_WriteBlind2B
                                        (0038) 
                                        (0039) export  DAC8_1_WriteStall
                                        (0040) export _DAC8_1_WriteStall
                                        (0041) export  DAC8_1_WriteStall2B
                                        (0042) export _DAC8_1_WriteStall2B
                                        (0043) 
                                        (0044) export  DAC8_1_Stop
                                        (0045) export _DAC8_1_Stop
                                        (0046) 
                                        (0047) ;-----------------------------------------------
                                        (0048) ;  EQUATES
                                        (0049) ;-----------------------------------------------
                                        (0050) 
                                        (0051) cOFFSET:   equ 127              ; Conversion term for offset binary to 2's C
                                        (0052) bPWRMASK:  equ 03h              ; Power bitfield in Switched Cap CR3 reg
                                        (0053) bSPLITMASK:equ 03h              ; Marks split between MSB and LSB bits
                                        (0054) bSMMASK:   equ 3Fh              ; Sign and Magnitude bits mask
                                        (0055) bSIGNMASK: equ 20h              ; Sign bit mask
                                        (0056) 
                                        (0057)     AREA UserModules (ROM, REL)
                                        (0058) 
                                        (0059) .SECTION
                                        (0060) ;-----------------------------------------------------------------------------
                                        (0061) ;  FUNCTION NAME: DAC8_1_Start
                                        (0062) ;  FUNCTION NAME: DAC8_1_SetPower
                                        (0063) ;
                                        (0064) ;  DESCRIPTION:
                                        (0065) ;    Applies power setting to the module's analog PSoC blocks.
                                        (0066) ;
                                        (0067) ;-----------------------------------------------------------------------------
                                        (0068) ;
                                        (0069) ;  ARGUMENTS:
                                        (0070) ;    A contains the power setting 0=Off, 1=Low, 2=Med, 3=High.
                                        (0071) ;
                                        (0072) ;  RETURNS: none
                                        (0073) ;
                                        (0074) ;  SIDE EFFECTS:
                                        (0075) ;    The A and X registers may be modified by this or future implementations
                                        (0076) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0077) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0078) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0079) ;    functions.
                                        (0080) ;
                                        (0081)  DAC8_1_Start:
                                        (0082) _DAC8_1_Start:
                                        (0083)  DAC8_1_SetPower:
                                        (0084) _DAC8_1_SetPower:
                                        (0085)     RAM_PROLOGUE RAM_USE_CLASS_2
0F6E: 21 03    AND   A,0x3              (0086)     and   A, bPWRMASK       ; trim input to bits of interest
0F70: 4F       MOV   X,SP               (0087)     mov   X, SP             ; Set stack frame pointer
0F71: 08       PUSH  A                  (0088)     push  A
                                        (0089)     ;; read CR3 registers, modify power bits & write back
0F72: 5D 83    MOV   A,REG[0x83]        (0090)     mov   A, reg[DAC8_1_MSB_CR3]
0F74: 21 FC    AND   A,0xFC             (0091)     and   a, ~bPWRMASK      ; clear old setting
0F76: 2B 00    OR    A,[X+0]            (0092)     or    A, [X]            ; set power in MSB register image
0F78: 60 83    MOV   REG[0x83],A        (0093)     mov   reg[DAC8_1_MSB_CR3], A
0F7A: 5D 93    MOV   A,REG[0x93]        (0094)     mov   A, reg[DAC8_1_LSB_CR3]
0F7C: 21 FC    AND   A,0xFC             (0095)     and   a, ~bPWRMASK      ; clear old setting
0F7E: 2B 00    OR    A,[X+0]            (0096)     or    A, [X]            ; set power in LSB register image
0F80: 60 93    MOV   REG[0x93],A        (0097)     mov   reg[DAC8_1_LSB_CR3], A
0F82: 18       POP   A                  (0098)     pop   A
0F83: 70 3F    AND   F,0x3F             
0F85: 71 C0    OR    F,0xC0             
                                        (0099)     RAM_EPILOGUE RAM_USE_CLASS_2
0F87: 7F       RET                      (0100)     ret
                                        (0101) .ENDSECTION
                                        (0102) 
                                        (0103) .SECTION
                                        (0104) ;-----------------------------------------------------------------------------
                                        (0105) ;  FUNCTION NAME: DAC8_1_WriteBlind
                                        (0106) ;  FUNCTION NAME: DAC8_1_WriteBlind2B
                                        (0107) ;
                                        (0108) ;  DESCRIPTION:
                                        (0109) ;    Modify the DAC's update value without worrying about the clocks
                                        (0110) ;    Lowest overhead, but may cause glitches on the output.
                                        (0111) ;
                                        (0112) ;-----------------------------------------------------------------------------
                                        (0113) ;
                                        (0114) ;  ARGUMENTS:
                                        (0115) ;    A contains the update value if data format is offset binary or
                                        (0116) ;    2's complement. If format is 2-byte sign-and-magnitude, the LSB is in
                                        (0117) ;    A (as 00smmmmm) and the MSB is in X (as 00xmm000, where x=s\, the
                                        (0118) ;    inverted sign.
                                        (0119) ;
                                        (0120) ;  RETURNS: none
                                        (0121) ;
                                        (0122) ;  SIDE EFFECTS:
                                        (0123) ;    The A and X registers may be modified by this or future implementations
                                        (0124) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0125) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0126) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0127) ;    functions.
                                        (0128) ;
                                        (0129)  DAC8_1_WriteBlind:
                                        (0130) _DAC8_1_WriteBlind:
                                        (0131)     RAM_PROLOGUE RAM_USE_CLASS_2
                                        (0132)   IF DAC8_1_OFFSETBINARY
                                        (0133)     ;; Data is an unsigned byte value in [0..254] (i.e., 255 unique values).
                                        (0134)     ;; Following converts it to 2's complement:
0F88: 11 7F    SUB   A,0x7F             (0135)     sub   A, cOFFSET            ; Convert to 2's Complement
                                        (0136)   ENDIF
                                        (0137)   IF DAC8_1_OFFSETBINARY | DAC8_1_TWOSCOMPLEMENT
0F8A: 4F       MOV   X,SP               (0138)     mov   X, SP
0F8B: 08       PUSH  A                  (0139)     push  A                     ; Preserve the sign
0F8C: 39 80    CMP   A,0x80             (0140)     cmp   A, 80h                ; negative (or zero)?
0F8E: C0 05    JC    0x0F94             (0141)     jc    BlindAdjustCycles     ;   no: just go on
0F90: 73       CPL   A                  (0142)     cpl   A                     ;  yes: take the 2's Complement
0F91: 74       INC   A                  (0143)     inc   A
0F92: 80 05    JMP   0x0F98             (0144)     jmp   BlindMagSet
                                        (0145) BlindAdjustCycles:
0F94: 73       CPL   A                  (0146)     cpl   A                     ; these 3 instructions implement a 13-cycle
0F95: 73       CPL   A                  (0147)     cpl   A                     ;   NOP so it takes the same amount of time
0F96: 80 01    JMP   0x0F98             (0148)     jmp   BlindMagSet           ;   for both positive and negative numbers.
                                        (0149) BlindMagSet:
0F98: 08       PUSH  A                  (0150)     push  A                     ; preserve LSB magnitude bits
0F99: 27 01 03 AND   [X+1],0x3          (0151)     and   [X+1], bSPLITMASK
0F9C: 27 00 80 AND   [X+0],0x80         (0152)     and   [X], 80h              ; isolate the sign
0F9F: 2B 00    OR    A,[X+0]            (0153)     or    A, [X]                ; insert in MSB
0FA1: 67       ASR   A                  (0154)     asr   A                     ; justify MSB sign & mag
0FA2: 67       ASR   A                  (0155)     asr   A
0FA3: 21 3F    AND   A,0x3F             (0156)     and   A, bSMMASK            ; clear sign extension bits
                                        (0157)                                 ; Set FCap and ClockPhase bits for MSB
0FA5: 54 00    MOV   [X+0],A            (0158)     mov   [X], A                ; stash the MSB
0FA7: 21 20    AND   A,0x20             (0159)     and   A, bSIGNMASK          ; isolate the sign
0FA9: 31 20    XOR   A,0x20             (0160)     xor   A, bSIGNMASK          ;   and invert for LSB
0FAB: 66 01    ASL   [X+1]              (0161)     asl   [X+1]                 ; justify LSB magnitude
0FAD: 66 01    ASL   [X+1]              (0162)     asl   [X+1]
0FAF: 66 01    ASL   [X+1]              (0163)     asl   [X+1]
0FB1: 2B 01    OR    A,[X+1]            (0164)     or    A, [X+1]              ; combine LSB magnitude with sign
                                        (0165)                                 ; Set FCap and ClockPhase bits for LSB
0FB3: 20       POP   X                  (0166)     pop   X                     ; Put MSB in X
0FB4: 20       POP   X                  (0167)     pop   X
                                        (0168)   ENDIF
0FB5: 29 80    OR    A,0x80             (0169)     or    A, DAC8_1_CR0_HIBITS
0FB7: 4B       SWAP  A,X                (0170)     swap  A, X
0FB8: 29 80    OR    A,0x80             (0171)     or    A, DAC8_1_CR0_HIBITS
0FBA: 60 80    MOV   REG[0x80],A        (0172)     mov   reg[DAC8_1_MSB_CR0], A
0FBC: 5B       MOV   A,X                (0173)     mov   A, X
0FBD: 60 90    MOV   REG[0x90],A        (0174)     mov   reg[DAC8_1_LSB_CR0], A
0FBF: 70 3F    AND   F,0x3F             
0FC1: 71 C0    OR    F,0xC0             
                                        (0175)     RAM_EPILOGUE RAM_USE_CLASS_2
0FC3: 7F       RET                      (0176)     ret
                                        (0177) 
                                        (0178) 
                                        (0179)  DAC8_1_WriteBlind2B:
                                        (0180) _DAC8_1_WriteBlind2B:
                                        (0181)     RAM_PROLOGUE RAM_USE_CLASS_1
0FC4: 29 80    OR    A,0x80             (0182)     or    A, DAC8_1_CR0_HIBITS
0FC6: 4B       SWAP  A,X                (0183)     swap  A, X
0FC7: 29 80    OR    A,0x80             (0184)     or    A, DAC8_1_CR0_HIBITS
0FC9: 60 80    MOV   REG[0x80],A        (0185)     mov   reg[DAC8_1_MSB_CR0], A
0FCB: 5B       MOV   A,X                (0186)     mov   A, X
0FCC: 60 90    MOV   REG[0x90],A        (0187)     mov   reg[DAC8_1_LSB_CR0], A
                                        (0188)     RAM_EPILOGUE RAM_USE_CLASS_1
0FCE: 7F       RET                      (0189)     ret
                                        (0190) .ENDSECTION
                                        (0191) 
                                        (0192) .SECTION
                                        (0193) ;-----------------------------------------------------------------------------
                                        (0194) ;  FUNCTION NAME: DAC8_1_WriteStall
                                        (0195) ;  FUNCTION NAME: DAC8_1_WriteStall2B
                                        (0196) ;
                                        (0197) ;  DESCRIPTION:
                                        (0198) ;    Modify the DAC's update value, stalling the CPU if necessary.
                                        (0199) ;    This routine should be used with faster analog clocks or when the
                                        (0200) ;    effect of prolonging interrupt latencies can be safely tolerated.
                                        (0201) ;
                                        (0202) ;-----------------------------------------------------------------------------
                                        (0203) ;
                                        (0204) ;  ARGUMENTS:
                                        (0205) ;   A contains the update value if data format is offset binary or
                                        (0206) ;   2's complement. If format is 2-byte sign-and-magnitude, the LSB is in
                                        (0207) ;   A (as 00smmmmm) and the MSB is in X (as 00xmm000, where x=s\, the
                                        (0208) ;   inverted sign.
                                        (0209) ;
                                        (0210) ;  RETURNS: none
                                        (0211) ;
                                        (0212) ;  SIDE EFFECTS:
                                        (0213) ;
                                        (0214) ;  THEORY of OPERATION or PROCEDURE:
                                        (0215) ;    The A and X registers may be modified by this or future implementations
                                        (0216) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0217) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0218) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0219) ;    functions.
                                        (0220) ;
                                        (0221)  DAC8_1_WriteStall:
                                        (0222) _DAC8_1_WriteStall:
                                        (0223)     RAM_PROLOGUE RAM_USE_CLASS_2
                                        (0224)   IF DAC8_1_OFFSETBINARY
                                        (0225)     ;; Data is an unsigned byte value in [0..254] (i.e., 255 unique values).
                                        (0226)     ;; Following converts it to 2's complement:
0FCF: 11 7F    SUB   A,0x7F             (0227)     sub   A, cOFFSET            ; Convert to 2's Complement
                                        (0228)   ENDIF
                                        (0229)   IF DAC8_1_OFFSETBINARY | DAC8_1_TWOSCOMPLEMENT
0FD1: 4F       MOV   X,SP               (0230)     mov   X, SP
0FD2: 08       PUSH  A                  (0231)     push  A                     ; Preserve the sign
0FD3: 39 80    CMP   A,0x80             (0232)     cmp   A, 80h                ; negative (or zero)?
0FD5: C0 05    JC    0x0FDB             (0233)     jc    StallAdjustCycles     ;   no: just go on
0FD7: 73       CPL   A                  (0234)     cpl   A                     ;  yes: take the 2's Complement
0FD8: 74       INC   A                  (0235)     inc   A
0FD9: 80 05    JMP   0x0FDF             (0236)     jmp   StallMagSet
                                        (0237) StallAdjustCycles:
0FDB: 73       CPL   A                  (0238)     cpl   A                     ; these 3 instructions implement a 13-cycle
0FDC: 73       CPL   A                  (0239)     cpl   A                     ;   NOP so it takes the same amount of time
0FDD: 80 01    JMP   0x0FDF             (0240)     jmp   StallMagSet           ;   for both positive and negative numbers.
                                        (0241) StallMagSet:
0FDF: 08       PUSH  A                  (0242)     push  A                     ; preserve LSB magnitude bits
0FE0: 27 01 03 AND   [X+1],0x3          (0243)     and   [X+1], bSPLITMASK
0FE3: 27 00 80 AND   [X+0],0x80         (0244)     and   [X], 80h              ; isolate the sign
0FE6: 2B 00    OR    A,[X+0]            (0245)     or    A, [X]                ; insert in MSB
0FE8: 67       ASR   A                  (0246)     asr   A                     ; justify MSB sign & mag
0FE9: 67       ASR   A                  (0247)     asr   A
0FEA: 21 3F    AND   A,0x3F             (0248)     and   A, bSMMASK            ; clear sign extension bits
                                        (0249)                                 ; Set FCap and ClockPhase bits for MSB
0FEC: 54 00    MOV   [X+0],A            (0250)     mov   [X], A                ; stash the MSB
0FEE: 21 20    AND   A,0x20             (0251)     and   A, bSIGNMASK          ; isolate the sign
0FF0: 31 20    XOR   A,0x20             (0252)     xor   A, bSIGNMASK          ;   and invert for LSB
0FF2: 66 01    ASL   [X+1]              (0253)     asl   [X+1]                 ; justify LSB magnitude
0FF4: 66 01    ASL   [X+1]              (0254)     asl   [X+1]
0FF6: 66 01    ASL   [X+1]              (0255)     asl   [X+1]
0FF8: 2B 01    OR    A,[X+1]            (0256)     or    A, [X+1]              ; combine LSB magnitude with sign
                                        (0257)                                 ; Set FCap and ClockPhase bits for LSB
0FFA: 20       POP   X                  (0258)     pop   X                     ; Put MSB in X
0FFB: 20       POP   X                  (0259)     pop   X
                                        (0260)   ENDIF
0FFC: 29 80    OR    A,0x80             (0261)     or    A, DAC8_1_CR0_HIBITS
0FFE: 4B       SWAP  A,X                (0262)     swap  A, X
0FFF: 29 80    OR    A,0x80             (0263)     or    A, DAC8_1_CR0_HIBITS
1001: 43 65 01 OR    REG[0x65],0x1      
                                        (0264) 
                                        (0265)     M8C_Stall
1004: 60 80    MOV   REG[0x80],A        (0266)     mov   reg[DAC8_1_MSB_CR0], A
1006: 41 65 FE AND   REG[0x65],0xFE     
                                        (0267)     M8C_Unstall
1009: 5B       MOV   A,X                (0268)     mov   A, X
100A: 60 90    MOV   REG[0x90],A        (0269)     mov   reg[DAC8_1_LSB_CR0], A
100C: 70 3F    AND   F,0x3F             
100E: 71 C0    OR    F,0xC0             
                                        (0270)     RAM_EPILOGUE RAM_USE_CLASS_2
1010: 7F       RET                      (0271)     ret
                                        (0272) 
                                        (0273)  DAC8_1_WriteStall2B:
                                        (0274) _DAC8_1_WriteStall2B:
                                        (0275)     RAM_PROLOGUE RAM_USE_CLASS_1
1011: 29 80    OR    A,0x80             (0276)     or    A, DAC8_1_CR0_HIBITS
1013: 4B       SWAP  A,X                (0277)     swap  A, X
1014: 29 80    OR    A,0x80             (0278)     or    A, DAC8_1_CR0_HIBITS
1016: 43 65 01 OR    REG[0x65],0x1      
                                        (0279) 
                                        (0280)     M8C_Stall
1019: 60 80    MOV   REG[0x80],A        (0281)     mov   reg[DAC8_1_MSB_CR0], A
101B: 41 65 FE AND   REG[0x65],0xFE     
                                        (0282)     M8C_Unstall
101E: 5B       MOV   A,X                (0283)     mov   A, X
101F: 60 90    MOV   REG[0x90],A        (0284)     mov   reg[DAC8_1_LSB_CR0], A
                                        (0285)     RAM_EPILOGUE RAM_USE_CLASS_1
1021: 7F       RET                      (0286)     ret
                                        (0287) .ENDSECTION
                                        (0288) 
                                        (0289) .SECTION
                                        (0290) ;-----------------------------------------------------------------------------
                                        (0291) ;  FUNCTION NAME: DAC8_1_Stop
                                        (0292) ;
                                        (0293) ;  DESCRIPTION:
                                        (0294) ;    Cuts power to the user module.
                                        (0295) ;
                                        (0296) ;-----------------------------------------------------------------------------
                                        (0297) ;
                                        (0298) ;  ARGUMENTS: none
                                        (0299) ;
                                        (0300) ;  RETURNS: none
                                        (0301) ;
                                        (0302) ;  SIDE EFFECTS:
                                        (0303) ;    The A and X registers may be modified by this or future implementations
                                        (0304) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0305) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0306) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0307) ;    functions.
                                        (0308) ;
                                        (0309)  DAC8_1_Stop:
                                        (0310) _DAC8_1_Stop:
                                        (0311)     RAM_PROLOGUE RAM_USE_CLASS_1
1022: 41 83 FC AND   REG[0x83],0xFC     (0312)     and  reg[DAC8_1_MSB_CR3], ~bPWRMASK
1025: 41 93 FC AND   REG[0x93],0xFC     (0313)     and  reg[DAC8_1_LSB_CR3], ~bPWRMASK
                                        (0314)     RAM_EPILOGUE RAM_USE_CLASS_1
1028: 7F       RET                      (0315)     ret
                                        (0316) .ENDSECTION
                                        (0317) ; End of File DAC8_1.asm
FILE: lib\adcint.asm                    (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME: ADCINT.asm
                                        (0004) ;;  Version: 1.1, Updated on 2011/3/29 at 14:28:42
                                        (0005) ;;
                                        (0006) ;;  DESCRIPTION: Assembler interrupt service routine for the ADCINC
                                        (0007) ;;               A/D Converter User Module. This code works for both the
                                        (0008) ;;               first and second-order modulator topologies.
                                        (0009) ;;-----------------------------------------------------------------------------
                                        (0010) ;;  Copyright (c) Cypress Semiconductor 2011. All Rights Reserved.
                                        (0011) ;;*****************************************************************************
                                        (0012) ;;*****************************************************************************
                                        (0013) 
                                        (0014) include "m8c.inc"
                                        (0015) include "memory.inc"
                                        (0016) include "ADC.inc"
                                        (0017) 
                                        (0018) 
                                        (0019) ;-----------------------------------------------
                                        (0020) ;  Global Symbols
                                        (0021) ;-----------------------------------------------
                                        (0022) 
                                        (0023) export _ADC_ADConversion_ISR
                                        (0024) 
                                        (0025) export _ADC_iResult
                                        (0026) export  ADC_iResult
                                        (0027) export _ADC_fStatus
                                        (0028) export  ADC_fStatus
                                        (0029) export _ADC_bState
                                        (0030) export  ADC_bState
                                        (0031) export _ADC_fMode
                                        (0032) export  ADC_fMode
                                        (0033) export _ADC_bNumSamples
                                        (0034) export  ADC_bNumSamples
                                        (0035) 
                                        (0036) ;-----------------------------------------------
                                        (0037) ; Variable Allocation
                                        (0038) ;-----------------------------------------------
                                        (0039) AREA InterruptRAM(RAM,REL)
                                        (0040)  ADC_iResult:
                                        (0041) _ADC_iResult:                              BLK  2 ;Calculated answer
                                        (0042)   iTemp:                                   BLK  2 ;internal temp storage
                                        (0043)  ADC_fStatus:
                                        (0044) _ADC_fStatus:                              BLK  1 ;ADC Status
                                        (0045)  ADC_bState:
                                        (0046) _ADC_bState:                               BLK  1 ;State value of ADC count
                                        (0047)  ADC_fMode:
                                        (0048) _ADC_fMode:                                BLK  1 ;Integrate and reset mode.
                                        (0049)  ADC_bNumSamples:
                                        (0050) _ADC_bNumSamples:                          BLK  1 ;Number of samples to take.
                                        (0051) 
                                        (0052) ;-----------------------------------------------
                                        (0053) ;  EQUATES
                                        (0054) ;-----------------------------------------------
                                        (0055) 
                                        (0056) ;@PSoC_UserCode_INIT@ (Do not change this line.)
                                        (0057) ;---------------------------------------------------
                                        (0058) ; Insert your custom declarations below this banner
                                        (0059) ;---------------------------------------------------
                                        (0060) 
                                        (0061) ;------------------------
                                        (0062) ;  Constant Definitions
                                        (0063) ;------------------------
                                        (0064) 
                                        (0065) 
                                        (0066) ;------------------------
                                        (0067) ; Variable Allocation
                                        (0068) ;------------------------
                                        (0069) 
                                        (0070) 
                                        (0071) ;---------------------------------------------------
                                        (0072) ; Insert your custom declarations above this banner
                                        (0073) ;---------------------------------------------------
                                        (0074) ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0075) 
                                        (0076) 
                                        (0077) AREA UserModules (ROM, REL)
                                        (0078) 
                                        (0079) ;-----------------------------------------------------------------------------
                                        (0080) ;  FUNCTION NAME: _ADC_ADConversion_ISR
                                        (0081) ;
                                        (0082) ;  DESCRIPTION: Perform final filter operations to produce output samples.
                                        (0083) ;
                                        (0084) ;-----------------------------------------------------------------------------
                                        (0085) ;
                                        (0086) ;    The decimation rate is established by the PWM interrupt. Four timer
                                        (0087) ;    clocks elapse for each modulator output (decimator input) since the
                                        (0088) ;    phi1/phi2 generator divides by 4. This means the timer period and thus
                                        (0089) ;    it's interrupt must equal 4 times the actual decimation rate.  The
                                        (0090) ;    decimator is ru  for 2^(#bits-6).
                                        (0091) ;
                                        (0092) _ADC_ADConversion_ISR:
1029: 7A 3F    DEC   [0x3F]             (0093)     dec  [ADC_bState]
                                        (0094) if1:
102B: C0 02    JC    0x102E             (0095)     jc endif1 ; no underflow
102D: 7E       RETI                     (0096)     reti
                                        (0097) endif1:
102E: 3C 40 00 CMP   [0x40],0x0         (0098)     cmp [ADC_fMode],0
                                        (0099) if2: 
1031: B0 12    JNZ   0x1044             (0100)     jnz endif2  ;leaving reset mode
1033: 08       PUSH  A                  (0101)     push A                            ;read decimator
1034: 5D E5    MOV   A,REG[0xE5]        (0102)     mov  A, reg[DEC_DL]
1036: 53 3D    MOV   [0x3D],A           (0103)     mov  [iTemp + LowByte],A
1038: 5D E4    MOV   A,REG[0xE4]        (0104)     mov  A, reg[DEC_DH]
103A: 53 3C    MOV   [0x3C],A           (0105)     mov  [iTemp + HighByte], A
103C: 18       POP   A                  (0106)     pop A
103D: 55 40 01 MOV   [0x40],0x1         (0107)     mov [ADC_fMode],1
1040: 55 3F 03 MOV   [0x3F],0x3         (0108)     mov [ADC_bState],((1<<(ADC_bNUMBITS- 6))-1)
1043: 7E       RETI                     (0109)     reti
1044: 43 86 20 OR    REG[0x86],0x20     
1047: 43 87 10 OR    REG[0x87],0x10     
                                        (0110) endif2:
                                        (0111)     ;This code runs at end of integrate
                                        (0112)     ADC_RESET_INTEGRATOR_M
104A: 08       PUSH  A                  (0113)     push A
104B: 5D E5    MOV   A,REG[0xE5]        (0114)     mov  A, reg[DEC_DL]
104D: 12 3D    SUB   A,[0x3D]           (0115)     sub  A,[iTemp + LowByte]
104F: 53 3D    MOV   [0x3D],A           (0116)     mov  [iTemp +LowByte],A
1051: 5D E4    MOV   A,REG[0xE4]        (0117)     mov  A, reg[DEC_DH]
1053: 1A 3C    SBB   A,[0x3C]           (0118)     sbb  A,[iTemp + HighByte]
                                        (0119) 
                                        (0120)        ;check for overflow
                                        (0121) IF     ADC_8_OR_MORE_BITS
1055: 39 01    CMP   A,0x1              (0122)     cmp A,(1<<(ADC_bNUMBITS - 8))
                                        (0123) if3: 
1057: B0 05    JNZ   0x105D             (0124)     jnz endif3 ;overflow
1059: 78       DEC   A                  (0125)     dec A
105A: 55 3D FF MOV   [0x3D],0xFF        (0126)     mov [iTemp + LowByte],ffh
                                        (0127) endif3:
                                        (0128) ELSE
                                        (0129)     cmp [iTemp + LowByte],(1<<(ADC_bNUMBITS))
                                        (0130) if4: 
                                        (0131)     jnz endif4 ;overflow
                                        (0132)     dec [iTemp + LowByte]
                                        (0133) endif4:
                                        (0134) ENDIF
                                        (0135) IF ADC_SIGNED_DATA
                                        (0136) IF ADC_9_OR_MORE_BITS
                                        (0137)     sub A,(1<<(ADC_bNUMBITS - 9))
                                        (0138) ELSE
                                        (0139)     sub [iTemp +LowByte],(1<<(ADC_bNUMBITS - 1))
                                        (0140)     sbb A,0
                                        (0141) ENDIF
                                        (0142) ENDIF
105D: 5F 3B 3D MOV   [0x3B],[0x3D]      (0143)     mov  [ADC_iResult + LowByte],[iTemp +LowByte]
1060: 53 3A    MOV   [0x3A],A           (0144)     mov  [ADC_iResult + HighByte],A
1062: 55 3E 01 MOV   [0x3E],0x1         (0145)     mov  [ADC_fStatus],1
                                        (0146) ConversionReady:
                                        (0147)     ;@PSoC_UserCode_BODY@ (Do not change this line.)
                                        (0148)     ;---------------------------------------------------
                                        (0149)     ; Insert your custom code below this banner
                                        (0150)     ;---------------------------------------------------
                                        (0151)     ;  Sample data is now in iResult
                                        (0152)     ;
                                        (0153)     ;  NOTE: This interrupt service routine has already
                                        (0154)     ;  preserved the values of the A CPU register. If
                                        (0155)     ;  you need to use the X register you must preserve
                                        (0156)     ;  its value and restore it before the return from
                                        (0157)     ;  interrupt.
                                        (0158)     ;---------------------------------------------------
                                        (0159)     ; Insert your custom code above this banner
                                        (0160)     ;---------------------------------------------------
                                        (0161)     ;@PSoC_UserCode_END@ (Do not change this line.)
1065: 18       POP   A                  (0162)     pop A
1066: 3C 41 00 CMP   [0x41],0x0         (0163)     cmp [ADC_bNumSamples],0
                                        (0164) if5: 
1069: B0 0E    JNZ   0x1078             (0165)     jnz endif5 ; Number of samples is zero
106B: 55 40 00 MOV   [0x40],0x0         (0166)     mov [ADC_fMode],0
106E: 55 3F 00 MOV   [0x3F],0x0         (0167)     mov [ADC_bState],0
1071: 41 87 EF AND   REG[0x87],0xEF     
1074: 41 86 DF AND   REG[0x86],0xDF     
                                        (0168)     ADC_ENABLE_INTEGRATOR_M
1077: 7E       RETI                     (0169)     reti       
                                        (0170) endif5:
1078: 7A 41    DEC   [0x41]             (0171)     dec [ADC_bNumSamples]
                                        (0172) if6:
107A: A0 0E    JZ    0x1089             (0173)     jz endif6  ; count not zero
107C: 55 40 00 MOV   [0x40],0x0         (0174)     mov [ADC_fMode],0
107F: 55 3F 00 MOV   [0x3F],0x0         (0175)     mov [ADC_bState],0
1082: 41 87 EF AND   REG[0x87],0xEF     
1085: 41 86 DF AND   REG[0x86],0xDF     
                                        (0176)     ADC_ENABLE_INTEGRATOR_M
1088: 7E       RETI                     (0177)     reti       
1089: 71 10    OR    F,0x10             
                                        (0178) endif6:
                                        (0179)     ;All samples done
                                        (0180)     M8C_SetBank1
108B: 41 E7 3F AND   REG[0xE7],0x3F     (0181)     and reg[E7h], 3Fh            ; if we are in 29xxx or 24x94   
108E: 43 E7 80 OR    REG[0xE7],0x80     (0182)     or  reg[E7h], 80h            ; then set to incremental Mode
1091: 70 EF    AND   F,0xEF             
1093: 41 E1 FE AND   REG[0xE1],0xFE     
                                        (0183)     M8C_SetBank0
                                        (0184)     ADC_STOPADC_M
1096: 7E       RETI                     (0185)  reti 
FILE: lib\adc.asm                       (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME: ADC.asm
                                        (0004) ;;   Version: 1.1, Updated on 2011/3/29 at 14:28:42
                                        (0005) ;;  Generated by PSoC Designer 5.1.2110.0
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: Assembler source for the ADCINC A/D Converter
                                        (0008) ;;               User Module with 1st-order modulator.
                                        (0009) ;;
                                        (0010) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                        (0011) ;;        arguments and observe the associated "Registers are volatile" policy.
                                        (0012) ;;        This means it is the caller's responsibility to preserve any values
                                        (0013) ;;        in the X and A registers that are still needed after the API
                                        (0014) ;;        function returns. Even though these registers may be preserved now,
                                        (0015) ;;        there is no guarantee they will be preserved in future releases.
                                        (0016) ;;-----------------------------------------------------------------------------
                                        (0017) ;;  Copyright (c) Cypress Semiconductor 2011. All Rights Reserved.
                                        (0018) ;;*****************************************************************************
                                        (0019) ;;*****************************************************************************
                                        (0020) 
                                        (0021) include "m8c.inc"
                                        (0022) include "memory.inc"
                                        (0023) 
                                        (0024) include "ADC.inc"
                                        (0025) 
                                        (0026) 
                                        (0027) ;-----------------------------------------------
                                        (0028) ;  Global Symbols
                                        (0029) ;-----------------------------------------------
                                        (0030) export  ADC_Start
                                        (0031) export _ADC_Start
                                        (0032) export  ADC_SetPower
                                        (0033) export _ADC_SetPower
                                        (0034) export  ADC_Stop
                                        (0035) export _ADC_Stop
                                        (0036) export  ADC_GetSamples
                                        (0037) export _ADC_GetSamples
                                        (0038) export  ADC_StopADC
                                        (0039) export _ADC_StopADC
                                        (0040) export  ADC_fIsDataAvailable
                                        (0041) export _ADC_fIsDataAvailable
                                        (0042) export  ADC_iClearFlagGetData
                                        (0043) export _ADC_iClearFlagGetData
                                        (0044) export  ADC_wClearFlagGetData
                                        (0045) export _ADC_wClearFlagGetData
                                        (0046) export  ADC_cClearFlagGetData
                                        (0047) export _ADC_cClearFlagGetData
                                        (0048) export  ADC_bClearFlagGetData
                                        (0049) export _ADC_bClearFlagGetData
                                        (0050) export  ADC_iGetData
                                        (0051) export _ADC_iGetData
                                        (0052) export  ADC_wGetData
                                        (0053) export _ADC_wGetData
                                        (0054) export  ADC_bGetData
                                        (0055) export _ADC_bGetData
                                        (0056) export  ADC_cGetData
                                        (0057) export _ADC_cGetData
                                        (0058) export  ADC_fClearFlag
                                        (0059) export _ADC_fClearFlag
                                        (0060) export  ADC_WritePulseWidth
                                        (0061) export _ADC_WritePulseWidth
                                        (0062) 
                                        (0063) 
                                        (0064) AREA bss (RAM,REL)
                                        (0065) 
                                        (0066) ;-----------------------------------------------
                                        (0067) ;  Constant Definitions
                                        (0068) ;-----------------------------------------------
                                        (0069) 
                                        (0070) ;-----------------------------------------------
                                        (0071) ; Variable Allocation
                                        (0072) ;-----------------------------------------------
                                        (0073) 
                                        (0074) 
                                        (0075) AREA UserModules (ROM, REL)
                                        (0076) 
                                        (0077) .SECTION
                                        (0078) ;-----------------------------------------------------------------------------
                                        (0079) ;  FUNCTION NAME: ADC_Start
                                        (0080) ;
                                        (0081) ;  DESCRIPTION: Applies power setting to the module's analog PSoc block.
                                        (0082) ;               and starts the PWM
                                        (0083) ;-----------------------------------------------------------------------------
                                        (0084) ;
                                        (0085) ;  ARGUMENTS:    The A register contains the power setting.
                                        (0086) ;  RETURNS:      Nothing.
                                        (0087) ;  SIDE EFFECTS:
                                        (0088) ;    The A and X registers may be modified by this or future implementations
                                        (0089) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0090) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0091) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0092) ;    functions.
                                        (0093) ;
                                        (0094)  ADC_Start:
                                        (0095) _ADC_Start:
                                        (0096)    RAM_PROLOGUE RAM_USE_CLASS_1
1097: 90 0D    CALL  _ADC_SetPower      (0097)    call  ADC_SetPower
1099: 43 86 20 OR    REG[0x86],0x20     
109C: 43 87 10 OR    REG[0x87],0x10     
                                        (0098)    ADC_RESET_INTEGRATOR_M
109F: 62 21 FF MOV   REG[0x21],0xFF     (0099)    mov   reg[ADC_PWMdr1],ffh
10A2: 43 23 01 OR    REG[0x23],0x1      (0100)    or    reg[ADC_PWMcr0],01h                         ; start PWM
                                        (0101)    RAM_EPILOGUE RAM_USE_CLASS_1
10A5: 7F       RET                      (0102)    ret
                                        (0103) .ENDSECTION
                                        (0104) 
                                        (0105)    
                                        (0106) .SECTION
                                        (0107) ;-----------------------------------------------------------------------------
                                        (0108) ;  FUNCTION NAME: ADC_SetPower
                                        (0109) ;
                                        (0110) ;  DESCRIPTION: Applies power setting to the module's analog PSoc block.
                                        (0111) ;-----------------------------------------------------------------------------
                                        (0112) ;
                                        (0113) ;  ARGUMENTS:    The A register contains the power setting.
                                        (0114) ;  RETURNS:      Nothing.
                                        (0115) ;  SIDE EFFECTS:
                                        (0116) ;    The A and X registers may be modified by this or future implementations
                                        (0117) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0118) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0119) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0120) ;    functions.
                                        (0121) ;
                                        (0122)  ADC_SetPower:
                                        (0123) _ADC_SetPower:
                                        (0124)    RAM_PROLOGUE RAM_USE_CLASS_2
10A6: 4F       MOV   X,SP               (0125)    mov  X,SP                                     ; Set up Stack frame
10A7: 21 03    AND   A,0x3              (0126)    and  A,03h                                    ; Ensure value is legal
10A9: 08       PUSH  A                  (0127)    push A
10AA: 5D 87    MOV   A,REG[0x87]        (0128)    mov  A,reg[ADC_AtoDcr3]                       ; First SC block:
10AC: 21 FC    AND   A,0xFC             (0129)    and  A,~03h                                   ;   clear power bits to zero
10AE: 2B 00    OR    A,[X+0]            (0130)    or   A,[ X ]                                  ;   establish new value
10B0: 60 87    MOV   REG[0x87],A        (0131)    mov  reg[ADC_AtoDcr3],A                       ;   change the actual setting
10B2: 18       POP   A                  (0132)    pop  A
10B3: 70 3F    AND   F,0x3F             
10B5: 71 C0    OR    F,0xC0             
                                        (0133)    RAM_EPILOGUE RAM_USE_CLASS_2
10B7: 7F       RET                      (0134)    ret
10B8: 41 E1 FE AND   REG[0xE1],0xFE     
                                        (0135) .ENDSECTION
                                        (0136) 
                                        (0137) .SECTION
                                        (0138) ;-----------------------------------------------------------------------------
                                        (0139) ;  FUNCTION NAME: ADC_Stop
                                        (0140) ;
                                        (0141) ;  DESCRIPTION:   Removes power from the module's analog PSoc block.
                                        (0142) ;                 and turns off PWM
                                        (0143) ;-----------------------------------------------------------------------------
                                        (0144) ;
                                        (0145) ;  ARGUMENTS:     None.
                                        (0146) ;  RETURNS:       Nothing.
                                        (0147) ;  SIDE EFFECTS:
                                        (0148) ;    The A and X registers may be modified by this or future implementations
                                        (0149) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0150) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0151) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0152) ;    functions.
                                        (0153) ;
                                        (0154)  ADC_Stop:
                                        (0155) _ADC_Stop:
                                        (0156)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0157)    ADC_STOPADC_M
10BB: 41 87 FC AND   REG[0x87],0xFC     (0158)    and  reg[ADC_AtoDcr3], ~03h
10BE: 41 23 FE AND   REG[0x23],0xFE     (0159)    and  reg[ADC_PWMcr0], ~01h ; stop PWM
                                        (0160)    RAM_EPILOGUE RAM_USE_CLASS_1
10C1: 7F       RET                      (0161)    ret
10C2: 62 D0 00 MOV   REG[0xD0],0x0      
10C5: 41 87 EF AND   REG[0x87],0xEF     
10C8: 41 86 DF AND   REG[0x86],0xDF     
                                        (0162) .ENDSECTION
                                        (0163) 
                                        (0164) 
                                        (0165) .SECTION
                                        (0166) ;-----------------------------------------------------------------------------
                                        (0167) ;  FUNCTION NAME: ADC_GetSamples
                                        (0168) ;
                                        (0169) ;  DESCRIPTION: Activates interrupts for this user module and begins sampling.
                                        (0170) ;-----------------------------------------------------------------------------
                                        (0171) ;
                                        (0172) ;  ARGUMENTS:    A register contain number of samples
                                        (0173) ;  RETURNS:      Nothing.
                                        (0174) ;  SIDE EFFECTS:
                                        (0175) ;    The A and X registers may be modified by this or future implementations
                                        (0176) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0177) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0178) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0179) ;    functions.
                                        (0180) ;          
                                        (0181) ;    Currently only the page pointer registers listed below are modified: 
                                        (0182) ;          CUR_PP
                                        (0183) ;
                                        (0184)  ADC_GetSamples:
                                        (0185) _ADC_GetSamples:
                                        (0186)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0187)    RAM_SETPAGE_CUR >ADC_fMode
                                        (0188)    ADC_ENABLE_INTEGRATOR_M
10CB: 55 40 00 MOV   [0x40],0x0         (0189)    mov [ADC_fMode],0
10CE: 55 3F 00 MOV   [0x3F],0x0         (0190)    mov [ADC_bState],0
10D1: 53 41    MOV   [0x41],A           (0191)    mov [ADC_bNumSamples],A
10D3: 5D 22    MOV   A,REG[0x22]        (0192)    mov A, reg[ADC_PWMdr2]
10D5: B0 04    JNZ   0x10DA             (0193)    jnz  .SkipPulseWrite
10D7: 62 22 01 MOV   REG[0x22],0x1      (0194)    mov reg[ADC_PWMdr2], 1
10DA: 71 10    OR    F,0x10             
                                        (0195) .SkipPulseWrite:
                                        (0196) 
                                        (0197)    M8C_SetBank1
10DC: 41 E7 3F AND   REG[0xE7],0x3F     (0198)    and reg[E7h], 3Fh             ; if we are in 29xxx or 24x94   
10DF: 43 E7 40 OR    REG[0xE7],0x40     (0199)    or  reg[E7h], 40h             ; then set to incremental Mode
10E2: 70 EF    AND   F,0xEF             
10E4: 62 DB FE MOV   REG[0xDB],0xFE     
10E7: 43 E1 01 OR    REG[0xE1],0x1      
                                        (0200)    M8C_SetBank0
                                        (0201) 
                                        (0202)    ADC_STARTADC_M  ;enable interrupt 
                                        (0203)    RAM_EPILOGUE RAM_USE_CLASS_4 
10EA: 7F       RET                      (0204)    ret
10EB: 71 10    OR    F,0x10             
                                        (0205) .ENDSECTION
                                        (0206) 
                                        (0207) 
                                        (0208) .SECTION
                                        (0209) ;-----------------------------------------------------------------------------
                                        (0210) ;  FUNCTION NAME: ADC_StopADC
                                        (0211) ;
                                        (0212) ;  DESCRIPTION: Shuts down the A/D is an orderly manner.  The interrupt
                                        (0213) ;               is disabled but the PWM output is still active.
                                        (0214) ;               Integrator is reset
                                        (0215) ;-----------------------------------------------------------------------------
                                        (0216) ;
                                        (0217) ;  ARGUMENTS:    None.
                                        (0218) ;  RETURNS:      Nothing.
                                        (0219) ;  SIDE EFFECTS:
                                        (0220) ;    The A and X registers may be modified by this or future implementations
                                        (0221) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0222) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0223) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0224) ;    functions.
                                        (0225) ;
                                        (0226)  ADC_StopADC:
                                        (0227) _ADC_StopADC:
                                        (0228)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0229)    M8C_SetBank1
10ED: 41 E7 3F AND   REG[0xE7],0x3F     (0230)    and reg[E7h], 3Fh             ; if we are in 29xxx or 24x94   
10F0: 43 E7 80 OR    REG[0xE7],0x80     (0231)    or  reg[E7h], 80h             ; then set to incremental Mode
10F3: 70 EF    AND   F,0xEF             
10F5: 41 E1 FE AND   REG[0xE1],0xFE     
10F8: 43 86 20 OR    REG[0x86],0x20     
10FB: 43 87 10 OR    REG[0x87],0x10     
                                        (0232)    M8C_SetBank0
                                        (0233)    ADC_STOPADC_M
                                        (0234)    ADC_RESET_INTEGRATOR_M
                                        (0235)    RAM_EPILOGUE RAM_USE_CLASS_1 
10FE: 7F       RET                      (0236)    ret
10FF: 62 D0 00 MOV   REG[0xD0],0x0      
1102: 51 3E    MOV   A,[0x3E]           
                                        (0237) .ENDSECTION
                                        (0238) 
                                        (0239) 
                                        (0240) .SECTION
                                        (0241) ;-----------------------------------------------------------------------------
                                        (0242) ;  FUNCTION NAME: ADC_fIsDataAvailable
                                        (0243) ;
                                        (0244) ;  DESCRIPTION: Returns the status of the A/D Data
                                        (0245) ;-----------------------------------------------------------------------------
                                        (0246) ;  ARGUMENTS:    None.
                                        (0247) ;  RETURNS:      fastcall BOOL DataAvailable returned in the A register
                                        (0248) ;  SIDE EFFECTS:
                                        (0249) ;    The A and X registers may be modified by this or future implementations
                                        (0250) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0251) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0252) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0253) ;    functions.
                                        (0254) ;          
                                        (0255) ;    Currently only the page pointer registers listed below are modified: 
                                        (0256) ;          CUR_PP
                                        (0257) ;
                                        (0258)  ADC_fIsDataAvailable:
                                        (0259) _ADC_fIsDataAvailable:
                                        (0260)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0261)    ADC_fIsDataAvailable_M   
                                        (0262)    RAM_EPILOGUE RAM_USE_CLASS_4
1104: 7F       RET                      (0263)    ret
1105: 62 D0 00 MOV   REG[0xD0],0x0      
1108: 55 3E 00 MOV   [0x3E],0x0         
110B: 58 3A    MOV   X,[0x3A]           
110D: 51 3B    MOV   A,[0x3B]           
110F: 3C 3E 00 CMP   [0x3E],0x0         
1112: BF F5    JNZ   0x1108             
                                        (0264) .ENDSECTION
                                        (0265) 
                                        (0266) 
                                        (0267) .SECTION
                                        (0268) ;-----------------------------------------------------------------------------
                                        (0269) ;  FUNCTION NAME:  ADC_iClearFlagGetData
                                        (0270) ;                  ADC_wClearFlagGetData
                                        (0271) ;
                                        (0272) ;  DESCRIPTION:    Clears the fStatus and places ADC data in iResult A/D.
                                        (0273) ;                  Flag is checked after trandfer to insure valid data.
                                        (0274) ;                  available. Also clears the DATA_READY flag. 
                                        (0275) ;-----------------------------------------------------------------------------
                                        (0276) ;  ARGUMENTS:    None.
                                        (0277) ;  RETURNS:      fastcall int iResult returned in the X and A register
                                        (0278) ;  SIDE EFFECTS:
                                        (0279) ;    The A and X registers may be modified by this or future implementations
                                        (0280) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0281) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0282) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0283) ;    functions.
                                        (0284) ;          
                                        (0285) ;    Currently only the page pointer registers listed below are modified: 
                                        (0286) ;          CUR_PP
                                        (0287) ;
                                        (0288)  ADC_iClearFlagGetData:
                                        (0289) _ADC_iClearFlagGetData:
                                        (0290)  ADC_wClearFlagGetData:
                                        (0291) _ADC_wClearFlagGetData:
                                        (0292)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0293)    ADC_iClearFlagGetData_M   
                                        (0294)    RAM_EPILOGUE RAM_USE_CLASS_4
1114: 7F       RET                      (0295)    ret
1115: 62 D0 00 MOV   REG[0xD0],0x0      
1118: 55 3E 00 MOV   [0x3E],0x0         
111B: 51 3B    MOV   A,[0x3B]           
                                        (0296) .ENDSECTION
                                        (0297) 
                                        (0298) 
                                        (0299) .SECTION
                                        (0300) ;-----------------------------------------------------------------------------
                                        (0301) ;  FUNCTION NAME:  ADC_cClearFlagGetData
                                        (0302) ;                  ADC_bClearFlagGetData
                                        (0303) ;
                                        (0304) ;  DESCRIPTION:    Clears the fStatus and places ADC data in iResult A/D.
                                        (0305) ;-----------------------------------------------------------------------------
                                        (0306) ;  ARGUMENTS:    None.
                                        (0307) ;  RETURNS:      fastcall int iResult returned in the X and A register
                                        (0308) ;  SIDE EFFECTS:
                                        (0309) ;    The A and X registers may be modified by this or future implementations
                                        (0310) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0311) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0312) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0313) ;    functions.
                                        (0314) ;          
                                        (0315) ;    Currently only the page pointer registers listed below are modified: 
                                        (0316) ;          CUR_PP
                                        (0317) ;
                                        (0318)  ADC_cClearFlagGetData:
                                        (0319) _ADC_cClearFlagGetData:
                                        (0320)  ADC_bClearFlagGetData:
                                        (0321) _ADC_bClearFlagGetData:
                                        (0322)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0323)    ADC_bClearFlagGetData_M     
                                        (0324)    RAM_EPILOGUE RAM_USE_CLASS_4
111D: 7F       RET                      (0325)    ret
111E: 62 D0 00 MOV   REG[0xD0],0x0      
1121: 58 3A    MOV   X,[0x3A]           
1123: 51 3B    MOV   A,[0x3B]           
                                        (0326) .ENDSECTION
                                        (0327) .SECTION
                                        (0328) ;-----------------------------------------------------------------------------
                                        (0329) ;  FUNCTION NAME:  ADC_iGetData
                                        (0330) ;				   ADC_wGetData
                                        (0331) ;
                                        (0332) ;  DESCRIPTION:     Returns the data from the A/D.  Does not check if data is
                                        (0333) ;                   available.
                                        (0334) ;-----------------------------------------------------------------------------
                                        (0335) ;  ARGUMENTS:    None.
                                        (0336) ;  RETURNS:      fastcall int iResult is returned in the X,A registers
                                        (0337) ;  SIDE EFFECTS:
                                        (0338) ;    The A and X registers may be modified by this or future implementations
                                        (0339) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0340) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0341) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0342) ;    functions.
                                        (0343) ;          
                                        (0344) ;    Currently only the page pointer registers listed below are modified: 
                                        (0345) ;          CUR_PP
                                        (0346) ;
                                        (0347)  ADC_iGetData:
                                        (0348) _ADC_iGetData:
                                        (0349)  ADC_wGetData:
                                        (0350) _ADC_wGetData:
                                        (0351)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0352)    ADC_wGetData_M          
                                        (0353)    RAM_EPILOGUE RAM_USE_CLASS_4
1125: 7F       RET                      (0354)    ret
1126: 62 D0 00 MOV   REG[0xD0],0x0      
1129: 51 3B    MOV   A,[0x3B]           
                                        (0355) .ENDSECTION
                                        (0356) .SECTION
                                        (0357) ;-----------------------------------------------------------------------------
                                        (0358) ;  FUNCTION NAME:  ADC_bGetData
                                        (0359) ;                  ADC_cGetData
                                        (0360) ;
                                        (0361) ;  DESCRIPTION:     Returns the data from the A/D.  Does not check if data is
                                        (0362) ;                   available.
                                        (0363) ;-----------------------------------------------------------------------------
                                        (0364) ;  ARGUMENTS:    None.
                                        (0365) ;  RETURNS:      fastcall CHAR cData returned in the A register
                                        (0366) ;  SIDE EFFECTS:
                                        (0367) ;    The A and X registers may be modified by this or future implementations
                                        (0368) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0369) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0370) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0371) ;    functions.
                                        (0372) ;          
                                        (0373) ;    Currently only the page pointer registers listed below are modified: 
                                        (0374) ;          CUR_PP
                                        (0375) ;
                                        (0376)  ADC_bGetData:
                                        (0377) _ADC_bGetData:
                                        (0378)  ADC_cGetData:
                                        (0379) _ADC_cGetData:
                                        (0380)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0381)    ADC_cGetData_M        
                                        (0382)    RAM_EPILOGUE RAM_USE_CLASS_4
112B: 7F       RET                      (0383)    ret
112C: 62 D0 00 MOV   REG[0xD0],0x0      
112F: 51 3E    MOV   A,[0x3E]           
1131: 55 3E 00 MOV   [0x3E],0x0         
                                        (0384) .ENDSECTION
                                        (0385) 
                                        (0386) 
                                        (0387) .SECTION
                                        (0388) ;-----------------------------------------------------------------------------
                                        (0389) ;  FUNCTION NAME: ADC_fClearFlag
                                        (0390) ;
                                        (0391) ;  DESCRIPTION: Clears the data ready flag.
                                        (0392) ;-----------------------------------------------------------------------------
                                        (0393) ;  ARGUMENTS:    None.
                                        (0394) ;  RETURNS:      Nothing.
                                        (0395) ;  SIDE EFFECTS: 
                                        (0396) ;    The DATA_READY flag is cleared.
                                        (0397) ;    
                                        (0398) ;    The A and X registers may be modified by this or future implementations
                                        (0399) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0400) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0401) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0402) ;    functions.
                                        (0403) ;          
                                        (0404) ;    Currently only the page pointer registers listed below are modified: 
                                        (0405) ;          CUR_PP
                                        (0406) ;
                                        (0407)  ADC_fClearFlag:
                                        (0408) _ADC_fClearFlag:
                                        (0409)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0410)    ADC_fClearFlag_M    
                                        (0411)    RAM_EPILOGUE RAM_USE_CLASS_4
1134: 7F       RET                      (0412)    ret
1135: 60 22    MOV   REG[0x22],A        
                                        (0413) .ENDSECTION
                                        (0414) 
                                        (0415) 
                                        (0416) .SECTION
                                        (0417) ;-----------------------------------------------------------------------------
                                        (0418) ;  FUNCTION NAME: ADC_WritePulseWidth
                                        (0419) ;
                                        (0420) ;  DESCRIPTION:
                                        (0421) ;     Write the 8-bit period value into the compare register (DR2).
                                        (0422) ;-----------------------------------------------------------------------------
                                        (0423) ;
                                        (0424) ;  ARGUMENTS: fastcall BYTE bPeriodValue (passed in A)
                                        (0425) ;  RETURNS:   Nothing
                                        (0426) ;  SIDE EFFECTS:
                                        (0427) ;    The A and X registers may be modified by this or future implementations
                                        (0428) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0429) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0430) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0431) ;    functions.
                                        (0432) ;
                                        (0433)  ADC_WritePulseWidth:
                                        (0434) _ADC_WritePulseWidth:
                                        (0435)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0436)    ADC_WritePulseWidth_M  
                                        (0437)    RAM_EPILOGUE RAM_USE_CLASS_1
1137: 7F       RET                      (0438)    ret
                                        (0439) .ENDSECTION
                                        (0440) 
                                        (0441) ; End of File ADC.asm
FILE: D:\Univer\3.1\MICROP~1\CY3214~1\Firmware\USBUART\USBUART\USBUART\main.c
(0001) /*******************************************************************************
(0002) * File Name: Main.c
(0003) * Version 1.0
(0004) *
(0005) * Description:
(0006) * This file contains the main function for the USBUART example project for CY3214 PSoCEvalUSB Kit.
(0007) *
(0008) * Note:
(0009) *
(0010) ********************************************************************************
(0011) * Copyright (2011), Cypress Semiconductor Corporation. All rights reserved.
(0012) ********************************************************************************
(0013) * This software is owned by Cypress Semiconductor Corporation (Cypress) and is
(0014) * protected by and subject to worldwide patent protection (United States and
(0015) * foreign),United States copyright laws and international treaty provisions. 
(0016) * Cypress hereby grants to licensee a personal, non-exclusive, non-transferable
(0017) * license to copy, use, modify, create derivative works of, and compile the
(0018) * Cypress Source Code and derivative works for the sole purpose of creating 
(0019) * custom software in support of licensee product to be used only in conjunction
(0020) * with a Cypress integrated circuit as specified in the applicable agreement.
(0021) * Any reproduction, modification, translation, compilation, or representation of
(0022) * this software except as specified above is prohibited without the express
(0023) * written permission of Cypress.
(0024) *
(0025) * Disclaimer: CYPRESS MAKES NO WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, WITH
(0026) * REGARD TO THIS MATERIAL, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
(0027) * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
(0028) * Cypress reserves the right to make changes without further notice to the
(0029) * materials described herein. Cypress does not assume any liability arising out
(0030) * of the application or use of any product or circuit described herein. Cypress 
(0031) * does not authorize its products for use as critical components in life-support
(0032) * systems where a malfunction or failure may reasonably be expected to result in 
(0033) * significant injury to the user. The inclusion of Cypress' product in a life-
(0034) * support systems application implies that the manufacturer assumes all risk of
(0035) * such use and in doing so indemnifies Cypress against all charges. Use may be
(0036) * limited by and subject to the applicable Cypress software license agreement. 
(0037) *******************************************************************************/
(0038) 
(0039) /*************************************************************************************
(0040)                                 THEORY OF OPERATION
(0041) * This project demonstrates the use of USBUART user module using CY3214 PSoCEvalUSB Board.
(0042) * The USBUART user module is used to create a virtual RS232 port on PC using a USB port.
(0043) * The USBUART modules enumerates as a Comm Port device and data to and fro from the USb device is handled as a RS232 device data.
(0044) 
(0045) * This application demonstrates a simple data echo example. The data received from is transmitted back again.
(0046) * The application starts by executing "boot.asm". "boot.asm" does the
(0047) * hardware initialization and invokes the "main" function.  The "main"
(0048) * function completes the initialization of USBUART Module
(0049) * After initialization of the User Modules, the "main" enters into a loop
(0050) * which does the following:
(0051) *     -Checks if any data is received by looking at the count of received data
(0052) *     -Waits for transmit to be ready
(0053) *	  -the received data is transmitted back.
(0054) *     - Incase of reception of a Carraige Return, tha API to send CRLF is called.
(0055) 
(0056) * Hardware Connections
(0057) * Connect a USB cable from the board to a free USB port on PC
(0058) * On connecting for first time, wait for device to get installed.
(0059) * Ignore the Digital Signature warning when prompted. (Click on 'Continue Anyway')
(0060) * Check the Device Manager for the comm port number alloted for USBUART device
(0061) * Open Hyperterminal and connect to the required comm port
(0062) * Set the comm port settings as follows: 19200-N-8-1. FlowControl: None
(0063) * Now type any character and see the data being echoed back on the hyper terminal screen
(0064) * Note: By default, the local echo ing of characters is disabled in Hyperterminal.
(0065) *************************************************************************************/
(0066) 
(0067) 
(0068) #include <m8c.h>        /* part specific constants and macros */
(0069) #include "PSoCAPI.h"    /* PSoC API definitions for all User Modules */
(0070) #include <stdlib.h>
(0071) 
(0072) #define USB_STR_SIZE 		(3)
(0073) 
(0074) #define PERIOD  			(10)				// one measure period time
(0075) #define START_TEST_PERIOD 	(50000)				// delay before start measurement
(0076) 
(0077) #define DAC_VAL				(155)
(0078) #define PERCENTEG			(20)       			// shparyvatist
(0079) #define ANALOG_OFSET		(5)
(0080) #define ANALOG_SIZE  		(95+ANALOG_OFSET)
(0081) 
(0082) BYTE analog[ANALOG_SIZE];
(0083) BYTE measure_analog[ANALOG_SIZE];
(0084) 
(0085) char pTemp[USB_STR_SIZE] = "";
(0086) 
(0087) void load_analog_data(void)
(0088) {
__UserModules_end|__text_start|_load_analog_data|_load_analog_data:
  i                    --> X+0
    1138: 10       PUSH  X
    1139: 4F       MOV   X,SP
    113A: 38 01    ADD   SP,0x1
(0089) 	BYTE i;
(0090) 	for (i=0; i<ANALOG_SIZE; i++)
    113C: 56 00 00 MOV   [X+0],0x0
    113F: 80 40    JMP   0x1180
(0091) 	{
(0092) 		if ((i>ANALOG_OFSET)&&(i<ANALOG_OFSET+PERCENTEG))
    1141: 50 05    MOV   A,0x5
    1143: 3B 00    CMP   A,[X+0]
    1145: D0 20    JNC   0x1166
    1147: 3D 00 19 CMP   [X+0],0x19
    114A: D0 1B    JNC   0x1166
(0093) 		{
(0094) 			analog[i] = DAC_VAL;
    114C: 62 D0 00 MOV   REG[0xD0],0x0
    114F: 52 00    MOV   A,[X+0]
    1151: 53 AB    MOV   [__r1],A
    1153: 55 AC 00 MOV   [__r0],0x0
    1156: 06 AB 42 ADD   [__r1],0x42
    1159: 0E AC 00 ADC   [__r0],0x0
    115C: 51 AC    MOV   A,[__r0]
    115E: 60 D5    MOV   REG[0xD5],A
    1160: 50 9B    MOV   A,0x9B
    1162: 3F AB    MVI   [__r1],A
(0095) 		}
    1164: 80 19    JMP   0x117E
(0096) 		else
(0097) 		{
(0098) 			analog[i] = 0;
    1166: 62 D0 00 MOV   REG[0xD0],0x0
    1169: 52 00    MOV   A,[X+0]
    116B: 53 AB    MOV   [__r1],A
    116D: 55 AC 00 MOV   [__r0],0x0
    1170: 06 AB 42 ADD   [__r1],0x42
    1173: 0E AC 00 ADC   [__r0],0x0
    1176: 51 AC    MOV   A,[__r0]
    1178: 60 D5    MOV   REG[0xD5],A
    117A: 50 00    MOV   A,0x0
    117C: 3F AB    MVI   [__r1],A
(0099) 		}
(0100) 	}
    117E: 77 00    INC   [X+0]
    1180: 3D 00 64 CMP   [X+0],0x64
    1183: CF BD    JC    0x1141
    1185: 38 FF    ADD   SP,0xFF
    1187: 20       POP   X
    1188: 7F       RET   
(0101) }
(0102) 
(0103) void delay(int count)
(0104) {
_delay:
  i                    --> X+0
  count                --> X-5
    1189: 10       PUSH  X
    118A: 4F       MOV   X,SP
    118B: 38 02    ADD   SP,0x2
(0105) 	int i;
(0106) 	for (i=count; i; i--)		// 10000 = Delay about 0.1 seccond
    118D: 52 FC    MOV   A,[X-4]
    118F: 54 01    MOV   [X+1],A
    1191: 52 FB    MOV   A,[X-5]
    1193: 54 00    MOV   [X+0],A
    1195: 80 07    JMP   0x119D
(0107) 	{
(0108) 		asm("nop");
    1197: 40       NOP   
(0109) 	}
    1198: 7B 01    DEC   [X+1]
    119A: 1F 00 00 SBB   [X+0],0x0
    119D: 3D 00 00 CMP   [X+0],0x0
    11A0: BF F6    JNZ   0x1197
    11A2: 3D 01 00 CMP   [X+1],0x0
    11A5: BF F1    JNZ   0x1197
    11A7: 38 FE    ADD   SP,0xFE
    11A9: 20       POP   X
    11AA: 7F       RET   
(0110) }
(0111) 
(0112) void clear_pTemp(void)
(0113) {
_clear_pTemp:
  i                    --> X+0
    11AB: 10       PUSH  X
    11AC: 4F       MOV   X,SP
    11AD: 38 01    ADD   SP,0x1
(0114) 	BYTE i;
(0115) 	for (i=0; i<USB_STR_SIZE; i++)
    11AF: 56 00 00 MOV   [X+0],0x0
    11B2: 80 32    JMP   0x11E5
(0116) 	{
(0117) 		if (pTemp[i]==0)
    11B4: 62 D0 00 MOV   REG[0xD0],0x0
    11B7: 52 00    MOV   A,[X+0]
    11B9: 53 AB    MOV   [__r1],A
    11BB: 55 AC 00 MOV   [__r0],0x0
    11BE: 06 AB AD ADD   [__r1],0xAD
    11C1: 0E AC 00 ADC   [__r0],0x0
    11C4: 51 AC    MOV   A,[__r0]
    11C6: 60 D4    MOV   REG[0xD4],A
    11C8: 3E AB    MVI   A,[__r1]
    11CA: 39 00    CMP   A,0x0
    11CC: B0 16    JNZ   0x11E3
(0118) 		{
(0119) 			pTemp[i] = 0x20;
    11CE: 52 00    MOV   A,[X+0]
    11D0: 53 AB    MOV   [__r1],A
    11D2: 55 AC 00 MOV   [__r0],0x0
    11D5: 06 AB AD ADD   [__r1],0xAD
    11D8: 0E AC 00 ADC   [__r0],0x0
    11DB: 51 AC    MOV   A,[__r0]
    11DD: 60 D5    MOV   REG[0xD5],A
    11DF: 50 20    MOV   A,0x20
    11E1: 3F AB    MVI   [__r1],A
(0120) 		}
(0121) 	}
    11E3: 77 00    INC   [X+0]
    11E5: 3D 00 03 CMP   [X+0],0x3
    11E8: CF CB    JC    0x11B4
    11EA: 38 FF    ADD   SP,0xFF
    11EC: 20       POP   X
    11ED: 7F       RET   
(0122) }
(0123) 
(0124) void main(void)
(0125) {
_main:
  current_adc_data     --> X+2
  i                    --> X+1
  index                --> X+0
    11EE: 10       PUSH  X
    11EF: 4F       MOV   X,SP
    11F0: 38 03    ADD   SP,0x3
(0126) 	BYTE i;
(0127) 	BYTE index=0;
    11F2: 56 00 00 MOV   [X+0],0x0
(0128) 	BYTE current_adc_data;
(0129) 	M8C_EnableGInt; 							/* Enable Global Interrupts */
    11F5: 71 01    OR    F,0x1
(0130) 	USBUART_1_Start(USBUART_1_5V_OPERATION); 	/*Start USBUART 5V operation */
    11F7: 10       PUSH  X
    11F8: 50 03    MOV   A,0x3
    11FA: 7C 0B 96 LCALL _USBUART_1_Start
    11FD: 20       POP   X
(0131) 	while(!USBUART_1_Init()); 					/* Wait for Device to initialize */
    11FE: 10       PUSH  X
    11FF: 7C 0E 64 LCALL _USBUART_1_Init
    1202: 62 D0 00 MOV   REG[0xD0],0x0
    1205: 20       POP   X
    1206: 39 00    CMP   A,0x0
    1208: AF F5    JZ    0x11FE
(0132) 	for (i=20; i; i--)
    120A: 56 01 14 MOV   [X+1],0x14
    120D: 80 0D    JMP   0x121B
(0133) 	{
(0134) 		delay(START_TEST_PERIOD);
    120F: 50 C3    MOV   A,0xC3
    1211: 08       PUSH  A
    1212: 50 50    MOV   A,0x50
    1214: 08       PUSH  A
    1215: 9F 72    CALL  _delay
    1217: 38 FE    ADD   SP,0xFE
(0135) 	}
    1219: 7B 01    DEC   [X+1]
    121B: 3D 01 00 CMP   [X+1],0x0
    121E: BF F0    JNZ   0x120F
(0136) 	USBUART_1_CPutString("Start Test");
    1220: 10       PUSH  X
    1221: 50 01    MOV   A,0x1
    1223: 08       PUSH  A
    1224: 50 C3    MOV   A,0xC3
    1226: 5C       MOV   X,A
    1227: 18       POP   A
    1228: 7C 0C E8 LCALL _USBUART_1_CPutString
(0137) 	USBUART_1_PutCRLF();
    122B: 7C 0D 26 LCALL _USBUART_1_PutCRLF
    122E: 20       POP   X
(0138) 	DAC8_1_Start(DAC8_1_HIGHPOWER);        		/* start the DAC8_1  */
    122F: 10       PUSH  X
    1230: 50 03    MOV   A,0x3
    1232: 7C 0F 6E LCALL _DAC8_1_SetPower|_DAC8_1_Start|DAC8_1_SetPower|DAC8_1_Start
    1235: 20       POP   X
(0139) 	DAC8_1_WriteBlind(0);
    1236: 10       PUSH  X
    1237: 50 00    MOV   A,0x0
    1239: 7C 0F 88 LCALL _DAC8_1_WriteBlind
    123C: 20       POP   X
(0140) 	ADC_Start(ADC_HIGHPOWER);
    123D: 10       PUSH  X
    123E: 50 03    MOV   A,0x3
    1240: 7C 10 97 LCALL _ADC_Start
    1243: 20       POP   X
(0141) 	ADC_GetSamples(0);
    1244: 10       PUSH  X
    1245: 50 00    MOV   A,0x0
    1247: 7C 10 C2 LCALL _ADC_GetSamples
    124A: 20       POP   X
(0142) 	delay(START_TEST_PERIOD);
    124B: 50 C3    MOV   A,0xC3
    124D: 08       PUSH  A
    124E: 50 50    MOV   A,0x50
    1250: 08       PUSH  A
    1251: 9F 36    CALL  _delay
    1253: 38 FE    ADD   SP,0xFE
(0143) 	// Start measurement
(0144) 	load_analog_data();
    1255: 9E E1    CALL  __UserModules_end|__text_start|_load_analog_data|_load_analog_data
(0145) 	for (index=0; index<ANALOG_SIZE; index++)
    1257: 56 00 00 MOV   [X+0],0x0
    125A: 80 53    JMP   0x12AE
(0146) 	{
(0147) 		DAC8_1_WriteBlind(analog[index]);
    125C: 62 D0 00 MOV   REG[0xD0],0x0
    125F: 52 00    MOV   A,[X+0]
    1261: 53 AB    MOV   [__r1],A
    1263: 55 AC 00 MOV   [__r0],0x0
    1266: 06 AB 42 ADD   [__r1],0x42
    1269: 0E AC 00 ADC   [__r0],0x0
    126C: 51 AC    MOV   A,[__r0]
    126E: 60 D4    MOV   REG[0xD4],A
    1270: 3E AB    MVI   A,[__r1]
    1272: 10       PUSH  X
    1273: 7C 0F 88 LCALL _DAC8_1_WriteBlind
    1276: 20       POP   X
(0148) 		delay(PERIOD);
    1277: 50 00    MOV   A,0x0
    1279: 08       PUSH  A
    127A: 50 0A    MOV   A,0xA
    127C: 08       PUSH  A
    127D: 9F 0A    CALL  _delay
    127F: 38 FE    ADD   SP,0xFE
(0149) 		while(ADC_fIsDataAvailable() == 0);   	// Loop until value ready 
    1281: 10       PUSH  X
    1282: 7C 10 FF LCALL _ADC_fIsDataAvailable
    1285: 62 D0 00 MOV   REG[0xD0],0x0
    1288: 20       POP   X
    1289: 39 00    CMP   A,0x0
    128B: AF F5    JZ    0x1281
(0150) 		current_adc_data = ADC_bClearFlagGetData();
    128D: 10       PUSH  X
    128E: 7C 11 15 LCALL ADC_cClearFlagGetData|_ADC_bClearFlagGetData|_ADC_cClearFlagGetData|ADC_bClearFlagGetData
    1291: 62 D0 00 MOV   REG[0xD0],0x0
    1294: 20       POP   X
    1295: 54 02    MOV   [X+2],A
(0151) 		measure_analog[index] = current_adc_data;
    1297: 52 00    MOV   A,[X+0]
    1299: 53 AB    MOV   [__r1],A
    129B: 55 AC 00 MOV   [__r0],0x0
    129E: 06 AB 00 ADD   [__r1],0x0
    12A1: 0E AC 01 ADC   [__r0],0x1
    12A4: 51 AC    MOV   A,[__r0]
    12A6: 60 D5    MOV   REG[0xD5],A
    12A8: 52 02    MOV   A,[X+2]
    12AA: 3F AB    MVI   [__r1],A
(0152) 	}
    12AC: 77 00    INC   [X+0]
    12AE: 3D 00 64 CMP   [X+0],0x64
    12B1: CF AA    JC    0x125C
(0153) 	//Send measured data
(0154) 	USBUART_1_CPutString("i,  input,  output");
    12B3: 10       PUSH  X
    12B4: 50 01    MOV   A,0x1
    12B6: 08       PUSH  A
    12B7: 50 B0    MOV   A,0xB0
    12B9: 5C       MOV   X,A
    12BA: 18       POP   A
    12BB: 7C 0C E8 LCALL _USBUART_1_CPutString
(0155) 	USBUART_1_PutCRLF();
    12BE: 7C 0D 26 LCALL _USBUART_1_PutCRLF
    12C1: 20       POP   X
(0156) 	for (index=0; index<ANALOG_SIZE; index++)
    12C2: 56 00 00 MOV   [X+0],0x0
    12C5: 80 D6    JMP   0x139C
(0157) 	{
(0158) 		ltoa(pTemp, index, 10);
    12C7: 50 00    MOV   A,0x0
    12C9: 08       PUSH  A
    12CA: 50 0A    MOV   A,0xA
    12CC: 08       PUSH  A
    12CD: 62 D0 00 MOV   REG[0xD0],0x0
    12D0: 52 00    MOV   A,[X+0]
    12D2: 53 A9    MOV   [__r3],A
    12D4: 50 00    MOV   A,0x0
    12D6: 08       PUSH  A
    12D7: 08       PUSH  A
    12D8: 08       PUSH  A
    12D9: 51 A9    MOV   A,[__r3]
    12DB: 08       PUSH  A
    12DC: 50 00    MOV   A,0x0
    12DE: 08       PUSH  A
    12DF: 50 AD    MOV   A,0xAD
    12E1: 08       PUSH  A
    12E2: 7C 14 5D LCALL _ltoa
    12E5: 38 F8    ADD   SP,0xF8
(0159) 		clear_pTemp();
    12E7: 9E C2    CALL  _clear_pTemp
(0160) 		USBUART_1_Write(pTemp, USB_STR_SIZE); /* Else, send back the received data */
    12E9: 10       PUSH  X
    12EA: 50 03    MOV   A,0x3
    12EC: 08       PUSH  A
    12ED: 50 00    MOV   A,0x0
    12EF: 08       PUSH  A
    12F0: 50 AD    MOV   A,0xAD
    12F2: 08       PUSH  A
    12F3: 7C 0C 33 LCALL _USBUART_1_Write
    12F6: 38 FD    ADD   SP,0xFD
    12F8: 20       POP   X
(0161) 		USBUART_1_CPutString(",  ");
    12F9: 10       PUSH  X
    12FA: 50 01    MOV   A,0x1
    12FC: 08       PUSH  A
    12FD: 50 AC    MOV   A,0xAC
    12FF: 5C       MOV   X,A
    1300: 18       POP   A
    1301: 7C 0C E8 LCALL _USBUART_1_CPutString
    1304: 20       POP   X
(0162) 		ltoa(pTemp, analog[index], 10);
    1305: 50 00    MOV   A,0x0
    1307: 08       PUSH  A
    1308: 50 0A    MOV   A,0xA
    130A: 08       PUSH  A
    130B: 62 D0 00 MOV   REG[0xD0],0x0
    130E: 52 00    MOV   A,[X+0]
    1310: 53 AB    MOV   [__r1],A
    1312: 55 AC 00 MOV   [__r0],0x0
    1315: 06 AB 42 ADD   [__r1],0x42
    1318: 0E AC 00 ADC   [__r0],0x0
    131B: 51 AC    MOV   A,[__r0]
    131D: 60 D4    MOV   REG[0xD4],A
    131F: 3E AB    MVI   A,[__r1]
    1321: 53 A9    MOV   [__r3],A
    1323: 50 00    MOV   A,0x0
    1325: 08       PUSH  A
    1326: 08       PUSH  A
    1327: 08       PUSH  A
    1328: 51 A9    MOV   A,[__r3]
    132A: 08       PUSH  A
    132B: 50 00    MOV   A,0x0
    132D: 08       PUSH  A
    132E: 50 AD    MOV   A,0xAD
    1330: 08       PUSH  A
    1331: 7C 14 5D LCALL _ltoa
    1334: 38 F8    ADD   SP,0xF8
(0163) 		clear_pTemp();
    1336: 9E 73    CALL  _clear_pTemp
(0164) 		USBUART_1_Write(pTemp, USB_STR_SIZE); /* Else, send back the received data */
    1338: 10       PUSH  X
    1339: 50 03    MOV   A,0x3
    133B: 08       PUSH  A
    133C: 50 00    MOV   A,0x0
    133E: 08       PUSH  A
    133F: 50 AD    MOV   A,0xAD
    1341: 08       PUSH  A
    1342: 7C 0C 33 LCALL _USBUART_1_Write
    1345: 38 FD    ADD   SP,0xFD
    1347: 20       POP   X
(0165) 		USBUART_1_CPutString(",  ");
    1348: 10       PUSH  X
    1349: 50 01    MOV   A,0x1
    134B: 08       PUSH  A
    134C: 50 AC    MOV   A,0xAC
    134E: 5C       MOV   X,A
    134F: 18       POP   A
    1350: 7C 0C E8 LCALL _USBUART_1_CPutString
    1353: 20       POP   X
(0166) 		ltoa(pTemp, measure_analog[index], 10);
    1354: 50 00    MOV   A,0x0
    1356: 08       PUSH  A
    1357: 50 0A    MOV   A,0xA
    1359: 08       PUSH  A
    135A: 62 D0 00 MOV   REG[0xD0],0x0
    135D: 52 00    MOV   A,[X+0]
    135F: 53 AB    MOV   [__r1],A
    1361: 55 AC 00 MOV   [__r0],0x0
    1364: 06 AB 00 ADD   [__r1],0x0
    1367: 0E AC 01 ADC   [__r0],0x1
    136A: 51 AC    MOV   A,[__r0]
    136C: 60 D4    MOV   REG[0xD4],A
    136E: 3E AB    MVI   A,[__r1]
    1370: 53 A9    MOV   [__r3],A
    1372: 50 00    MOV   A,0x0
    1374: 08       PUSH  A
    1375: 08       PUSH  A
    1376: 08       PUSH  A
    1377: 51 A9    MOV   A,[__r3]
    1379: 08       PUSH  A
    137A: 50 00    MOV   A,0x0
    137C: 08       PUSH  A
    137D: 50 AD    MOV   A,0xAD
    137F: 08       PUSH  A
    1380: 7C 14 5D LCALL _ltoa
    1383: 38 F8    ADD   SP,0xF8
(0167) 		clear_pTemp();
    1385: 9E 24    CALL  _clear_pTemp
(0168) 		USBUART_1_Write(pTemp, USB_STR_SIZE); /* Else, send back the received data */
    1387: 10       PUSH  X
    1388: 50 03    MOV   A,0x3
    138A: 08       PUSH  A
    138B: 50 00    MOV   A,0x0
    138D: 08       PUSH  A
    138E: 50 AD    MOV   A,0xAD
    1390: 08       PUSH  A
    1391: 7C 0C 33 LCALL _USBUART_1_Write
    1394: 38 FD    ADD   SP,0xFD
(0169) 		USBUART_1_PutCRLF();
    1396: 7C 0D 26 LCALL _USBUART_1_PutCRLF
    1399: 20       POP   X
(0170) 	}
    139A: 77 00    INC   [X+0]
    139C: 3D 00 64 CMP   [X+0],0x64
    139F: CF 27    JC    0x12C7
(0171) 	USBUART_1_CPutString("End of Test");		
    13A1: 10       PUSH  X
    13A2: 50 01    MOV   A,0x1
    13A4: 08       PUSH  A
    13A5: 50 A0    MOV   A,0xA0
    13A7: 5C       MOV   X,A
    13A8: 18       POP   A
    13A9: 7C 0C E8 LCALL _USBUART_1_CPutString
    13AC: 20       POP   X
(0172) 	while(1)
(0173) 	{
(0174) 		// End
(0175) 	}
    13AD: 8F FF    JMP   0x13AD
(0176) }
(0177) 
FILE: lib\usbuart_1int.asm              (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME: USBUART_1Int.asm
                                        (0004) ;;  Version: 1.40, Updated on 2011/3/29 at 14:31:18
                                        (0005) ;;  Generated by PSoC Designer 5.1.2110.0
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: USBFS User Module software implementation file
                                        (0008) ;;
                                        (0009) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                        (0010) ;;        arguments and observe the associated "Registers are volatile" policy.
                                        (0011) ;;        This means it is the caller's responsibility to preserve any values
                                        (0012) ;;        in the X and A registers that are still needed after the API functions
                                        (0013) ;;        returns. For Large Memory Model devices it is also the caller's
                                        (0014) ;;        responsibility to preserve any value in the CUR_PP, IDX_PP, MVR_PP and
                                        (0015) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                        (0016) ;;        now, there is no guarantee that will remain the case in future releases.
                                        (0017) ;;-----------------------------------------------------------------------------
                                        (0018) ;;  Copyright (c) Cypress Semiconductor 2011. All Rights Reserved.
                                        (0019) ;;*****************************************************************************
                                        (0020) ;;*****************************************************************************
                                        (0021) 
                                        (0022) include "m8c.inc"
                                        (0023) include "memory.inc"
                                        (0024) include "USBUART_1.inc"
                                        (0025) 
                                        (0026) ;-----------------------------------------------
                                        (0027) ; include instance specific register definitions
                                        (0028) ;-----------------------------------------------
                                        (0029) 
                                        (0030) ;-----------------------------------------------
                                        (0031) ;  Global Symbols
                                        (0032) ;-----------------------------------------------
                                        (0033) ;-------------------------------------------------------------------
                                        (0034) ;  Declare the functions global for both assembler and C compiler.
                                        (0035) ;
                                        (0036) ;  Note that there are two names for each API. First name is
                                        (0037) ;  assembler reference. Name with underscore is name reference for
                                        (0038) ;  C compiler.  Calling function in C source code does not require
                                        (0039) ;  the underscore.
                                        (0040) ;-------------------------------------------------------------------
                                        (0041) 
                                        (0042) export    USBUART_1_EP1_ISR
                                        (0043) export   _USBUART_1_EP1_ISR
                                        (0044) export    USBUART_1_EP2_ISR
                                        (0045) export   _USBUART_1_EP2_ISR
                                        (0046) export    USBUART_1_EP3_ISR
                                        (0047) export   _USBUART_1_EP3_ISR
                                        (0048) export    USBUART_1_EP4_ISR
                                        (0049) export   _USBUART_1_EP4_ISR
                                        (0050) export    USBUART_1_RESET_ISR
                                        (0051) export   _USBUART_1_RESET_ISR
                                        (0052) export    USBUART_1_SOF_ISR
                                        (0053) export   _USBUART_1_SOF_ISR
                                        (0054) export    USBUART_1_WAKEUP_ISR
                                        (0055) export   _USBUART_1_WAKEUP_ISR
                                        (0056) 
                                        (0057) 
                                        (0058) AREA InterruptRAM (RAM, REL, CON)
                                        (0059) ;@PSoC_UserCode_INIT@ (Do not change this line.)
                                        (0060) ;---------------------------------------------------
                                        (0061) ; Insert your custom declarations below this banner
                                        (0062) ;---------------------------------------------------
                                        (0063) 
                                        (0064) ;------------------------
                                        (0065) ; Includes
                                        (0066) ;------------------------
                                        (0067) 
                                        (0068) 
                                        (0069) ;------------------------
                                        (0070) ;  Constant Definitions
                                        (0071) ;------------------------
                                        (0072) 
                                        (0073) 
                                        (0074) ;------------------------
                                        (0075) ; Variable Allocation
                                        (0076) ;------------------------
                                        (0077) 
                                        (0078) 
                                        (0079) ;---------------------------------------------------
                                        (0080) ; Insert your custom declarations above this banner
                                        (0081) ;---------------------------------------------------
                                        (0082) ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0083) 
                                        (0084) AREA text (ROM, REL)
                                        (0085) 
                                        (0086) 
                                        (0087)  USBUART_1_EP1_ISR:
                                        (0088) _USBUART_1_EP1_ISR:
                                        (0089) 
13B4: 55 23 01 MOV   [0x23],0x1         (0090)    mov  [USBUART_1_EndpointAPIStatus + 1], EVENT_PENDING
                                        (0091)    ;@PSoC_UserCode_BODY_1@ (Do not change this line.)
                                        (0092)    ;---------------------------------------------------
                                        (0093)    ; Insert your custom assembly code below this banner
                                        (0094)    ;---------------------------------------------------
                                        (0095)    ;   NOTE: interrupt service routines must preserve
                                        (0096)    ;   the values of the A and X CPU registers.
                                        (0097)    
                                        (0098)    ;---------------------------------------------------
                                        (0099)    ; Insert your custom assembly code above this banner
                                        (0100)    ;---------------------------------------------------
                                        (0101)    
                                        (0102)    ;---------------------------------------------------
                                        (0103)    ; Insert a lcall to a C function below this banner
                                        (0104)    ; and un-comment the lines between these banners
                                        (0105)    ;---------------------------------------------------
                                        (0106)    
                                        (0107)    ;PRESERVE_CPU_CONTEXT
                                        (0108)    ;lcall _My_C_Function
                                        (0109)    ;RESTORE_CPU_CONTEXT
                                        (0110)    
                                        (0111)    ;---------------------------------------------------
                                        (0112)    ; Insert a lcall to a C function above this banner
                                        (0113)    ; and un-comment the lines between these banners
                                        (0114)    ;---------------------------------------------------
                                        (0115)    ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0116) 
13B7: 7E       RETI                     (0117)    reti
                                        (0118) 
                                        (0119)  USBUART_1_EP2_ISR:
                                        (0120) _USBUART_1_EP2_ISR:
                                        (0121) 
13B8: 55 24 01 MOV   [0x24],0x1         (0122)    mov  [USBUART_1_EndpointAPIStatus + 2], EVENT_PENDING
                                        (0123)    ;@PSoC_UserCode_BODY_2@ (Do not change this line.)
                                        (0124)    ;---------------------------------------------------
                                        (0125)    ; Insert your custom assembly code below this banner
                                        (0126)    ;---------------------------------------------------
                                        (0127)    ;   NOTE: interrupt service routines must preserve
                                        (0128)    ;   the values of the A and X CPU registers.
                                        (0129)    
                                        (0130)    ;---------------------------------------------------
                                        (0131)    ; Insert your custom assembly code above this banner
                                        (0132)    ;---------------------------------------------------
                                        (0133)    
                                        (0134)    ;---------------------------------------------------
                                        (0135)    ; Insert a lcall to a C function below this banner
                                        (0136)    ; and un-comment the lines between these banners
                                        (0137)    ;---------------------------------------------------
                                        (0138)    
                                        (0139)    ;PRESERVE_CPU_CONTEXT
                                        (0140)    ;lcall _My_C_Function
                                        (0141)    ;RESTORE_CPU_CONTEXT
                                        (0142)    
                                        (0143)    ;---------------------------------------------------
                                        (0144)    ; Insert a lcall to a C function above this banner
                                        (0145)    ; and un-comment the lines between these banners
                                        (0146)    ;---------------------------------------------------
                                        (0147)    ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0148) 
13BB: 7E       RETI                     (0149)    reti
                                        (0150) 
                                        (0151)  USBUART_1_EP3_ISR:
                                        (0152) _USBUART_1_EP3_ISR:
                                        (0153) 
13BC: 55 25 01 MOV   [0x25],0x1         (0154)    mov  [USBUART_1_EndpointAPIStatus + 3], EVENT_PENDING
                                        (0155)    ;@PSoC_UserCode_BODY_3@ (Do not change this line.)
                                        (0156)    ;---------------------------------------------------
                                        (0157)    ; Insert your custom assembly code below this banner
                                        (0158)    ;---------------------------------------------------
                                        (0159)    ;   NOTE: interrupt service routines must preserve
                                        (0160)    ;   the values of the A and X CPU registers.
                                        (0161)    
                                        (0162)    ;---------------------------------------------------
                                        (0163)    ; Insert your custom assembly code above this banner
                                        (0164)    ;---------------------------------------------------
                                        (0165)    
                                        (0166)    ;---------------------------------------------------
                                        (0167)    ; Insert a lcall to a C function below this banner
                                        (0168)    ; and un-comment the lines between these banners
                                        (0169)    ;---------------------------------------------------
                                        (0170)    
                                        (0171)    ;PRESERVE_CPU_CONTEXT
                                        (0172)    ;lcall _My_C_Function
                                        (0173)    ;RESTORE_CPU_CONTEXT
                                        (0174)    
                                        (0175)    ;---------------------------------------------------
                                        (0176)    ; Insert a lcall to a C function above this banner
                                        (0177)    ; and un-comment the lines between these banners
                                        (0178)    ;---------------------------------------------------
                                        (0179)    ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0180) 
13BF: 7E       RETI                     (0181)    reti
                                        (0182) 
                                        (0183)  USBUART_1_EP4_ISR:
                                        (0184) _USBUART_1_EP4_ISR:
                                        (0185) 
13C0: 55 26 01 MOV   [0x26],0x1         (0186)    mov  [USBUART_1_EndpointAPIStatus + 4], EVENT_PENDING
                                        (0187)    ;@PSoC_UserCode_BODY_4@ (Do not change this line.)
                                        (0188)    ;---------------------------------------------------
                                        (0189)    ; Insert your custom assembly code below this banner
                                        (0190)    ;---------------------------------------------------
                                        (0191)    ;   NOTE: interrupt service routines must preserve
                                        (0192)    ;   the values of the A and X CPU registers.
                                        (0193)    
                                        (0194)    ;---------------------------------------------------
                                        (0195)    ; Insert your custom assembly code above this banner
                                        (0196)    ;---------------------------------------------------
                                        (0197)    
                                        (0198)    ;---------------------------------------------------
                                        (0199)    ; Insert a lcall to a C function below this banner
                                        (0200)    ; and un-comment the lines between these banners
                                        (0201)    ;---------------------------------------------------
                                        (0202)    
                                        (0203)    ;PRESERVE_CPU_CONTEXT
                                        (0204)    ;lcall _My_C_Function
                                        (0205)    ;RESTORE_CPU_CONTEXT
                                        (0206)    
                                        (0207)    ;---------------------------------------------------
                                        (0208)    ; Insert a lcall to a C function above this banner
                                        (0209)    ; and un-comment the lines between these banners
                                        (0210)    ;---------------------------------------------------
                                        (0211)    ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0212) 
13C3: 7E       RETI                     (0213)    reti
                                        (0214) 
                                        (0215)  USBUART_1_RESET_ISR:
                                        (0216) _USBUART_1_RESET_ISR:
13C4: 08       PUSH  A                  (0217)    push    A
13C5: 50 00    MOV   A,0x0              (0218)    mov     A, 0
13C7: 53 01    MOV   [0x1],A            (0219)    mov     [USBUART_1_Configuration], A
13C9: 53 02    MOV   [0x2],A            (0220)    mov     [USBUART_1_DeviceStatus], A
13CB: 53 03    MOV   [0x3],A            (0221)    mov     [USBUART_1_InterfaceSetting], A
13CD: 53 05    MOV   [0x5],A            (0222)    mov     [USBUART_1_EndpointStatus], A
13CF: 53 0B    MOV   [0xB],A            (0223)    mov     [USBUART_1_TransferType], A
13D1: 53 1E    MOV   [0x1E],A           (0224)    mov     [USBUART_1_fDataPending], A
13D3: 62 56 03 MOV   REG[0x56],0x3      (0225)    mov     reg[USBUART_1_EP0MODE], USB_MODE_STALL_IN_OUT ; ACK Setup/Stall IN/OUT
13D6: 71 10    OR    F,0x10             
                                        (0226)    M8C_SetBank1
13D8: 60 C4    MOV   REG[0xC4],A        (0227)    mov     reg[USBUART_1_EP1MODE], A
13DA: 60 C5    MOV   REG[0xC5],A        (0228)    mov     reg[USBUART_1_EP2MODE], A
13DC: 60 C6    MOV   REG[0xC6],A        (0229)    mov     reg[USBUART_1_EP3MODE], A
13DE: 60 C7    MOV   REG[0xC7],A        (0230)    mov     reg[USBUART_1_EP4MODE], A
13E0: 70 EF    AND   F,0xEF             
                                        (0231)    M8C_SetBank0
13E2: 53 1D    MOV   [0x1D],A           (0232)    mov     [USBUART_1_EPDataToggle], A   ; Clear all EP data toggles
                                        (0233) 
                                        (0234) ;   mov     X, USB_MAX_EP_NUMBER       ; Set up loop to clear all of the endpoint data items
                                        (0235) ;.loop:
                                        (0236) ;   mov     [X + USBUART_1_EPDataToggle], 0  ; Or in the toggle
                                        (0237) ;   dec     X                          ; Are we done?
                                        (0238) ;   jnz     .loop                      ; Jump to do another endpoint
                                        (0239) 
13E4: 62 4A 80 MOV   REG[0x4A],0x80     (0240)    mov     reg[USBUART_1_ADDR], USB_ADDR_ENABLE ; Enable Address 0
                                        (0241) 
                                        (0242)    ;@PSoC_UserCode_BODY_5@ (Do not change this line.)
                                        (0243)    ;---------------------------------------------------
                                        (0244)    ; Insert your custom assembly code below this banner
                                        (0245)    ;---------------------------------------------------
                                        (0246)    ;   NOTE: interrupt service routines must preserve
                                        (0247)    ;   the values of the A and X CPU registers.
                                        (0248)    
                                        (0249)    ;---------------------------------------------------
                                        (0250)    ; Insert your custom assembly code above this banner
                                        (0251)    ;---------------------------------------------------
                                        (0252)    
                                        (0253)    ;---------------------------------------------------
                                        (0254)    ; Insert a lcall to a C function below this banner
                                        (0255)    ; and un-comment the lines between these banners
                                        (0256)    ;---------------------------------------------------
                                        (0257)    
                                        (0258)    ;PRESERVE_CPU_CONTEXT
                                        (0259)    ;lcall _My_C_Function
                                        (0260)    ;RESTORE_CPU_CONTEXT
                                        (0261)    
                                        (0262)    ;---------------------------------------------------
                                        (0263)    ; Insert a lcall to a C function above this banner
                                        (0264)    ; and un-comment the lines between these banners
                                        (0265)    ;---------------------------------------------------
                                        (0266)    ;@PSoC_UserCode_END@ (Do not change this line.)
13E7: 18       POP   A                  (0267)    pop  A
13E8: 7E       RETI                     (0268)    reti
                                        (0269) 
                                        (0270)  USBUART_1_SOF_ISR:
                                        (0271) _USBUART_1_SOF_ISR:
                                        (0272) 
                                        (0273)    ;@PSoC_UserCode_BODY_6@ (Do not change this line.)
                                        (0274)    ;---------------------------------------------------
                                        (0275)    ; Insert your custom assembly code below this banner
                                        (0276)    ;---------------------------------------------------
                                        (0277)    ;   NOTE: interrupt service routines must preserve
                                        (0278)    ;   the values of the A and X CPU registers.
                                        (0279)    
                                        (0280)    ;---------------------------------------------------
                                        (0281)    ; Insert your custom assembly code above this banner
                                        (0282)    ;---------------------------------------------------
                                        (0283)    
                                        (0284)    ;---------------------------------------------------
                                        (0285)    ; Insert a lcall to a C function below this banner
                                        (0286)    ; and un-comment the lines between these banners
                                        (0287)    ;---------------------------------------------------
                                        (0288)    
                                        (0289)    ;PRESERVE_CPU_CONTEXT
                                        (0290)    ;lcall _My_C_Function
                                        (0291)    ;RESTORE_CPU_CONTEXT
                                        (0292)    
                                        (0293)    ;---------------------------------------------------
                                        (0294)    ; Insert a lcall to a C function above this banner
                                        (0295)    ; and un-comment the lines between these banners
                                        (0296)    ;---------------------------------------------------
                                        (0297)    ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0298) 
13E9: 7E       RETI                     (0299)    reti
                                        (0300) 
                                        (0301)  USBUART_1_WAKEUP_ISR:
                                        (0302) _USBUART_1_WAKEUP_ISR:
                                        (0303) 
                                        (0304)    ;@PSoC_UserCode_BODY_7@ (Do not change this line.)
                                        (0305)    ;---------------------------------------------------
                                        (0306)    ; Insert your custom assembly code below this banner
                                        (0307)    ;---------------------------------------------------
                                        (0308)    ;   NOTE: interrupt service routines must preserve
                                        (0309)    ;   the values of the A and X CPU registers.
                                        (0310)    
                                        (0311)    ;---------------------------------------------------
                                        (0312)    ; Insert your custom assembly code above this banner
                                        (0313)    ;---------------------------------------------------
                                        (0314)    
                                        (0315)    ;---------------------------------------------------
                                        (0316)    ; Insert a lcall to a C function below this banner
                                        (0317)    ; and un-comment the lines between these banners
                                        (0318)    ;---------------------------------------------------
                                        (0319)    
                                        (0320)    ;PRESERVE_CPU_CONTEXT
                                        (0321)    ;lcall _My_C_Function
                                        (0322)    ;RESTORE_CPU_CONTEXT
                                        (0323)    
                                        (0324)    ;---------------------------------------------------
                                        (0325)    ; Insert a lcall to a C function above this banner
                                        (0326)    ; and un-comment the lines between these banners
                                        (0327)    ;---------------------------------------------------
                                        (0328)    ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0329) 
13EA: 7E       RETI                     (0330)    reti
                                        (0331) 
                                        (0332) ; End of File USBUART_1.asm
_ltoa:
    145D: 10       PUSH  X
    145E: 4F       MOV   X,SP
    145F: 38 0B    ADD   SP,0xB
    1461: 52 F7    MOV   A,[X-9]
    1463: 54 02    MOV   [X+2],A
    1465: 52 F8    MOV   A,[X-8]
    1467: 54 03    MOV   [X+3],A
    1469: 52 F9    MOV   A,[X-7]
    146B: 54 04    MOV   [X+4],A
    146D: 52 FA    MOV   A,[X-6]
    146F: 54 05    MOV   [X+5],A
    1471: 3D F7 00 CMP   [X-9],0x0
    1474: B0 39    JNZ   0x14AE
    1476: 3D F8 00 CMP   [X-8],0x0
    1479: B0 34    JNZ   0x14AE
    147B: 3D F9 00 CMP   [X-7],0x0
    147E: B0 2F    JNZ   0x14AE
    1480: 3D FA 00 CMP   [X-6],0x0
    1483: B0 2A    JNZ   0x14AE
    1485: 62 D0 00 MOV   REG[0xD0],0x0
    1488: 52 FC    MOV   A,[X-4]
    148A: 53 AB    MOV   [__r1],A
    148C: 52 FB    MOV   A,[X-5]
    148E: 60 D5    MOV   REG[0xD5],A
    1490: 50 30    MOV   A,0x30
    1492: 3F AB    MVI   [__r1],A
    1494: 52 FC    MOV   A,[X-4]
    1496: 01 01    ADD   A,0x1
    1498: 53 AB    MOV   [__r1],A
    149A: 52 FB    MOV   A,[X-5]
    149C: 09 00    ADC   A,0x0
    149E: 60 D5    MOV   REG[0xD5],A
    14A0: 50 00    MOV   A,0x0
    14A2: 3F AB    MVI   [__r1],A
    14A4: 52 FC    MOV   A,[X-4]
    14A6: 53 AB    MOV   [__r1],A
    14A8: 52 FB    MOV   A,[X-5]
    14AA: 53 AC    MOV   [__r0],A
    14AC: 82 25    JMP   0x16D2
    14AE: 52 FA    MOV   A,[X-6]
    14B0: 11 00    SUB   A,0x0
    14B2: 52 F9    MOV   A,[X-7]
    14B4: 19 00    SBB   A,0x0
    14B6: 52 F8    MOV   A,[X-8]
    14B8: 19 00    SBB   A,0x0
    14BA: 52 F7    MOV   A,[X-9]
    14BC: 31 80    XOR   A,0x80
    14BE: 19 80    SBB   A,0x80
    14C0: D0 3B    JNC   0x14FC
    14C2: 3D F5 00 CMP   [X-11],0x0
    14C5: B0 36    JNZ   0x14FC
    14C7: 3D F6 0A CMP   [X-10],0xA
    14CA: B0 31    JNZ   0x14FC
    14CC: 56 08 01 MOV   [X+8],0x1
    14CF: 62 D0 00 MOV   REG[0xD0],0x0
    14D2: 52 02    MOV   A,[X+2]
    14D4: 73       CPL   A
    14D5: 53 AC    MOV   [__r0],A
    14D7: 52 03    MOV   A,[X+3]
    14D9: 73       CPL   A
    14DA: 53 AB    MOV   [__r1],A
    14DC: 52 04    MOV   A,[X+4]
    14DE: 73       CPL   A
    14DF: 53 AA    MOV   [__r2],A
    14E1: 52 05    MOV   A,[X+5]
    14E3: 73       CPL   A
    14E4: 01 01    ADD   A,0x1
    14E6: 54 05    MOV   [X+5],A
    14E8: 51 AA    MOV   A,[__r2]
    14EA: 09 00    ADC   A,0x0
    14EC: 54 04    MOV   [X+4],A
    14EE: 51 AB    MOV   A,[__r1]
    14F0: 09 00    ADC   A,0x0
    14F2: 54 03    MOV   [X+3],A
    14F4: 51 AC    MOV   A,[__r0]
    14F6: 09 00    ADC   A,0x0
    14F8: 54 02    MOV   [X+2],A
    14FA: 80 04    JMP   0x14FF
    14FC: 56 08 00 MOV   [X+8],0x0
    14FF: 52 FC    MOV   A,[X-4]
    1501: 54 01    MOV   [X+1],A
    1503: 52 FB    MOV   A,[X-5]
    1505: 54 00    MOV   [X+0],A
    1507: 62 D0 00 MOV   REG[0xD0],0x0
    150A: 52 F6    MOV   A,[X-10]
    150C: 53 A9    MOV   [__r3],A
    150E: 52 F5    MOV   A,[X-11]
    1510: 53 AA    MOV   [__r2],A
    1512: 47 AA 80 TST   [__r2],0x80
    1515: A0 09    JZ    0x151F
    1517: 55 AB FF MOV   [__r1],0xFF
    151A: 55 AC FF MOV   [__r0],0xFF
    151D: 80 0A    JMP   0x1528
    151F: 62 D0 00 MOV   REG[0xD0],0x0
    1522: 55 AB 00 MOV   [__r1],0x0
    1525: 55 AC 00 MOV   [__r0],0x0
    1528: 62 D0 00 MOV   REG[0xD0],0x0
    152B: 51 AC    MOV   A,[__r0]
    152D: 08       PUSH  A
    152E: 51 AB    MOV   A,[__r1]
    1530: 08       PUSH  A
    1531: 51 AA    MOV   A,[__r2]
    1533: 08       PUSH  A
    1534: 51 A9    MOV   A,[__r3]
    1536: 08       PUSH  A
    1537: 52 02    MOV   A,[X+2]
    1539: 08       PUSH  A
    153A: 52 03    MOV   A,[X+3]
    153C: 08       PUSH  A
    153D: 52 04    MOV   A,[X+4]
    153F: 08       PUSH  A
    1540: 52 05    MOV   A,[X+5]
    1542: 08       PUSH  A
    1543: 7C 13 EB LCALL 0x13EB
    1546: 38 FC    ADD   SP,0xFC
    1548: 18       POP   A
    1549: 53 A9    MOV   [__r3],A
    154B: 18       POP   A
    154C: 53 AA    MOV   [__r2],A
    154E: 18       POP   A
    154F: 18       POP   A
    1550: 51 A9    MOV   A,[__r3]
    1552: 53 AB    MOV   [__r1],A
    1554: 51 AA    MOV   A,[__r2]
    1556: 53 AC    MOV   [__r0],A
    1558: 51 AB    MOV   A,[__r1]
    155A: 54 0A    MOV   [X+10],A
    155C: 51 AC    MOV   A,[__r0]
    155E: 54 09    MOV   [X+9],A
    1560: 50 09    MOV   A,0x9
    1562: 13 0A    SUB   A,[X+10]
    1564: 52 09    MOV   A,[X+9]
    1566: 31 80    XOR   A,0x80
    1568: 53 A8    MOV   [__rX],A
    156A: 50 80    MOV   A,0x80
    156C: 1A A8    SBB   A,[__rX]
    156E: C0 28    JC    0x1597
    1570: 62 D0 00 MOV   REG[0xD0],0x0
    1573: 52 01    MOV   A,[X+1]
    1575: 53 AB    MOV   [__r1],A
    1577: 52 00    MOV   A,[X+0]
    1579: 53 AC    MOV   [__r0],A
    157B: 51 AB    MOV   A,[__r1]
    157D: 01 01    ADD   A,0x1
    157F: 54 01    MOV   [X+1],A
    1581: 51 AC    MOV   A,[__r0]
    1583: 09 00    ADC   A,0x0
    1585: 54 00    MOV   [X+0],A
    1587: 52 0A    MOV   A,[X+10]
    1589: 01 30    ADD   A,0x30
    158B: 53 AA    MOV   [__r2],A
    158D: 51 AC    MOV   A,[__r0]
    158F: 60 D5    MOV   REG[0xD5],A
    1591: 51 AA    MOV   A,[__r2]
    1593: 3F AB    MVI   [__r1],A
    1595: 80 26    JMP   0x15BC
    1597: 62 D0 00 MOV   REG[0xD0],0x0
    159A: 52 01    MOV   A,[X+1]
    159C: 53 AB    MOV   [__r1],A
    159E: 52 00    MOV   A,[X+0]
    15A0: 53 AC    MOV   [__r0],A
    15A2: 51 AB    MOV   A,[__r1]
    15A4: 01 01    ADD   A,0x1
    15A6: 54 01    MOV   [X+1],A
    15A8: 51 AC    MOV   A,[__r0]
    15AA: 09 00    ADC   A,0x0
    15AC: 54 00    MOV   [X+0],A
    15AE: 52 0A    MOV   A,[X+10]
    15B0: 01 57    ADD   A,0x57
    15B2: 53 AA    MOV   [__r2],A
    15B4: 51 AC    MOV   A,[__r0]
    15B6: 60 D5    MOV   REG[0xD5],A
    15B8: 51 AA    MOV   A,[__r2]
    15BA: 3F AB    MVI   [__r1],A
    15BC: 62 D0 00 MOV   REG[0xD0],0x0
    15BF: 52 F6    MOV   A,[X-10]
    15C1: 53 A9    MOV   [__r3],A
    15C3: 52 F5    MOV   A,[X-11]
    15C5: 53 AA    MOV   [__r2],A
    15C7: 47 AA 80 TST   [__r2],0x80
    15CA: A0 09    JZ    0x15D4
    15CC: 55 AB FF MOV   [__r1],0xFF
    15CF: 55 AC FF MOV   [__r0],0xFF
    15D2: 80 0A    JMP   0x15DD
    15D4: 62 D0 00 MOV   REG[0xD0],0x0
    15D7: 55 AB 00 MOV   [__r1],0x0
    15DA: 55 AC 00 MOV   [__r0],0x0
    15DD: 62 D0 00 MOV   REG[0xD0],0x0
    15E0: 51 AC    MOV   A,[__r0]
    15E2: 08       PUSH  A
    15E3: 51 AB    MOV   A,[__r1]
    15E5: 08       PUSH  A
    15E6: 51 AA    MOV   A,[__r2]
    15E8: 08       PUSH  A
    15E9: 51 A9    MOV   A,[__r3]
    15EB: 08       PUSH  A
    15EC: 52 02    MOV   A,[X+2]
    15EE: 08       PUSH  A
    15EF: 52 03    MOV   A,[X+3]
    15F1: 08       PUSH  A
    15F2: 52 04    MOV   A,[X+4]
    15F4: 08       PUSH  A
    15F5: 52 05    MOV   A,[X+5]
    15F7: 08       PUSH  A
    15F8: 7C 13 EB LCALL 0x13EB
    15FB: 18       POP   A
    15FC: 54 05    MOV   [X+5],A
    15FE: 18       POP   A
    15FF: 54 04    MOV   [X+4],A
    1601: 18       POP   A
    1602: 54 03    MOV   [X+3],A
    1604: 18       POP   A
    1605: 54 02    MOV   [X+2],A
    1607: 38 FC    ADD   SP,0xFC
    1609: 3D 02 00 CMP   [X+2],0x0
    160C: BE FA    JNZ   0x1507
    160E: 3D 03 00 CMP   [X+3],0x0
    1611: BE F5    JNZ   0x1507
    1613: 3D 04 00 CMP   [X+4],0x0
    1616: BE F0    JNZ   0x1507
    1618: 3D 05 00 CMP   [X+5],0x0
    161B: BE EB    JNZ   0x1507
    161D: 3D 08 00 CMP   [X+8],0x0
    1620: A0 20    JZ    0x1641
    1622: 62 D0 00 MOV   REG[0xD0],0x0
    1625: 52 01    MOV   A,[X+1]
    1627: 53 AB    MOV   [__r1],A
    1629: 52 00    MOV   A,[X+0]
    162B: 53 AC    MOV   [__r0],A
    162D: 51 AB    MOV   A,[__r1]
    162F: 01 01    ADD   A,0x1
    1631: 54 01    MOV   [X+1],A
    1633: 51 AC    MOV   A,[__r0]
    1635: 09 00    ADC   A,0x0
    1637: 54 00    MOV   [X+0],A
    1639: 51 AC    MOV   A,[__r0]
    163B: 60 D5    MOV   REG[0xD5],A
    163D: 50 2D    MOV   A,0x2D
    163F: 3F AB    MVI   [__r1],A
    1641: 62 D0 00 MOV   REG[0xD0],0x0
    1644: 52 01    MOV   A,[X+1]
    1646: 53 AB    MOV   [__r1],A
    1648: 52 00    MOV   A,[X+0]
    164A: 53 AC    MOV   [__r0],A
    164C: 51 AB    MOV   A,[__r1]
    164E: 01 FF    ADD   A,0xFF
    1650: 54 01    MOV   [X+1],A
    1652: 51 AC    MOV   A,[__r0]
    1654: 09 FF    ADC   A,0xFF
    1656: 54 00    MOV   [X+0],A
    1658: 51 AC    MOV   A,[__r0]
    165A: 60 D5    MOV   REG[0xD5],A
    165C: 50 00    MOV   A,0x0
    165E: 3F AB    MVI   [__r1],A
    1660: 52 FC    MOV   A,[X-4]
    1662: 54 07    MOV   [X+7],A
    1664: 52 FB    MOV   A,[X-5]
    1666: 54 06    MOV   [X+6],A
    1668: 80 54    JMP   0x16BD
    166A: 62 D0 00 MOV   REG[0xD0],0x0
    166D: 52 07    MOV   A,[X+7]
    166F: 53 AB    MOV   [__r1],A
    1671: 52 06    MOV   A,[X+6]
    1673: 60 D4    MOV   REG[0xD4],A
    1675: 3E AB    MVI   A,[__r1]
    1677: 54 08    MOV   [X+8],A
    1679: 52 07    MOV   A,[X+7]
    167B: 53 AB    MOV   [__r1],A
    167D: 52 06    MOV   A,[X+6]
    167F: 53 AC    MOV   [__r0],A
    1681: 51 AB    MOV   A,[__r1]
    1683: 01 01    ADD   A,0x1
    1685: 54 07    MOV   [X+7],A
    1687: 51 AC    MOV   A,[__r0]
    1689: 09 00    ADC   A,0x0
    168B: 54 06    MOV   [X+6],A
    168D: 52 01    MOV   A,[X+1]
    168F: 53 A9    MOV   [__r3],A
    1691: 52 00    MOV   A,[X+0]
    1693: 60 D4    MOV   REG[0xD4],A
    1695: 3E A9    MVI   A,[__r3]
    1697: 53 AA    MOV   [__r2],A
    1699: 51 AC    MOV   A,[__r0]
    169B: 60 D5    MOV   REG[0xD5],A
    169D: 51 AA    MOV   A,[__r2]
    169F: 3F AB    MVI   [__r1],A
    16A1: 52 01    MOV   A,[X+1]
    16A3: 53 AB    MOV   [__r1],A
    16A5: 52 00    MOV   A,[X+0]
    16A7: 53 AC    MOV   [__r0],A
    16A9: 51 AB    MOV   A,[__r1]
    16AB: 01 FF    ADD   A,0xFF
    16AD: 54 01    MOV   [X+1],A
    16AF: 51 AC    MOV   A,[__r0]
    16B1: 09 FF    ADC   A,0xFF
    16B3: 54 00    MOV   [X+0],A
    16B5: 51 AC    MOV   A,[__r0]
    16B7: 60 D5    MOV   REG[0xD5],A
    16B9: 52 08    MOV   A,[X+8]
    16BB: 3F AB    MVI   [__r1],A
    16BD: 52 07    MOV   A,[X+7]
    16BF: 13 01    SUB   A,[X+1]
    16C1: 52 06    MOV   A,[X+6]
    16C3: 1B 00    SBB   A,[X+0]
    16C5: CF A4    JC    0x166A
    16C7: 62 D0 00 MOV   REG[0xD0],0x0
    16CA: 52 FC    MOV   A,[X-4]
    16CC: 53 AB    MOV   [__r1],A
    16CE: 52 FB    MOV   A,[X-5]
    16D0: 53 AC    MOV   [__r0],A
    16D2: 38 F5    ADD   SP,0xF5
    16D4: 20       POP   X
    16D5: 7F       RET   
